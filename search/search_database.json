var tipuesearch = {"pages":[{"title":" slsqp ","text":"slsqp Modern Fortran Edition of the SLSQP Optimizer Status Description This is an updated version of the SLSQP nonlinear constrained optimization code. It can be used to solve nonlinear programming problems that seek to minimize a scalar performance index subject to nonlinear equality and inequality constraints as well as bounds on the variables. Updates to the original code include: It has been translated into free-form source. It is now thread safe. The original version was not thread safe due to the use of saved variables in one of the subroutines. It no longer uses obsolescent and non-standard Fortran features. It should now be 100% standard compliant (Fortran 2008). It now has an easy-to-use object-oriented interface. The slsqp_class is used for all interactions with the solver. Methods include initialize() , optimize() , and destroy() . It includes updated versions of some of the third-party routines used in the original code (BLAS, LINPACK, and NNLS). Some new features were added to support printing error  messages and reporting iterations to the user. The user can now specify the max and min alpha to use during the line search. The user can supply a routine to compute the gradients of the objective function and constraints, or allow the code to estimate them using finite differences (backward, forward, or central). The documentation strings in the code have been converted to FORD format, allowing for nicely formatted documentation to be auto-generated. A couple of bug fixes noted elsewhere have been applied. Building SLSQP Fortran Package Manager The library can be built with the Fortran Package Manager using the provided fpm.toml file like so: fpm build --release By default, the library is built with double precision ( real64 ) real values. Explicitly specifying the real kind can be done using the following processor flags: Preprocessor flag Kind Number of bytes REAL32 real(kind=real32) 4 REAL64 real(kind=real64) 8 REAL128 real(kind=real128) 16 For example, to build a single precision version of the library, use: fpm build --profile release --flag \"-DREAL32\" To use SLSQP within your fpm project, add the following to your fpm.toml file: [dependencies] slsqp = { git = \"https://github.com/jacobwilliams/slsqp.git\" } or, to use a specific version: [dependencies] slsqp = { git = \"https://github.com/jacobwilliams/slsqp.git\" , tag = \"1.3.0\" } Dependencies The library requires some BLAS routines, which are included. However, the user may also choose to link to an external BLAS library. This can be done by using the HAS_BLAS compiler directive. For example: fpm build --compiler gfortran --flag \"-DHAS_BLAS -lblas\" However, note that an external BLAS can only be used if the library is compiled with double precision ( real64 ) reals. Documentation The latest API documentation can be found here . This was generated from the source code using FORD . License The original sourcecode and the modifications are released under a permissive BSD-style license . Development Development continues on GitHub . References Original sourcecode at NETLIB D. Kraft, \" A software package for sequential quadratic programming \",\n  Technical Report DFVLR-FB 88-28, Institut für Dynamik der Flugsysteme,\n  Oberpfaffenhofen, July 1988. D. Kraft, \" Algorithm 733: TOMP--Fortran modules for optimal control calculations ,\"\n  ACM Transactions on Mathematical Software, Vol. 20, No. 3, p. 262-281 (1994). C. L. Lawson, R. J. Hanson, \"Solving Least Squares Problems\", Prentice Hall, 1974. (Revised 1995 edition) Developer Info Jacob Williams","tags":"home","url":"index.html"},{"title":"linmin_data – slsqp ","text":"type, public :: linmin_data data formerly saved in linmin routine. Inherited by type~~linmin_data~~InheritedByGraph type~linmin_data linmin_data type~slsqp_solver slsqp_solver type~slsqp_solver->type~linmin_data linmin Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=wp), public :: a = zero real(kind=wp), public :: b = zero real(kind=wp), public :: d = zero real(kind=wp), public :: e = zero real(kind=wp), public :: p = zero real(kind=wp), public :: q = zero real(kind=wp), public :: r = zero real(kind=wp), public :: u = zero real(kind=wp), public :: v = zero real(kind=wp), public :: w = zero real(kind=wp), public :: x = zero real(kind=wp), public :: m = zero real(kind=wp), public :: fu = zero real(kind=wp), public :: fv = zero real(kind=wp), public :: fw = zero real(kind=wp), public :: fx = zero real(kind=wp), public :: tol1 = zero real(kind=wp), public :: tol2 = zero Type-Bound Procedures procedure, public :: destroy => destroy_linmin_data private  subroutine destroy_linmin_data (me) Destructor for linmin_data type. Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me Source Code type , public :: linmin_data !! data formerly saved in [[linmin]] routine. real ( wp ) :: a = zero real ( wp ) :: b = zero real ( wp ) :: d = zero real ( wp ) :: e = zero real ( wp ) :: p = zero real ( wp ) :: q = zero real ( wp ) :: r = zero real ( wp ) :: u = zero real ( wp ) :: v = zero real ( wp ) :: w = zero real ( wp ) :: x = zero real ( wp ) :: m = zero real ( wp ) :: fu = zero real ( wp ) :: fv = zero real ( wp ) :: fw = zero real ( wp ) :: fx = zero real ( wp ) :: tol1 = zero real ( wp ) :: tol2 = zero contains procedure :: destroy => destroy_linmin_data end type linmin_data","tags":"","url":"type/linmin_data.html"},{"title":"slsqpb_data – slsqp ","text":"type, public :: slsqpb_data data formerly saved in slsqpb . Inherited by type~~slsqpb_data~~InheritedByGraph type~slsqpb_data slsqpb_data type~slsqp_solver slsqp_solver type~slsqp_solver->type~slsqpb_data slsqpb Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=wp), public :: t = zero real(kind=wp), public :: f0 = zero real(kind=wp), public :: h1 = zero real(kind=wp), public :: h2 = zero real(kind=wp), public :: h3 = zero real(kind=wp), public :: h4 = zero real(kind=wp), public :: t0 = zero real(kind=wp), public :: gs = zero real(kind=wp), public :: tol = zero real(kind=wp), public :: alpha = zero integer, public :: line = 0 integer, public :: iexact = 0 integer, public :: incons = 0 integer, public :: ireset = 0 integer, public :: itermx = 0 integer, public :: n1 = 0 integer, public :: n2 = 0 integer, public :: n3 = 0 Type-Bound Procedures procedure, public :: destroy => destroy_slsqpb_data private  subroutine destroy_slsqpb_data (me) Destructor for slsqpb_data type. Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me Source Code type , public :: slsqpb_data !! data formerly saved in [[slsqpb]]. real ( wp ) :: t = zero real ( wp ) :: f0 = zero real ( wp ) :: h1 = zero real ( wp ) :: h2 = zero real ( wp ) :: h3 = zero real ( wp ) :: h4 = zero real ( wp ) :: t0 = zero real ( wp ) :: gs = zero real ( wp ) :: tol = zero real ( wp ) :: alpha = zero integer :: line = 0 integer :: iexact = 0 integer :: incons = 0 integer :: ireset = 0 integer :: itermx = 0 integer :: n1 = 0 integer :: n2 = 0 integer :: n3 = 0 contains procedure :: destroy => destroy_slsqpb_data end type slsqpb_data","tags":"","url":"type/slsqpb_data.html"},{"title":"slsqp_solver – slsqp ","text":"type, public :: slsqp_solver The main class used to interface with the SLSQP solver. Inherits type~~slsqp_solver~~InheritsGraph type~slsqp_solver slsqp_solver type~linmin_data linmin_data type~slsqp_solver->type~linmin_data linmin type~slsqpb_data slsqpb_data type~slsqp_solver->type~slsqpb_data slsqpb Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of optimization variables ( ) integer, private :: m = 0 number of constraints ( ) integer, private :: meq = 0 number of equality constraints ( ) integer, private :: max_iter = 0 maximum number of iterations real(kind=wp), private :: acc = zero accuracy tolerance real(kind=wp), private :: tolf = -one accuracy tolerance over f:  if then stop real(kind=wp), private :: toldf = -one accuracy tolerance over df: if then stop.\nIt's different from acc in the case of positive derivative real(kind=wp), private :: toldx = -one accuracy tolerance over dx: if then stop integer, private :: gradient_mode = 0 how the gradients are computed: 0 - use the user-supplied g subroutine. [default] 1 - approximate by basic backward differences 2 - approximate by basic forward differences 3 - approximate by basic central differences real(kind=wp), private :: gradient_delta = 1.0e8_wp perturbation step size to approximate gradients\nby finite differences ( gradient_mode 1-3). real(kind=wp), private :: alphamin = 0.1_wp min for line search real(kind=wp), private :: alphamax = 1.0_wp max for line search integer, private :: iprint = output_unit unit number of status printing (0 for no printing) real(kind=wp), private, dimension(:), allocatable :: xl lower bound on x real(kind=wp), private, dimension(:), allocatable :: xu upper bound on x integer, private :: l_w = 0 size of w real(kind=wp), private, dimension(:), allocatable :: w real work array procedure( func ), private, pointer :: f => null() problem function subroutine procedure( grad ), private, pointer :: g => null() gradient subroutine procedure( iterfunc ), private, pointer :: report => null() for reporting an iteration procedure( msgfunc ), private, pointer :: report_msg => null() for reporting a string message from slsqp to the user integer, private :: linesearch_mode = 1 linesearch mode: 1 = inexact (Armijo) linesearch, 2 = exact linesearch. type( linmin_data ), private :: linmin data formerly within linmin .\nOnly used when linesearch_mode=2 type( slsqpb_data ), private :: slsqpb data formerly within slsqpb . integer, private :: nnls_mode = 1 Which NNLS method to use: Use the original nnls Use the newer bvls integer, private :: max_iter_ls = 0 max iterations in the least squares problem.\nif <=0 , defaults to 3*n .\n(use by either nnls or bvls ) logical, private :: user_triggered_stop = .false. if the abort method has been called\nto stop the iterations real(kind=wp), private :: infinite_bound = huge(one) \"infinity\" for the upper and lower bounds.\nif xl<=-infinite_bound or xu>=infinite_bound then these bounds are considered nonexistant. Type-Bound Procedures procedure, public :: initialize => initialize_slsqp private  subroutine initialize_slsqp (me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax, gradient_mode, gradient_delta, tolf, toldf, toldx, max_iter_ls, nnls_mode, infinite_bound, report_msg) initialize the slsqp_solver class.  see slsqp for more details. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of variables, integer, intent(in) :: m total number of constraints, integer, intent(in) :: meq number of equality constraints, integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients (must be\nassociated if gradient_mode=0 ) real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x . xl(i)=NaN (or xl(i)<=-infinite_bound ) indicates to ignore i th bound real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x . xu(i)=NaN (or xu(i)>=infinite_bound ) indicates to ignore i th bound logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default= output_unit ) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] integer, intent(in), optional :: gradient_mode how the gradients are to be computed: Read more… real(kind=wp), intent(in), optional :: gradient_delta perturbation step size (>epsilon) to compute the approximated\ngradient by finite differences ( gradient_mode 1-3).\nnote that this is an absolute step that does not respect\nthe xl or xu variable bounds. real(kind=wp), intent(in), optional :: tolf stopping criterion if then stop. real(kind=wp), intent(in), optional :: toldf stopping criterion if then stop real(kind=wp), intent(in), optional :: toldx stopping criterion if then stop integer, intent(in), optional :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in), optional :: nnls_mode Which NNLS method to use: Read more… real(kind=wp), intent(in), optional :: infinite_bound \"infinity\" for the upper and lower bounds.\nif xl<=-infinite_bound or xu>=infinite_bound then these bounds are considered nonexistant.\nIf not present then huge() is used for this. procedure( msgfunc ), optional :: report_msg user-defined procedure that will be called\nwith any warning or error messages. procedure, public :: destroy => destroy_slsqp private  subroutine destroy_slsqp (me) destructor for slsqp_solver . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me procedure, public :: optimize => slsqp_wrapper private  subroutine slsqp_wrapper (me, x, istat, iterations, status_message) main routine for calling slsqp . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional, allocatable :: status_message string status message\ncorresponding to istat procedure, public :: abort => stop_iterations private  subroutine stop_iterations (me) A method that the user can call to stop the iterations.\n(it can be called in any of the functions).\nSLSQP will stop at the end of the next iteration. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me procedure, private :: report_message for reporting messages to the user private  subroutine report_message (me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\nif no unit is specified, the error_unit is used. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False). Source Code type , public :: slsqp_solver !! The main class used to interface with the SLSQP solver. private integer :: n = 0 !! number of optimization variables ( n > 0 ) integer :: m = 0 !! number of constraints ( m \\ge 0 ) integer :: meq = 0 !! number of equality constraints ( m \\ge m_{eq} \\ge 0 ) integer :: max_iter = 0 !! maximum number of iterations real ( wp ) :: acc = zero !! accuracy tolerance real ( wp ) :: tolf = - one !! accuracy tolerance over f:  if  |f| < tolf  then stop real ( wp ) :: toldf = - one !! accuracy tolerance over df: if  |f_{n+1} - f_n| < toldf  then stop. !! It's different from `acc` in the case of positive derivative real ( wp ) :: toldx = - one !! accuracy tolerance over dx: if  |x_{n+1} - x_n| < toldx  then stop integer :: gradient_mode = 0 !! how the gradients are computed: !! !! * 0 - use the user-supplied `g` subroutine. [default] !! * 1 - approximate by basic backward differences !! * 2 - approximate by basic forward differences !! * 3 - approximate by basic central differences real ( wp ) :: gradient_delta = 1.0e8_wp !! perturbation step size to approximate gradients !! by finite differences (`gradient_mode` 1-3). !these two were not in the original code: real ( wp ) :: alphamin = 0.1_wp !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ) :: alphamax = 1.0_wp !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: iprint = output_unit !! unit number of status printing (0 for no printing) real ( wp ), dimension (:), allocatable :: xl !! lower bound on x real ( wp ), dimension (:), allocatable :: xu !! upper bound on x integer :: l_w = 0 !! size of `w` real ( wp ), dimension (:), allocatable :: w !! real work array procedure ( func ), pointer :: f => null () !! problem function subroutine procedure ( grad ), pointer :: g => null () !! gradient subroutine procedure ( iterfunc ), pointer :: report => null () !! for reporting an iteration procedure ( msgfunc ), pointer :: report_msg => null () !! for reporting a string message from slsqp to the user integer :: linesearch_mode = 1 !! linesearch mode: !! !! * `1` = inexact (Armijo) linesearch, !! * `2` = exact linesearch. type ( linmin_data ) :: linmin !! data formerly within [[linmin]]. !! Only used when `linesearch_mode=2` type ( slsqpb_data ) :: slsqpb !! data formerly within [[slsqpb]]. ! note: the following two maybe should be combined into a separate type ! along with the two methods... integer :: nnls_mode = 1 !! Which NNLS method to use: !! !! 1. Use the original [[nnls]] !! 2. Use the newer [[bvls]] integer :: max_iter_ls = 0 !! max iterations in the least squares problem. !! if `<=0`, defaults to `3*n`. !! (use by either [[nnls]] or [[bvls]]) logical :: user_triggered_stop = . false . !! if the `abort` method has been called !! to stop the iterations real ( wp ) :: infinite_bound = huge ( one ) !! \"infinity\" for the upper and lower bounds. !! if `xl<=-infinite_bound` or `xu>=infinite_bound` !! then these bounds are considered nonexistant. contains private procedure , public :: initialize => initialize_slsqp procedure , public :: destroy => destroy_slsqp procedure , public :: optimize => slsqp_wrapper procedure , public :: abort => stop_iterations procedure :: report_message !! for reporting messages to the user end type slsqp_solver","tags":"","url":"type/slsqp_solver.html"},{"title":"func – slsqp","text":"interface private  subroutine func(me, x, f, c) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\nequality constraints (if any) first. Description for computing the function","tags":"","url":"interface/func.html"},{"title":"grad – slsqp","text":"interface private  subroutine grad(me, x, g, a) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) Description for computing the gradients","tags":"","url":"interface/grad.html"},{"title":"iterfunc – slsqp","text":"interface private  subroutine iterfunc(me, iter, x, f, c) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(in) :: f value of the objective function real(kind=wp), intent(in), dimension(:) :: c the constraint vector dimension(m) ,\nequality constraints (if any) first. Description for reporting an iteration","tags":"","url":"interface/iterfunc.html"},{"title":"msgfunc – slsqp","text":"interface private  subroutine msgfunc(me, str) Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me character(len=*), intent(in) :: str the message to report. Description for reporting a message to the user","tags":"","url":"interface/msgfunc.html"},{"title":"check_convergence – slsqp","text":"private pure function check_convergence(n, f, f0, x, x0, s, h3, acc, tolf, toldf, toldx, converged, not_converged, inconsistent_linearization) result(mode) Check for convergence. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: x0 real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in) :: h3 real(kind=wp), intent(in) :: acc real(kind=wp), intent(in) :: tolf real(kind=wp), intent(in) :: toldf real(kind=wp), intent(in) :: toldx integer, intent(in) :: converged mode value if converged integer, intent(in) :: not_converged mode value if not converged logical, intent(in) :: inconsistent_linearization if the SQP problem is inconsistent (will return not_converged ) Return Value integer Calls proc~~check_convergence~~CallsGraph proc~check_convergence check_convergence proc~dnrm2 dnrm2 proc~check_convergence->proc~dnrm2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~check_convergence~~CalledByGraph proc~check_convergence check_convergence proc~slsqpb slsqpb proc~slsqpb->proc~check_convergence proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function check_convergence ( n , f , f0 , x , x0 , s , h3 , acc , tolf , toldf , toldx ,& converged , not_converged , inconsistent_linearization ) result ( mode ) implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: f real ( wp ), intent ( in ) :: f0 real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: x0 real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), intent ( in ) :: h3 real ( wp ), intent ( in ) :: acc real ( wp ), intent ( in ) :: tolf real ( wp ), intent ( in ) :: toldf real ( wp ), intent ( in ) :: toldx integer , intent ( in ) :: converged !! mode value if converged integer , intent ( in ) :: not_converged !! mode value if not converged logical , intent ( in ) :: inconsistent_linearization !! if the SQP problem is inconsistent (will return `not_converged`) integer :: mode logical :: ok ! temp variable real ( wp ), dimension ( n ) :: xmx0 if ( h3 >= acc . or . inconsistent_linearization . or . ieee_is_nan ( f )) then mode = not_converged else ! if any are OK then it is converged ok = . false . if (. not . ok ) ok = abs ( f - f0 ) < acc if (. not . ok ) ok = dnrm2 ( n , s , 1 ) < acc ! note that these can be ignored if they are < 0: if (. not . ok . and . tolf >= zero ) ok = abs ( f ) < tolf if (. not . ok . and . toldf >= zero ) ok = abs ( f - f0 ) < toldf if (. not . ok . and . toldx >= zero ) then xmx0 = x - x0 ! to avoid array temporary warning ok = dnrm2 ( n , xmx0 , 1 ) < toldx end if if ( ok ) then mode = converged else mode = not_converged end if end if end function check_convergence","tags":"","url":"proc/check_convergence.html"},{"title":"linmin – slsqp","text":"private  function linmin(mode, ax, bx, f, tol, a, b, d, e, p, q, r, u, v, w, x, m, fu, fv, fw, fx, tol1, tol2) Linesearch without derivatives (used by slsqp if linesearch_mode=2 ).\n  Returns the abscissa approximating the point where f attains a minimum. purpose: to find the argument linmin where the function f takes it's minimum\n  on the interval ax , bx . It uses a combination of golden section\n  and successive quadratic interpolation. Reference This function subprogram is a slightly modified version of the\n  ALGOL 60 procedure localmin given in R.P. Brent:\n  \" Algorithms for minimization without derivatives \",\n  Prentice-Hall (1973). History Kraft, D., DFVLR - institut fuer dynamik der flugsysteme\n    d-8031  oberpfaffenhofen status: 31. august 1984 Jacob Williams, Jan 2016, Refactored into modern Fortran.\n    Added saved variables as inout s to make the routine thread-safe. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: mode controls reverse communication\nmust be set to 0 initially, returns with intermediate\nvalues 1 and 2 which must not be changed by the user,\nends with convergence with value 3. real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp) :: f function value at linmin which is to be brought in by\nreverse communication controlled by mode real(kind=wp), intent(in) :: tol desired length of interval of uncertainty of final result real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(inout) :: d real(kind=wp), intent(inout) :: e real(kind=wp), intent(inout) :: p real(kind=wp), intent(inout) :: q real(kind=wp), intent(inout) :: r real(kind=wp), intent(inout) :: u real(kind=wp), intent(inout) :: v real(kind=wp), intent(inout) :: w real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout) :: m real(kind=wp), intent(inout) :: fu real(kind=wp), intent(inout) :: fv real(kind=wp), intent(inout) :: fw real(kind=wp), intent(inout) :: fx real(kind=wp), intent(inout) :: tol1 real(kind=wp), intent(inout) :: tol2 Return Value real(kind=wp) Called by proc~~linmin~~CalledByGraph proc~linmin linmin proc~slsqpb slsqpb proc~slsqpb->proc~linmin proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code real ( wp ) function linmin ( mode , ax , bx , f , tol ,& a , b , d , e , p , q , r , u , v ,& w , x , m , fu , fv , fw , fx , tol1 , tol2 ) implicit none integer , intent ( inout ) :: mode !! controls reverse communication !! must be set to 0 initially, returns with intermediate !! values 1 and 2 which must not be changed by the user, !! ends with convergence with value 3. real ( wp ) :: f !! function value at `linmin` which is to be brought in by !! reverse communication controlled by `mode` real ( wp ), intent ( in ) :: tol !! desired length of interval of uncertainty of final result real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( inout ) :: a , b , d , e , p , q , r , u , v , w , x , m , fu , fv , fw , fx , tol1 , tol2 real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! golden section ratio = `0.381966011` real ( wp ), parameter :: sqrteps = sqrt ( eps ) !! square root of machine precision select case ( mode ) case ( 1 ) ! main loop starts here fx = f fv = fx fw = fv case ( 2 ) fu = f ! update a, b, v, w, and x if ( fu > fx ) then if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . abs ( w - x ) <= zero ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . abs ( v - x ) <= zero . or . abs ( v - w ) <= zero ) then v = u fv = fu end if else if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu end if case default ! initialization a = ax b = bx e = zero v = a + c * ( b - a ) w = v x = w linmin = x mode = 1 return end select m = 0.5_wp * ( a + b ) tol1 = sqrteps * abs ( x ) + tol tol2 = tol1 + tol1 ! test convergence if ( abs ( x - m ) <= tol2 - 0.5_wp * ( b - a ) ) then ! end of main loop linmin = x mode = 3 else r = zero q = r p = q if ( abs ( e ) > tol1 ) then ! fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = q - r q = q + q if ( q > zero ) p = - p if ( q < zero ) q = - q r = e e = d end if ! is parabola acceptable if ( abs ( p ) >= 0.5_wp * abs ( q * r ) . or . p <= q * ( a - x ) . or . p >= q * ( b - x ) ) then ! golden section step if ( x >= m ) e = a - x if ( x < m ) e = b - x d = c * e else ! parabolic interpolation step d = p / q ! f must not be evaluated too close to a or b if ( u - a < tol2 ) d = sign ( tol1 , m - x ) if ( b - u < tol2 ) d = sign ( tol1 , m - x ) end if ! f must not be evaluated too close to x if ( abs ( d ) < tol1 ) d = sign ( tol1 , d ) u = x + d linmin = u mode = 2 end if end function linmin","tags":"","url":"proc/linmin.html"},{"title":"slsqp – slsqp","text":"public  subroutine slsqp(m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, w, l_w, sdat, ldat, alphamin, alphamax, tolf, toldf, toldx, max_iter_ls, nnls_mode, infinite_bound) slsqp : s equential l east sq uares p rogramming\n  to solve general nonlinear optimization problems a nonlinear programming method with quadratic programming subproblems\n  this subroutine solves the general nonlinear programming problem: minimize subject to , , , the algorithm implements the method of Han and Powell\n  with BFGS-update of the b-matrix and L1-test function\n  within the steplength algorithm. Reference Dieter Kraft: \"A software package for sequential quadratic programming\",\n     DFVLR-FB 88-28, 1988 History implemented by: Dieter Kraft, DFVLR oberpfaffenhofen date: april - october, 1981. December, 31-st, 1984. March   , 21-st, 1987, revised to fortran 77 March   , 20-th, 1989, revised to ms-fortran April   , 14-th, 1989, hesse   in-line coded February, 28-th, 1991, fortran/2 version 1.04 accepts statement functions March   ,  1-st, 1991, tested with salford ftn77/386 compiler vers 2.40 in protected mode January ,        2016, Refactored into modern Fortran by Jacob Williams License Original version copyright 1991: Dieter Kraft, FHM.\n  Released under a BSD license. Note f , c , g , a must all be set by the user before each call. Arguments Type Intent Optional Attributes Name integer, intent(in) :: m is the total number of constraints, integer, intent(in) :: meq is the number of equality constraints, integer, intent(in) :: la see a , integer, intent(in) :: n is the number of variables, real(kind=wp), intent(inout), dimension(n) :: x x() stores the current iterate of the n vector x on entry x() must be initialized. on exit x() stores the solution vector x if mode = 0 . real(kind=wp), intent(in), dimension(n) :: xl xl() stores an n vector of lower bounds xl to x . real(kind=wp), intent(in), dimension(n) :: xu xu() stores an n vector of upper bounds xu to x . real(kind=wp), intent(in) :: f is the value of the objective function. real(kind=wp), intent(in), dimension(la) :: c c() stores the m vector c of constraints,\nequality constraints (if any) first.\ndimension of c must be greater or equal la ,\nwhich must be greater or equal max(1,m) . real(kind=wp), intent(in), dimension(n+1) :: g g() stores the n vector g of partials of the\nobjective function; dimension of g must be\ngreater or equal n+1 . real(kind=wp), intent(in), dimension(la,n+1) :: a the la by n + 1 array a() stores\nthe m by n matrix a of constraint normals. a() has first dimensioning parameter la ,\nwhich must be greater or equal max(1,m) . real(kind=wp), intent(inout) :: acc abs(acc) controls the final accuracy.\nif acc < zero an exact linesearch is performed,\notherwise an armijo-type linesearch is used. integer, intent(inout) :: iter prescribes the maximum number of iterations.\non exit iter indicates the number of iterations. integer, intent(inout) :: mode mode controls calculation: reverse communication is used in the sense that\nthe program is initialized by mode = 0 ; then it is\nto be called repeatedly by the user until a return\nwith mode /= abs(1) takes place.\nif mode = -1 gradients have to be calculated,\nwhile with mode = 1 functions have to be calculated.\nmode must not be changed between subsequent calls of slsqp . evaluation modes : ** -1 **: gradient evaluation, ( g & a ) **  0 : on entry : initialization, ( f , g , c , a ), on exit : required accuracy for solution obtained **  1 **: function evaluation, ( f & c ) failure modes : ** 2 **: number of equality constraints larger than n ** 3 **: more than 3*n iterations in lsq subproblem ** 4 **: inequality constraints incompatible ** 5 **: singular matrix e in lsq subproblem ** 6 **: singular matrix c in lsq subproblem ** 7 **: rank-deficient equality constraint subproblem hfti ** 8 **: positive directional derivative for linesearch ** 9 **: more than iter iterations in sqp ** >=10 **: working space w too small, w should be enlarged to l_w=mode/1000 , real(kind=wp), intent(inout), dimension(l_w) :: w w() is a one dimensional working space.\nthe first m+n+n*n1/2 elements of w must not be\nchanged between subsequent calls of slsqp .\non return w(1) ... w(m) contain the multipliers\nassociated with the general constraints, while w(m+1) ... w(m+n(n+1)/2) store the cholesky factor l*d*l(t) of the approximate hessian of the\nlagrangian columnwise dense as lower triangular\nunit matrix l with d in its 'diagonal' and w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n) contain the multipliers associated with all\nconstraints of the quadratic program finding\nthe search direction to the solution x* integer, intent(in) :: l_w the length of w , which should be at least: (3*n1+m)*(n1+1) for lsq +(n1-meq+1)*(mineq+2) + 2*mineq for lsi +(n1+mineq)*(n1-meq) + 2*meq + n1 for lsei + n1*n/2 + 2*m + 3*n + 3*n1 + 1 for slsqpb with mineq = m - meq + 2*n1 & n1 = n+1 type( slsqpb_data ), intent(inout) :: sdat data for slsqpb . type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min for line search real(kind=wp), intent(in) :: alphamax max for line search real(kind=wp), intent(in) :: tolf stopping criterion if then stop. real(kind=wp), intent(in) :: toldf stopping criterion if then stop. real(kind=wp), intent(in) :: toldx stopping criterion if then stop. integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use real(kind=wp), intent(in) :: infinite_bound \"infinity\" for the upper and lower bounds.\nif xl<=-infinite_bound or xu>=infinite_bound then these bounds are considered nonexistant.\nIf infinite_bound=0 then huge() is used for this. Calls proc~~slsqp~~CallsGraph proc~slsqp slsqp proc~slsqpb slsqpb proc~slsqp->proc~slsqpb proc~check_convergence check_convergence proc~slsqpb->proc~check_convergence proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~ddot ddot proc~slsqpb->proc~ddot proc~dscal dscal proc~slsqpb->proc~dscal proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~ldl ldl proc~slsqpb->proc~ldl proc~linmin linmin proc~slsqpb->proc~linmin proc~lsq lsq proc~slsqpb->proc~lsq proc~dnrm2 dnrm2 proc~check_convergence->proc~dnrm2 proc~lsq->proc~dcopy proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsq->proc~enforce_bounds proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~h12 h12 proc~lsei->proc~h12 proc~hfti hfti proc~lsei->proc~hfti proc~lsi lsi proc~lsei->proc~lsi proc~hfti->proc~h12 proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~ldp->proc~daxpy proc~ldp->proc~dcopy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~bvls_wrapper bvls_wrapper proc~ldp->proc~bvls_wrapper proc~nnls nnls proc~ldp->proc~nnls proc~bvls bvls proc~bvls_wrapper->proc~bvls proc~nnls->proc~h12 proc~g1 g1 proc~nnls->proc~g1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~slsqp~~CalledByGraph proc~slsqp slsqp proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine slsqp ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode , w , l_w , & sdat , ldat , alphamin , alphamax , tolf , toldf , toldx ,& max_iter_ls , nnls_mode , infinite_bound ) implicit none integer , intent ( in ) :: m !! is the total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! is the number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: la !! see `a`,  la \\ge \\max(m,1)  integer , intent ( in ) :: n !! is the number of variables,  n \\ge 1  real ( wp ), dimension ( n ), intent ( inout ) :: x !! `x()` stores the current iterate of the `n` vector `x` !! on entry `x()` must be initialized. on exit `x()` !! stores the solution vector `x` if `mode = 0`. real ( wp ), dimension ( n ), intent ( in ) :: xl !! `xl()` stores an n vector of lower bounds `xl` to `x`. real ( wp ), dimension ( n ), intent ( in ) :: xu !! `xu()` stores an n vector of upper bounds `xu` to `x`. real ( wp ), intent ( in ) :: f !! is the value of the objective function. real ( wp ), dimension ( la ), intent ( in ) :: c !! `c()` stores the `m` vector `c` of constraints, !! equality constraints (if any) first. !! dimension of `c` must be greater or equal `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), dimension ( n + 1 ), intent ( in ) :: g !! `g()` stores the `n` vector `g` of partials of the !! objective function; dimension of `g` must be !! greater or equal `n+1`. real ( wp ), dimension ( la , n + 1 ), intent ( in ) :: a !! the `la` by `n + 1` array `a()` stores !! the `m` by `n` matrix `a` of constraint normals. !! `a()` has first dimensioning parameter `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), intent ( inout ) :: acc !! `abs(acc)` controls the final accuracy. !! if `acc` < zero an exact linesearch is performed, !! otherwise an armijo-type linesearch is used. integer , intent ( inout ) :: iter !! prescribes the maximum number of iterations. !! on exit `iter` indicates the number of iterations. integer , intent ( inout ) :: mode !! mode controls calculation: !! !! reverse communication is used in the sense that !! the program is initialized by `mode = 0`; then it is !! to be called repeatedly by the user until a return !! with `mode /= abs(1)` takes place. !! if `mode = -1` gradients have to be calculated, !! while with `mode = 1` functions have to be calculated. !! mode must not be changed between subsequent calls of [[slsqp]]. !! !! **evaluation modes**: !! !! * ** -1 **: gradient evaluation, (`g` & `a`) !! * **  0 **: *on entry*: initialization, (`f`, `g`, `c`, `a`), !!   *on exit*: required accuracy for solution obtained !! * **  1 **: function evaluation, (`f` & `c`) !! !! **failure modes**: !! !! * ** 2 **: number of equality constraints larger than `n` !! * ** 3 **: more than `3*n` iterations in [[lsq]] subproblem !! * ** 4 **: inequality constraints incompatible !! * ** 5 **: singular matrix `e` in [[lsq]] subproblem !! * ** 6 **: singular matrix `c` in [[lsq]] subproblem !! * ** 7 **: rank-deficient equality constraint subproblem [[hfti]] !! * ** 8 **: positive directional derivative for linesearch !! * ** 9 **: more than `iter` iterations in sqp !! * ** >=10 **: working space `w` too small, !!   `w` should be enlarged to `l_w=mode/1000`, integer , intent ( in ) :: l_w !! the length of `w`, which should be at least: !! !! * `(3*n1+m)*(n1+1)`                     **for lsq** !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`     **for lsi** !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`   **for lsei** !! * `+ n1*n/2 + 2*m + 3*n + 3*n1 + 1`     **for slsqpb** !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` real ( wp ), dimension ( l_w ), intent ( inout ) :: w !! `w()` is a one dimensional working space. !! the first `m+n+n*n1/2` elements of `w` must not be !! changed between subsequent calls of [[slsqp]]. !! on return `w(1) ... w(m)` contain the multipliers !! associated with the general constraints, while !! `w(m+1) ... w(m+n(n+1)/2)` store the cholesky factor !! `l*d*l(t)` of the approximate hessian of the !! lagrangian columnwise dense as lower triangular !! unit matrix `l` with `d` in its 'diagonal' and !! `w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n)` !! contain the multipliers associated with all !! constraints of the quadratic program finding !! the search direction to the solution `x*` type ( slsqpb_data ), intent ( inout ) :: sdat !! data for [[slsqpb]]. type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ) :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop. real ( wp ), intent ( in ) :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop. integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use real ( wp ), intent ( in ) :: infinite_bound !! \"infinity\" for the upper and lower bounds. !! if `xl<=-infinite_bound` or `xu>=infinite_bound` !! then these bounds are considered nonexistant. !! If `infinite_bound=0` then `huge()` is used for this. integer :: il , im , ir , is , iu , iv , iw , ix , mineq , n1 real ( wp ) :: infBnd !! local copy of `infinite_bound` if ( infinite_bound == zero ) then infBnd = huge ( one ) else infBnd = abs ( infinite_bound ) end if ! check length of working arrays n1 = n + 1 mineq = m - meq + n1 + n1 il = ( 3 * n1 + m ) * ( n1 + 1 ) + ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + ( n1 + mineq )& * ( n1 - meq ) + 2 * meq + n1 * n / 2 + 2 * m + 3 * n + 4 * n1 + 1 im = max ( mineq , n1 - meq ) if ( l_w < il ) then mode = 1000 * max ( 10 , il ) mode = mode + max ( 10 , im ) iter = 0 return end if if ( meq > n ) then ! note: calling lsq when meq>n is corrupting the ! memory in some way, so just catch this here. mode = 2 iter = 0 return end if ! prepare data for calling sqpbdy  -  initial addresses in w im = 1 il = im + max ( 1 , m ) il = im + la ix = il + n1 * n / 2 + 1 ir = ix + n is = ir + n + n + max ( 1 , m ) is = ir + n + n + la iu = is + n1 iv = iu + n1 iw = iv + n1 sdat % n1 = n1 call slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& w ( ir ), w ( il ), w ( ix ), w ( im ), w ( is ), w ( iu ), w ( iv ), w ( iw ),& sdat % t , sdat % f0 , sdat % h1 , sdat % h2 , sdat % h3 , sdat % h4 ,& sdat % n1 , sdat % n2 , sdat % n3 , sdat % t0 , sdat % gs , sdat % tol , sdat % line ,& sdat % alpha , sdat % iexact , sdat % incons , sdat % ireset , sdat % itermx ,& ldat , alphamin , alphamax , tolf , toldf , toldx ,& max_iter_ls , nnls_mode , infBnd ) end subroutine slsqp","tags":"","url":"proc/slsqp.html"},{"title":"slsqpb – slsqp","text":"private  subroutine slsqpb(m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, r, l, x0, mu, s, u, v, w, t, f0, h1, h2, h3, h4, n1, n2, n3, t0, gs, tol, line, alpha, iexact, incons, ireset, itermx, ldat, alphamin, alphamax, tolf, toldf, toldx, max_iter_ls, nnls_mode, infBnd) nonlinear programming by solving sequentially quadratic programs l1 - line search, positive definite bfgs update Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: la integer, intent(in) :: n real(kind=wp), dimension(n) :: x real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp) :: f real(kind=wp), dimension(la) :: c real(kind=wp), dimension(n+1) :: g real(kind=wp), dimension(la,n+1) :: a real(kind=wp) :: acc integer, intent(inout) :: iter in: maximum number of iterations. out: actual number of iterations. integer, intent(inout) :: mode real(kind=wp), dimension(m+n+n+2) :: r real(kind=wp), dimension((n+1)*(n+2)/2) :: l real(kind=wp), dimension(n) :: x0 real(kind=wp), dimension(la) :: mu real(kind=wp), dimension(n+1) :: s real(kind=wp), dimension(n+1) :: u real(kind=wp), dimension(n+1) :: v real(kind=wp), intent(inout), dimension(*) :: w dim(w) = n1*(n1+1) + meq*(n1+1) + mineq*(n1+1) for lsq +(n1-meq+1)*(mineq+2) + 2*mineq for lsi +(n1+mineq)*(n1-meq) + 2*meq + n1 for lsei with mineq = m - meq + 2*n1 & n1 = n+1 real(kind=wp), intent(inout) :: t real(kind=wp), intent(inout) :: f0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(inout) :: h2 real(kind=wp), intent(inout) :: h3 real(kind=wp), intent(inout) :: h4 integer, intent(inout) :: n1 integer, intent(inout) :: n2 integer, intent(inout) :: n3 real(kind=wp), intent(inout) :: t0 real(kind=wp), intent(inout) :: gs real(kind=wp), intent(inout) :: tol integer, intent(inout) :: line real(kind=wp), intent(inout) :: alpha integer, intent(inout) :: iexact integer, intent(inout) :: incons integer, intent(inout) :: ireset integer, intent(inout) :: itermx type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min for line search real(kind=wp), intent(in) :: alphamax max for line search real(kind=wp), intent(in) :: tolf stopping criterion if then stop. real(kind=wp), intent(in) :: toldf stopping criterion if then stop real(kind=wp), intent(in) :: toldx stopping criterion if then stop integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use real(kind=wp), intent(in) :: infBnd \"infinity\" for the upper and lower bounds. Calls proc~~slsqpb~~CallsGraph proc~slsqpb slsqpb proc~check_convergence check_convergence proc~slsqpb->proc~check_convergence proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~ddot ddot proc~slsqpb->proc~ddot proc~dscal dscal proc~slsqpb->proc~dscal proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~ldl ldl proc~slsqpb->proc~ldl proc~linmin linmin proc~slsqpb->proc~linmin proc~lsq lsq proc~slsqpb->proc~lsq proc~dnrm2 dnrm2 proc~check_convergence->proc~dnrm2 proc~lsq->proc~dcopy proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsq->proc~enforce_bounds proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~h12 h12 proc~lsei->proc~h12 proc~hfti hfti proc~lsei->proc~hfti proc~lsi lsi proc~lsei->proc~lsi proc~hfti->proc~h12 proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~ldp->proc~daxpy proc~ldp->proc~dcopy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~bvls_wrapper bvls_wrapper proc~ldp->proc~bvls_wrapper proc~nnls nnls proc~ldp->proc~nnls proc~bvls bvls proc~bvls_wrapper->proc~bvls proc~nnls->proc~h12 proc~g1 g1 proc~nnls->proc~g1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~slsqpb~~CalledByGraph proc~slsqpb slsqpb proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& r , l , x0 , mu , s , u , v , w ,& t , f0 , h1 , h2 , h3 , h4 , n1 , n2 , n3 , t0 , gs , tol , line ,& alpha , iexact , incons , ireset , itermx , ldat ,& alphamin , alphamax , tolf , toldf , toldx ,& max_iter_ls , nnls_mode , infBnd ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: meq integer , intent ( in ) :: la integer , intent ( in ) :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: f real ( wp ), dimension ( la ) :: c real ( wp ), dimension ( n + 1 ) :: g real ( wp ), dimension ( la , n + 1 ) :: a real ( wp ) :: acc integer , intent ( inout ) :: iter !! **in:**  maximum number of iterations. !! **out:** actual number of iterations. integer , intent ( inout ) :: mode real ( wp ), dimension ( m + n + n + 2 ) :: r real ( wp ), dimension (( n + 1 ) * ( n + 2 ) / 2 ) :: l real ( wp ), dimension ( n ) :: x0 real ( wp ), dimension ( la ) :: mu real ( wp ), dimension ( n + 1 ) :: s real ( wp ), dimension ( n + 1 ) :: u real ( wp ), dimension ( n + 1 ) :: v real ( wp ), dimension ( * ), intent ( inout ) :: w !! `dim(w)` = !! !! * `n1*(n1+1) + meq*(n1+1) + mineq*(n1+1)`   for [[lsq]] !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`         for [[lsi]] !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`       for [[lsei]] !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` real ( wp ), intent ( inout ) :: t real ( wp ), intent ( inout ) :: f0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( inout ) :: h2 real ( wp ), intent ( inout ) :: h3 real ( wp ), intent ( inout ) :: h4 integer , intent ( inout ) :: n1 integer , intent ( inout ) :: n2 integer , intent ( inout ) :: n3 real ( wp ), intent ( inout ) :: t0 real ( wp ), intent ( inout ) :: gs real ( wp ), intent ( inout ) :: tol integer , intent ( inout ) :: line real ( wp ), intent ( inout ) :: alpha integer , intent ( inout ) :: iexact integer , intent ( inout ) :: incons integer , intent ( inout ) :: ireset integer , intent ( inout ) :: itermx type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ) :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop real ( wp ), intent ( in ) :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use real ( wp ), intent ( in ) :: infBnd !! \"infinity\" for the upper and lower bounds. integer :: i , j , k logical :: inconsistent_linearization !! if the SQP problem is inconsistent inconsistent_linearization = . false . ! initialize if ( mode < 0 ) then ! call jacobian at current x ! update cholesky-factors of hessian matrix by modified bfgs formula do i = 1 , n u ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) - v ( i ) end do ! l'*s k = 0 do i = 1 , n h1 = zero k = k + 1 do j = i + 1 , n k = k + 1 h1 = h1 + l ( k ) * s ( j ) end do v ( i ) = s ( i ) + h1 end do ! d*l'*s k = 1 do i = 1 , n v ( i ) = l ( k ) * v ( i ) k = k + n1 - i end do ! l*d*l'*s do i = n , 1 , - 1 h1 = zero k = i do j = 1 , i - 1 h1 = h1 + l ( k ) * v ( j ) k = k + n - j end do v ( i ) = v ( i ) + h1 end do h1 = ddot ( n , s , 1 , u , 1 ) h2 = ddot ( n , s , 1 , v , 1 ) h3 = 0.2_wp * h2 if ( h1 < h3 ) then h4 = ( h2 - h3 ) / ( h2 - h1 ) h1 = h3 call dscal ( n , h4 , u , 1 ) call daxpy ( n , one - h4 , v , 1 , u , 1 ) end if if ( h1 == zero . or . h2 == zero ) then ! Singular update: reset hessian. ! [ JW : this is based on a SciPy update ] call reset_bfgs_matrix () if ( ireset > 5 ) return else call ldl ( n , l , u , + one / h1 , v ) call ldl ( n , l , v , - one / h2 , u ) end if ! end of main iteration else if ( mode == 0 ) then itermx = iter if ( acc >= zero ) then iexact = 0 else iexact = 1 end if acc = abs ( acc ) tol = ten * acc iter = 0 ireset = 0 n1 = n + 1 n2 = n1 * n / 2 n3 = n2 + 1 s ( 1 ) = zero mu ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) call dcopy ( m , mu ( 1 ), 0 , mu , 1 ) call reset_bfgs_matrix () if ( ireset > 5 ) return else ! call functions at current x t = f do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if t = t + mu ( j ) * max ( - c ( j ), h1 ) end do h1 = t - t0 select case ( iexact ) case ( 0 ) if ( h1 <= h3 / ten . or . line > 10 ) then call convergence_check ( acc , 0 , - 1 ) else alpha = min ( max ( h3 / ( two * ( h3 - h1 )), alphamin ), alphamax ) call inexact_linesearch () end if case ( 1 ) call exact_linesearch () if ( line == 3 ) call convergence_check ( acc , 0 , - 1 ) end select return end if do ! main iteration : search direction, steplength, ldl'-update iter = iter + 1 mode = 9 if ( iter > itermx ) return ! search direction as solution of qp - subproblem call dcopy ( n , xl , 1 , u , 1 ) call dcopy ( n , xu , 1 , v , 1 ) call daxpy ( n , - one , x , 1 , u , 1 ) call daxpy ( n , - one , x , 1 , v , 1 ) h4 = one call lsq ( m , meq , n , n3 , la , l , g , a , c , u , v , s , r , w , mode , max_iter_ls , nnls_mode , infBnd ) ! augmented problem for inconsistent linearization inconsistent_linearization = . false . ! initialize if ( mode == 6 ) then if ( n == meq ) mode = 4 end if if ( mode == 4 ) then ! Will reject this iteration if the SQP problem is inconsistent, inconsistent_linearization = . true . do j = 1 , m if ( j <= meq ) then a ( j , n1 ) = - c ( j ) else a ( j , n1 ) = max ( - c ( j ), zero ) end if end do s ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) h3 = zero g ( n1 ) = zero l ( n3 ) = hun s ( n1 ) = one u ( n1 ) = zero v ( n1 ) = one incons = 0 do call lsq ( m , meq , n1 , n3 , la , l , g , a , c , u , v , s , r , w , mode , max_iter_ls , nnls_mode , infBnd ) h4 = one - s ( n1 ) if ( mode == 4 ) then l ( n3 ) = ten * l ( n3 ) incons = incons + 1 if ( incons <= 5 ) cycle return else if ( mode /= 1 ) then return else exit end if end do else if ( mode /= 1 ) then return end if ! update multipliers for l1-test do i = 1 , n v ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) end do f0 = f call dcopy ( n , x , 1 , x0 , 1 ) gs = ddot ( n , g , 1 , s , 1 ) h1 = abs ( gs ) h2 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h2 = h2 + max ( - c ( j ), h3 ) h3 = abs ( r ( j )) mu ( j ) = max ( h3 ,( mu ( j ) + h3 ) / two ) h1 = h1 + h3 * abs ( c ( j )) end do ! check convergence mode = 0 if ( h1 < acc . and . h2 < acc . and . & . not . inconsistent_linearization . and . & . not . ieee_is_nan ( f )) return h1 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h1 = h1 + mu ( j ) * max ( - c ( j ), h3 ) end do t0 = f + h1 h3 = gs - h1 * h4 mode = 8 if ( h3 >= zero ) then call reset_bfgs_matrix () if ( ireset > 5 ) return else exit end if end do ! line search with an l1-testfunction line = 0 alpha = alphamax if ( iexact == 1 ) then call exact_linesearch () if ( line == 3 ) call convergence_check ( acc , 0 , - 1 ) else call inexact_linesearch () end if contains subroutine reset_bfgs_matrix () ! 100 !! reset BFGS matrix ireset = ireset + 1 if ( ireset > 5 ) then ! check relaxed convergence in case of positive directional derivative ! [ JW: reuse this routine so that h3 is recomputed. !   this is based on a SciPy update to SLSQP ] call convergence_check ( tol , 0 , 8 ) ! the caller should return in this case else l ( 1 ) = zero call dcopy ( n2 , l ( 1 ), 0 , l , 1 ) j = 1 do i = 1 , n l ( j ) = one j = j + n1 - i end do end if end subroutine reset_bfgs_matrix subroutine inexact_linesearch () ! 300 line = line + 1 h3 = alpha * h3 call dscal ( n , alpha , s , 1 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , one , s , 1 , x , 1 ) call enforce_bounds ( x , xl , xu , infBnd ) ! ensure that x doesn't violate bounds mode = 1 end subroutine inexact_linesearch subroutine exact_linesearch () ! 400 if ( line /= 3 ) then alpha = linmin ( line , alphamin , alphamax , t , tol , & ldat % a , ldat % b , ldat % d , ldat % e , ldat % p , ldat % q , & ldat % r , ldat % u , ldat % v , ldat % w , ldat % x , ldat % m , & ldat % fu , ldat % fv , ldat % fw , ldat % fx , ldat % tol1 , ldat % tol2 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , alpha , s , 1 , x , 1 ) mode = 1 else call dscal ( n , alpha , s , 1 ) end if end subroutine exact_linesearch subroutine convergence_check ( tolerance , converged , not_converged ) ! 500 real ( wp ), intent ( in ) :: tolerance !! tolerance integer , intent ( in ) :: converged !! mode value if converged integer , intent ( in ) :: not_converged !! mode value if not converged h3 = zero do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if h3 = h3 + max ( - c ( j ), h1 ) end do mode = check_convergence ( n , f , f0 , x , x0 , s , h3 , tolerance , tolf , toldf , toldx ,& converged , not_converged , inconsistent_linearization ) end subroutine convergence_check end subroutine slsqpb","tags":"","url":"proc/slsqpb.html"},{"title":"lsq – slsqp","text":"private  subroutine lsq(m, meq, n, nl, la, l, g, a, b, xl, xu, x, y, w, mode, max_iter_ls, nnls_mode, infbnd) Minimize with respect to ,\n  with upper triangular matrix ,\n  and vector ,\n  where the unit lower tridiangular matrix is stored columnwise\n  dense in the array with vector stored in its\n  'diagonal' thus substituting the one-elements of subject to: , , , On entry, the user has to provide the arrays l , g , a , b , xl , xu .\n  with dimensions: l(n*(n+1)/2) , g(n) , a(la,n) , b(m) , xl(n) , xu(n) . The working array w must have at least the following dimension: dim(w) = (3*n+m)*(n+1) for lsq +(n-meq+1)*(mineq+2) + 2*mineq for lsi +(n+mineq)*(n-meq) + 2*meq + n for lsei with mineq = m - meq + 2*n On return, no array will be changed by the subroutine. History coded dieter kraft, april 1987 revised march 1989 Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: n integer, intent(in) :: nl integer, intent(in) :: la real(kind=wp), dimension(nl) :: l real(kind=wp), dimension(n) :: g real(kind=wp), dimension(la,n) :: a real(kind=wp), dimension(la) :: b real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp), dimension(n) :: x stores the n-dimensional solution vector real(kind=wp), dimension(m+n+n) :: y stores the vector of lagrange multipliers of dimension\nm+n+n (constraints+lower+upper bounds) real(kind=wp), dimension(*) :: w integer :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank, 6: matrix c is not of full rank, 7: rank defect in hfti integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use real(kind=wp), intent(in) :: infbnd \"infinity\" for the upper and lower bounds. Calls proc~~lsq~~CallsGraph proc~lsq lsq proc~dcopy dcopy proc~lsq->proc~dcopy proc~ddot ddot proc~lsq->proc~ddot proc~dscal dscal proc~lsq->proc~dscal proc~enforce_bounds enforce_bounds proc~lsq->proc~enforce_bounds proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~dnrm2 dnrm2 proc~lsei->proc~dnrm2 proc~h12 h12 proc~lsei->proc~h12 proc~hfti hfti proc~lsei->proc~hfti proc~lsi lsi proc~lsei->proc~lsi proc~hfti->proc~h12 proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~daxpy daxpy proc~lsi->proc~daxpy proc~ldp ldp proc~lsi->proc~ldp proc~ldp->proc~dcopy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~daxpy proc~bvls_wrapper bvls_wrapper proc~ldp->proc~bvls_wrapper proc~nnls nnls proc~ldp->proc~nnls proc~bvls bvls proc~bvls_wrapper->proc~bvls proc~nnls->proc~h12 proc~g1 g1 proc~nnls->proc~g1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lsq~~CalledByGraph proc~lsq lsq proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lsq ( m , meq , n , nl , la , l , g , a , b , xl , xu , x , y , w , mode , max_iter_ls , nnls_mode , infBnd ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: meq integer , intent ( in ) :: nl integer , intent ( in ) :: la real ( wp ), dimension ( n ) :: x !! stores the n-dimensional solution vector real ( wp ), dimension ( m + n + n ) :: y !! stores the vector of lagrange multipliers of dimension !! m+n+n (constraints+lower+upper bounds) integer :: mode !! is a success-failure flag with the following meanings: !! !! * **1:** successful computation, !! * **2:** error return because of wrong dimensions (`n<1`), !! * **3:** iteration count exceeded by [[nnls]], !! * **4:** inequality constraints incompatible, !! * **5:** matrix `e` is not of full rank, !! * **6:** matrix `c` is not of full rank, !! * **7:** rank defect in [[hfti]] integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use real ( wp ), intent ( in ) :: infbnd !! \"infinity\" for the upper and lower bounds. real ( wp ), dimension ( nl ) :: l real ( wp ), dimension ( n ) :: g real ( wp ), dimension ( la , n ) :: a real ( wp ), dimension ( la ) :: b real ( wp ), dimension ( * ) :: w real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: diag , xnorm integer :: i , ic , id , ie , iff , ig , ih , il , ip , & iw , i1 , i2 , i3 , i4 , mineq , & m1 , n1 , n2 , n3 , num_unbounded , j n1 = n + 1 mineq = m - meq m1 = mineq + n + n !  determine whether to solve problem !  with inconsistent linerarization (n2=1) !  or not (n2=0) n2 = n1 * n / 2 + 1 if ( n2 == nl ) then n2 = 0 else n2 = 1 end if n3 = n - n2 !  recover matrix e and vector f from l and g i2 = 1 i3 = 1 i4 = 1 ie = 1 iff = n * n + 1 do i = 1 , n3 i1 = n1 - i diag = sqrt ( l ( i2 )) w ( i3 ) = zero call dcopy ( i1 , w ( i3 ), 0 , w ( i3 ), 1 ) call dcopy ( i1 - n2 , l ( i2 ), 1 , w ( i3 ), n ) call dscal ( i1 - n2 , diag , w ( i3 ), n ) w ( i3 ) = diag w ( iff - 1 + i ) = ( g ( i ) - ddot ( i - 1 , w ( i4 ), 1 , w ( iff ), 1 )) / diag i2 = i2 + i1 - n2 i3 = i3 + n1 i4 = i4 + n end do if ( n2 == 1 ) then w ( i3 ) = l ( nl ) w ( i4 ) = zero call dcopy ( n3 , w ( i4 ), 0 , w ( i4 ), 1 ) w ( iff - 1 + n ) = zero end if call dscal ( n , - one , w ( iff ), 1 ) ic = iff + n id = ic + meq * n if ( meq > 0 ) then !  recover matrix c from upper part of a do i = 1 , meq call dcopy ( n , a ( i , 1 ), la , w ( ic - 1 + i ), meq ) end do !  recover vector d from upper part of b call dcopy ( meq , b ( 1 ), 1 , w ( id ), 1 ) call dscal ( meq , - one , w ( id ), 1 ) end if ig = id + meq if ( mineq > 0 ) then ! recover matrix g from lower part of a ! The matrix G(mineq+2*n,m1) is stored at w(ig) ! Not all rows will be filled if some of the upper/lower ! bounds are unbounded. do i = 1 , mineq call dcopy ( n , a ( meq + i , 1 ), la , w ( ig - 1 + i ), m1 ) end do end if ih = ig + m1 * n iw = ih + mineq + 2 * n if ( mineq > 0 ) then ! recover h from lower part of b ! The vector H(mineq+2*n) is stored at w(ih) call dcopy ( mineq , b ( meq + 1 ), 1 , w ( ih ), 1 ) call dscal ( mineq , - one , w ( ih ), 1 ) end if !  augment matrix g by +i and -i, and, !  augment vector h by xl and xu !  NaN or infBnd value indicates no bound ip = ig + mineq il = ih + mineq num_unbounded = 0 do i = 1 , n if ( ieee_is_nan ( xl ( i )) . or . xl ( i ) <=- infbnd ) then num_unbounded = num_unbounded + 1 else call update_w ( xl ( i ), one ) end if end do do i = 1 , n if ( ieee_is_nan ( xu ( i )) . or . xu ( i ) >= infbnd ) then num_unbounded = num_unbounded + 1 else call update_w ( xu ( i ), - one ) end if end do call lsei ( w ( ic ), w ( id ), w ( ie ), w ( iff ), w ( ig ), w ( ih ), max ( 1 , meq ), meq , n , n , & m1 , m1 - num_unbounded , n , x , xnorm , w ( iw ), mode , max_iter_ls , nnls_mode ) if ( mode == 1 ) then ! restore lagrange multipliers (only for user-defined variables) call dcopy ( m , w ( iw ), 1 , y ( 1 ), 1 ) if ( n3 > 0 ) then !set rest of the multipliers to nan (they are not used) y ( m + 1 ) = ieee_value ( one , ieee_quiet_nan ) do i = m + 2 , m + n3 + n3 y ( i ) = y ( m + 1 ) end do end if call enforce_bounds ( x , xl , xu , infbnd ) ! to ensure that bounds are not violated end if contains subroutine update_w ( val , fact ) real ( wp ), intent ( in ) :: val !! xu(i) or xl(i) real ( wp ), intent ( in ) :: fact !! -1 or 1 w ( il ) = fact * val do j = 1 , n w ( ip + m1 * ( j - 1 )) = zero end do w ( ip + m1 * ( i - 1 )) = fact ip = ip + 1 il = il + 1 end subroutine update_w end subroutine lsq","tags":"","url":"proc/lsq.html"},{"title":"lsei – slsqp","text":"private  subroutine lsei(c, d, e, f, g, h, lc, mc, le, me, lg, mg, n, x, xnrm, w, mode, max_iter_ls, nnls_mode) for mode=1 , the subroutine returns the solution x of\n  equality & inequality constrained least squares problem lsei : s.t. and . using QR decomposition & orthogonal basis of nullspace of . The following dimensions of the arrays defining the problem\n  are necessary: dim(c) :   formal (lc,n),    actual (mc,n)\n        dim(d) :   formal (lc  ),    actual (mc  )\n        dim(e) :   formal (le,n),    actual (me,n)\n        dim(f) :   formal (le  ),    actual (me  )\n        dim(g) :   formal (lg,n),    actual (mg,n)\n        dim(h) :   formal (lg  ),    actual (mg  )\n        dim(x) :   formal (n   ),    actual (n   )\n        dim(w) :   2*mc+me+(me+mg)*(n-mc)  for lsei\n                 +(n-mc+1)*(mg+2)+2*mg     for lsi\n        dim(jw):   max(mg,l) On entry, the user has to provide the arrays C, d, E, f, G, and h.\n  On return, all arrays will be changed by the subroutine. Reference Chapter 23.6 of Lawson & Hanson: Solving least squares problems. History 18.5.1981, dieter kraft, dfvlr oberpfaffenhofen 20.3.1987, dieter kraft, dfvlr oberpfaffenhofen Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(lc,n) :: c real(kind=wp), intent(inout), dimension(lc) :: d real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: lc integer, intent(in) :: mc integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnrm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w on return, stores the vector of lagrange multipliers\nin its first mc+mg elements integer, intent(out) :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank, 6: matrix c is not of full rank, 7: rank defect in hfti integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use Calls proc~~lsei~~CallsGraph proc~lsei lsei proc~dcopy dcopy proc~lsei->proc~dcopy proc~ddot ddot proc~lsei->proc~ddot proc~dnrm2 dnrm2 proc~lsei->proc~dnrm2 proc~h12 h12 proc~lsei->proc~h12 proc~hfti hfti proc~lsei->proc~hfti proc~lsi lsi proc~lsei->proc~lsi proc~hfti->proc~h12 proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~daxpy daxpy proc~lsi->proc~daxpy proc~ldp ldp proc~lsi->proc~ldp proc~ldp->proc~dcopy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~ldp->proc~daxpy proc~bvls_wrapper bvls_wrapper proc~ldp->proc~bvls_wrapper proc~nnls nnls proc~ldp->proc~nnls proc~bvls bvls proc~bvls_wrapper->proc~bvls proc~nnls->proc~h12 proc~g1 g1 proc~nnls->proc~g1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lsei~~CalledByGraph proc~lsei lsei proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lsei ( c , d , e , f , g , h , lc , mc , le , me , lg , mg , n , x , xnrm , w , mode ,& max_iter_ls , nnls_mode ) implicit none integer , intent ( in ) :: lc integer , intent ( in ) :: mc integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( lc , n ), intent ( inout ) :: c real ( wp ), dimension ( lc ) , intent ( inout ) :: d real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnrm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! on return, stores the vector of lagrange multipliers !! in its first `mc+mg` elements integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank, !! * ***6:*** matrix `c` is not of full rank, !! * ***7:*** rank defect in [[hfti]] integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use integer :: i , ie , if , ig , iw , j , k , krank , l , mc1 real ( wp ) :: t , dum ( 1 ) mode = 2 if ( mc <= n ) then l = n - mc mc1 = mc + 1 iw = ( l + 1 ) * ( mg + 2 ) + 2 * mg + mc ie = iw + mc + 1 if = ie + me * l ig = if + me !  triangularize c and apply factors to e and g do i = 1 , mc j = min ( i + 1 , lc ) call h12 ( 1 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), c ( j , 1 ), lc , 1 , mc - i ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), e , le , 1 , me ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), g , lg , 1 , mg ) end do !  solve c*x=d and modify f mode = 6 do i = 1 , mc if ( abs ( c ( i , i )) < epmach ) return x ( i ) = ( d ( i ) - ddot ( i - 1 , c ( i , 1 ), lc , x , 1 )) / c ( i , i ) end do mode = 1 w ( mc1 ) = zero !call dcopy(mg-mc,w(mc1),0,w(mc1),1)  ! original code call dcopy ( mg , w ( mc1 ), 0 , w ( mc1 ), 1 ) ! bug fix for when meq = n if ( mc /= n ) then do i = 1 , me w ( if - 1 + i ) = f ( i ) - ddot ( mc , e ( i , 1 ), le , x , 1 ) end do !  store transformed e & g do i = 1 , me call dcopy ( l , e ( i , mc1 ), le , w ( ie - 1 + i ), me ) end do do i = 1 , mg call dcopy ( l , g ( i , mc1 ), lg , w ( ig - 1 + i ), mg ) end do if ( mg > 0 ) then !  modify h and solve inequality constrained ls problem do i = 1 , mg h ( i ) = h ( i ) - ddot ( mc , g ( i , 1 ), lg , x , 1 ) end do call lsi ( w ( ie ), w ( if ), w ( ig ), h , me , me , mg , mg , l , x ( mc1 ), xnrm , & w ( mc1 ), mode , max_iter_ls , nnls_mode ) if ( mc == 0 ) return t = dnrm2 ( mc , x , 1 ) xnrm = sqrt ( xnrm * xnrm + t * t ) if ( mode /= 1 ) return else ! solve ls without inequality constraints mode = 7 k = max ( le , n ) t = sqrt ( epmach ) call hfti ( w ( ie ), me , me , l , w ( if ), k , 1 , t , krank , dum , w , w ( l + 1 )) xnrm = dum ( 1 ) call dcopy ( l , w ( if ), 1 , x ( mc1 ), 1 ) if ( krank /= l ) return mode = 1 end if end if !  solution of original problem and lagrange multipliers do i = 1 , me f ( i ) = ddot ( n , e ( i , 1 ), le , x , 1 ) - f ( i ) end do do i = 1 , mc d ( i ) = ddot ( me , e ( 1 , i ), 1 , f , 1 ) & - ddot ( mg , g ( 1 , i ), 1 , w ( mc1 ), 1 ) end do do i = mc , 1 , - 1 call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), x , 1 , 1 , 1 ) end do do i = mc , 1 , - 1 j = min ( i + 1 , lc ) w ( i ) = ( d ( i ) - ddot ( mc - i , c ( j , i ), 1 , w ( j ), 1 )) / c ( i , i ) end do end if end subroutine lsei","tags":"","url":"proc/lsei.html"},{"title":"lsi – slsqp","text":"private  subroutine lsi(e, f, g, h, le, me, lg, mg, n, x, xnorm, w, mode, max_iter_ls, nnls_mode) for mode=1 , the subroutine returns the solution x of\n  inequality constrained linear least squares problem: s.t. . the following dimensions of the arrays defining the problem\n  are necessary: dim(e) :   formal (le,n),    actual (me,n)\n     dim(f) :   formal (le  ),    actual (me  )\n     dim(g) :   formal (lg,n),    actual (mg,n)\n     dim(h) :   formal (lg  ),    actual (mg  )\n     dim(x) :   n\n     dim(w) :   (n+1)*(mg+2) + 2*mg\n     dim(jw):   lg on entry, the user has to provide the arrays e , f , g , and h .\n  on return, all arrays will be changed by the subroutine. Reference Chapter 23.6 of Lawson & Hanson: Solving least squares problems. History 03.01.1980, dieter kraft: coded 20.03.1987, dieter kraft: revised to fortran 77 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnorm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w stores the vector of lagrange multipliers in its first mg elements integer, intent(out) :: mode is a success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<1 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible, 5: matrix e is not of full rank. integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use Calls proc~~lsi~~CallsGraph proc~lsi lsi proc~daxpy daxpy proc~lsi->proc~daxpy proc~ddot ddot proc~lsi->proc~ddot proc~dnrm2 dnrm2 proc~lsi->proc~dnrm2 proc~h12 h12 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~ldp->proc~daxpy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~bvls_wrapper bvls_wrapper proc~ldp->proc~bvls_wrapper proc~dcopy dcopy proc~ldp->proc~dcopy proc~nnls nnls proc~ldp->proc~nnls proc~bvls bvls proc~bvls_wrapper->proc~bvls proc~nnls->proc~h12 proc~g1 g1 proc~nnls->proc~g1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~lsi~~CalledByGraph proc~lsi lsi proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lsi ( e , f , g , h , le , me , lg , mg , n , x , xnorm , w , mode , max_iter_ls , nnls_mode ) implicit none integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnorm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! stores the vector of lagrange multipliers in its first !! `mg` elements integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank. integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use integer :: i , j real ( wp ) :: t !  qr-factors of e and application to f do i = 1 , n j = min ( i + 1 , n ) call h12 ( 1 , i , i + 1 , me , e ( 1 , i ), 1 , t , e ( 1 , j ), 1 , le , n - i ) call h12 ( 2 , i , i + 1 , me , e ( 1 , i ), 1 , t , f , 1 , 1 , 1 ) end do !  transform g and h to get least distance problem mode = 5 do i = 1 , mg do j = 1 , n if ( abs ( e ( j , j )) < epmach . or . ieee_is_nan ( e ( j , j ))) return g ( i , j ) = ( g ( i , j ) - ddot ( j - 1 , g ( i , 1 ), lg , e ( 1 , j ), 1 )) / e ( j , j ) end do h ( i ) = h ( i ) - ddot ( n , g ( i , 1 ), lg , f , 1 ) end do !  solve least distance problem call ldp ( g , lg , mg , n , h , x , xnorm , w , mode , max_iter_ls , nnls_mode ) if ( mode == 1 ) then !  solution of original problem call daxpy ( n , one , f , 1 , x , 1 ) do i = n , 1 , - 1 j = min ( i + 1 , n ) x ( i ) = ( x ( i ) - ddot ( n - i , e ( i , j ), le , x ( j ), 1 )) / e ( i , i ) end do j = min ( n + 1 , me ) t = dnrm2 ( me - n , f ( j ), 1 ) xnorm = sqrt ( xnorm * xnorm + t * t ) end if end subroutine lsi","tags":"","url":"proc/lsi.html"},{"title":"ldp – slsqp","text":"private  subroutine ldp(g, mg, m, n, h, x, xnorm, w, mode, max_iter_ls, nnls_mode) Least distance programming routine.\n  Minimize subject to . The declared dimension of w must be at least (n+1)*(m+2)+2*m : first (n+1)*m locs of w = matrix e for problem nnls.\n       next      n+1 locs of w = vector f for problem nnls.\n       next      n+1 locs of w = vector z for problem nnls.\n       next        m locs of w = vector y for problem nnls.\n       next        m locs of w = vector wdual for problem nnls. References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Note The 1995 version of this routine may have some sort of problem.\n      Using a refactored version of the original routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(mg,n) :: g on entry g stores the m by n matrix of\nlinear inequality constraints. g has first\ndimensioning parameter mg integer, intent(in) :: mg integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in), dimension(m) :: h the right side of the inequality system. real(kind=wp), intent(out), dimension(n) :: x solution vector x if mode=1 . real(kind=wp), intent(out) :: xnorm euclidian norm of the solution vector\nif computation is successful real(kind=wp), intent(inout), dimension(*) :: w w is a one dimensional working space, the length\nof which should be at least (m+2)*(n+1) + 2*m .\non exit w stores the lagrange multipliers\nassociated with the constraints.\nat the solution of problem ldp . integer, intent(out) :: mode success-failure flag with the following meanings: 1: successful computation, 2: error return because of wrong dimensions ( n<=0 ), 3: iteration count exceeded by nnls , 4: inequality constraints incompatible. integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use Calls proc~~ldp~~CallsGraph proc~ldp ldp proc~bvls_wrapper bvls_wrapper proc~ldp->proc~bvls_wrapper proc~daxpy daxpy proc~ldp->proc~daxpy proc~dcopy dcopy proc~ldp->proc~dcopy proc~ddot ddot proc~ldp->proc~ddot proc~dnrm2 dnrm2 proc~ldp->proc~dnrm2 proc~nnls nnls proc~ldp->proc~nnls proc~bvls bvls proc~bvls_wrapper->proc~bvls proc~g1 g1 proc~nnls->proc~g1 proc~h12 h12 proc~nnls->proc~h12 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ldp~~CalledByGraph proc~ldp ldp proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ldp ( g , mg , m , n , h , x , xnorm , w , mode , max_iter_ls , nnls_mode ) implicit none integer , intent ( in ) :: mg integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), dimension ( mg , n ), intent ( in ) :: g !! on entry `g` stores the `m` by `n` matrix of !! linear inequality constraints. `g` has first !! dimensioning parameter `mg` real ( wp ), dimension ( m ), intent ( in ) :: h !! the right side of the inequality system. real ( wp ), dimension ( n ), intent ( out ) :: x !! solution vector `x` if `mode=1`. real ( wp ), dimension ( * ), intent ( inout ) :: w !! `w` is a one dimensional working space, the length !! of which should be at least `(m+2)*(n+1) + 2*m`. !! on exit `w` stores the lagrange multipliers !! associated with the constraints. !! at the solution of problem `ldp`. real ( wp ), intent ( out ) :: xnorm !! euclidian norm of the solution vector !! if computation is successful integer , intent ( out ) :: mode !! success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<=0`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible. integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use integer :: i , iw , iwdual , iy , iz , j , jf , n1 real ( wp ) :: fac , rnorm if ( n <= 0 ) then ! error return. mode = 2 else ! state dual problem mode = 1 x = zero xnorm = zero if ( m /= 0 ) then iw = 0 do j = 1 , m do i = 1 , n iw = iw + 1 w ( iw ) = g ( j , i ) end do iw = iw + 1 w ( iw ) = h ( j ) end do jf = iw + 1 do i = 1 , n iw = iw + 1 w ( iw ) = zero end do w ( iw + 1 ) = one n1 = n + 1 iz = iw + 2 iy = iz + n1 iwdual = iy + m ! solve dual problem select case ( nnls_mode ) case ( 1 ) ! original call nnls ( w , n1 , n1 , m , w ( jf ), w ( iy ), rnorm , w ( iwdual ), w ( iz ), mode , max_iter_ls ) case ( 2 ) ! new version call bvls_wrapper ( w , n1 , n1 , m , w ( jf ), w ( iy ), rnorm , w ( iwdual ), w ( iz ), mode , max_iter_ls ) case default error stop 'invalid nnls_mode' end select if ( mode == 1 ) then mode = 4 if ( rnorm > zero ) then !  compute solution of primal problem fac = one - ddot ( m , h , 1 , w ( iy ), 1 ) if ( ieee_is_nan ( fac )) return if ( fac >= eps ) then mode = 1 fac = one / fac do j = 1 , n x ( j ) = fac * ddot ( m , g ( 1 , j ), 1 , w ( iy ), 1 ) end do xnorm = dnrm2 ( n , x , 1 ) ! compute lagrange multipliers for primal problem w ( 1 ) = zero call dcopy ( m , w ( 1 ), 0 , w , 1 ) call daxpy ( m , fac , w ( iy ), 1 , w , 1 ) end if end if end if end if end if end subroutine ldp","tags":"","url":"proc/ldp.html"},{"title":"nnls – slsqp","text":"private  subroutine nnls(a, mda, m, n, b, x, rnorm, w, zz, mode, max_iter) Nonnegative least squares algorithm. Given an m by n matrix, , and an m-vector, ,\n  compute an n-vector, , that solves the least squares problem: subject to References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a on entry, contains the m by n matrix, a . on exit, contains\nthe product matrix, q*a , where q is an m by m orthogonal matrix generated implicitly by\nthis subroutine. integer, intent(in) :: mda first dimensioning parameter for the array a . integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(m) :: b on entry, contains the m-vector b . on exit, contains q*b . real(kind=wp), intent(out), dimension(n) :: x the solution vector. real(kind=wp), intent(out) :: rnorm euclidean norm of the residual vector. real(kind=wp), intent(inout), dimension(n) :: w array of working space.  on exit w will contain\nthe dual solution vector. w will satisfy w(i) = 0 for all i in set p and w(i) <= 0 for all i in set z . real(kind=wp), intent(inout), dimension(m) :: zz an m-array of working space. integer, intent(out) :: mode this is a success-failure flag with the following meanings: 1 the solution has been computed successfully. 2 the dimensions of the problem are bad. either m<=0 or n<=0 . 3 iteration count exceeded. more than 3*n iterations. integer, intent(in) :: max_iter maximum number of iterations (if <=0, then 3*n is used) Calls proc~~nnls~~CallsGraph proc~nnls nnls proc~g1 g1 proc~nnls->proc~g1 proc~h12 h12 proc~nnls->proc~h12 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~nnls~~CalledByGraph proc~nnls nnls proc~ldp ldp proc~ldp->proc~nnls proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine nnls ( a , mda , m , n , b , x , rnorm , w , zz , mode , max_iter ) implicit none integer , intent ( in ) :: mda !! first dimensioning parameter for the array `a`. integer , intent ( in ) :: n real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! on entry, contains the `m` by `n` !! matrix, `a`. on exit, contains !! the product matrix, `q*a`, where `q` is an !! `m` by `m` orthogonal matrix generated implicitly by !! this subroutine. integer , intent ( in ) :: m real ( wp ), dimension ( m ), intent ( inout ) :: b !! on entry, contains the m-vector `b`. on exit, contains `q*b`. real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution vector. real ( wp ), intent ( out ) :: rnorm !! euclidean norm of the residual vector. real ( wp ), dimension ( n ), intent ( inout ) :: w !! array of working space.  on exit `w` will contain !! the dual solution vector. `w` will satisfy `w(i) = 0` !! for all `i` in set `p` and `w(i) <= 0` for all `i` in set `z`. real ( wp ), dimension ( m ), intent ( inout ) :: zz !! an m-array of working space. integer , intent ( out ) :: mode !! this is a success-failure flag with the following meanings: !! !! * ***1*** the solution has been computed successfully. !! * ***2*** the dimensions of the problem are bad. either `m<=0` or `n<=0`. !! * ***3*** iteration count exceeded. more than `3*n` iterations. integer , intent ( in ) :: max_iter !! maximum number of iterations (if <=0, then `3*n` is used) integer :: i , ii , ip , iter , itmax , iz , iz1 , iz2 , izmax , j , jj , jz , l , npp1 , nsetp , rtnkey real ( wp ) :: alpha , asave , cc , sm , ss , t , temp , unorm , up , wmax , ztest real ( wp ), dimension ( 1 ) :: dummy integer , dimension ( n ) :: index !! an integer working array. !! the contents of this array define the sets !! `p` and `z` as follows: !! !! * `index(1:nsetp) = set p`. !! * `index(iz1:iz2) = set z`. !! !! where: `iz1 = nsetp + 1 = npp1`, `iz2 = n` real ( wp ), parameter :: factor = 0.01_wp mode = 1 if ( m <= 0 . or . n <= 0 ) then mode = 2 return end if iter = 0 if ( max_iter <= 0 ) then itmax = 3 * n else itmax = max_iter end if ! initialize the arrays index(1:n) and x(1:n). x = zero index = [( i , i = 1 , n )] iz2 = n iz1 = 1 nsetp = 0 npp1 = 1 main : do ! ******  main loop begins here  ****** ! quit if all coefficients are already in the solution. ! or if m cols of a have been triangularized. if ( iz1 <= iz2 . and . nsetp < m ) then ! compute components of the dual (negative gradient) vector w(). do iz = iz1 , iz2 j = index ( iz ) sm = zero do l = npp1 , m sm = sm + a ( l , j ) * b ( l ) end do w ( j ) = sm end do do ! find largest positive w(j). wmax = zero do iz = iz1 , iz2 j = index ( iz ) if ( w ( j ) > wmax ) then wmax = w ( j ) izmax = iz end if end do ! if wmax <= 0. go to termination. ! this indicates satisfaction of the kuhn-tucker conditions. if ( wmax <= zero ) then call termination () return end if iz = izmax j = index ( iz ) ! the sign of w(j) is ok for j to be moved to set p. ! begin the transformation and check new diagonal element to avoid ! near linear dependence. asave = a ( npp1 , j ) call h12 ( 1 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , dummy , 1 , 1 , 0 ) unorm = zero if ( nsetp /= 0 ) then do l = 1 , nsetp unorm = unorm + a ( l , j ) ** 2 end do end if unorm = sqrt ( unorm ) if ( abs ( a ( npp1 , j )) * factor >= unorm * eps ) then ! col j is sufficiently independent.  copy b into zz, update zz ! and solve for ztest ( = proposed new value for x(j) ). do l = 1 , m zz ( l ) = b ( l ) end do call h12 ( 2 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , zz , 1 , 1 , 1 ) ztest = zz ( npp1 ) / a ( npp1 , j ) ! see if ztest is positive if ( ztest > zero ) then ! the index j=index(iz) has been selected to be moved from ! set z to set p. update b, update indices, apply householder ! transformations to cols in new set z, zero subdiagonal elts in ! col j, set w(j)=0. do l = 1 , m b ( l ) = zz ( l ) end do index ( iz ) = index ( iz1 ) index ( iz1 ) = j iz1 = iz1 + 1 nsetp = npp1 npp1 = npp1 + 1 if ( iz1 <= iz2 ) then do jz = iz1 , iz2 jj = index ( jz ) call h12 ( 2 , nsetp , npp1 , m , a ( 1 , j ), 1 , up , a ( 1 , jj ), 1 , mda , 1 ) end do end if if ( nsetp /= m ) then do l = npp1 , m a ( l , j ) = zero end do end if w ( j ) = zero ! solve the triangular system. ! store the solution temporarily in zz(). rtnkey = 1 exit end if end if ! reject j as a candidate to be moved from set z to set p. ! restore a(npp1,j), set w(j)=0., and loop back to test dual ! coeffs again. a ( npp1 , j ) = asave w ( j ) = zero end do else call termination () return end if ! ******  end of main loop  ****** secondary : do ! the following block of code is used as an internal subroutine ! to solve the triangular system, putting the solution in zz(). do l = 1 , nsetp ip = nsetp + 1 - l if ( l /= 1 ) then do ii = 1 , ip zz ( ii ) = zz ( ii ) - a ( ii , jj ) * zz ( ip + 1 ) end do end if jj = index ( ip ) zz ( ip ) = zz ( ip ) / a ( ip , jj ) end do if ( rtnkey /= 1 . and . rtnkey /= 2 ) return ! ******  secondary loop begins here ****** ! iteration counter. iter = iter + 1 if ( iter > itmax ) then mode = 3 !write (*,'(/a)') ' nnls quitting on iteration count.' call termination () return end if ! see if all new constrained coeffs are feasible. ! if not compute alpha. alpha = two do ip = 1 , nsetp l = index ( ip ) if ( zz ( ip ) <= zero ) then t = - x ( l ) / ( zz ( ip ) - x ( l )) if ( alpha > t ) then alpha = t jj = ip end if end if end do ! if all new constrained coeffs are feasible then alpha will ! still = 2.    if so exit from secondary loop to main loop. if ( abs ( alpha - two ) <= zero ) then ! ******  end of secondary loop  ****** do ip = 1 , nsetp i = index ( ip ) x ( i ) = zz ( ip ) end do ! all new coeffs are positive.  loop back to beginning. cycle main end if ! otherwise use alpha which will be between 0. and 1. to ! interpolate between the old x and the new zz. do ip = 1 , nsetp l = index ( ip ) x ( l ) = x ( l ) + alpha * ( zz ( ip ) - x ( l )) end do ! modify a and b and the index arrays to move coefficient i ! from set p to set z. i = index ( jj ) move_p : do x ( i ) = zero if ( jj /= nsetp ) then jj = jj + 1 do j = jj , nsetp ii = index ( j ) index ( j - 1 ) = ii call g1 ( a ( j - 1 , ii ), a ( j , ii ), cc , ss , a ( j - 1 , ii )) a ( j , ii ) = zero do l = 1 , n if ( l /= ii ) then ! apply procedure g2 (cc,ss,a(j-1,l),a(j,l)) temp = a ( j - 1 , l ) a ( j - 1 , l ) = cc * temp + ss * a ( j , l ) a ( j , l ) = - ss * temp + cc * a ( j , l ) end if end do ! apply procedure g2 (cc,ss,b(j-1),b(j)) temp = b ( j - 1 ) b ( j - 1 ) = cc * temp + ss * b ( j ) b ( j ) = - ss * temp + cc * b ( j ) end do end if npp1 = nsetp nsetp = nsetp - 1 iz1 = iz1 - 1 index ( iz1 ) = i ! see if the remaining coeffs in set p are feasible.  they should ! be because of the way alpha was determined. ! if any are infeasible it is due to round-off error.  any ! that are nonpositive will be set to zero ! and moved from set p to set z. do jj = 1 , nsetp i = index ( jj ) if ( x ( i ) <= zero ) cycle move_p end do exit move_p end do move_p ! copy b( ) into zz( ).  then solve again and loop back. do i = 1 , m zz ( i ) = b ( i ) end do rtnkey = 2 end do secondary end do main contains subroutine termination () !! come to here for termination. !! compute the norm of the final residual vector. sm = zero if ( npp1 <= m ) then do i = npp1 , m sm = sm + b ( i ) ** 2 end do else do j = 1 , n w ( j ) = zero end do end if rnorm = sqrt ( sm ) end subroutine termination end subroutine nnls","tags":"","url":"proc/nnls.html"},{"title":"hfti – slsqp","text":"private  subroutine hfti(a, mda, m, n, b, mdb, nb, tau, krank, rnorm, h, g) Rank-deficient least squares algorithm using\n  householder forward triangulation with column interchanges. References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a the array a initially contains the matrix of the least squares problem .\neither m >= n or m < n is permitted.\nthere is no restriction on the rank of a .\nthe matrix a will be modified by the subroutine. integer, intent(in) :: mda the first dimensioning parameter of matrix a (mda >= m). integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(mdb,nb) :: b if nb = 0 the subroutine will make no reference\nto the array b . if nb > 0 the array b must\ninitially contain the m x nb matrix b of the\nthe least squares problem ax = b and on return\nthe array b will contain the n x nb solution x . integer, intent(in) :: mdb first dimensioning parameter of matrix b (mdb>=max(m,n)) integer, intent(in) :: nb real(kind=wp), intent(in) :: tau absolute tolerance parameter for pseudorank\ndetermination, provided by the user. integer, intent(out) :: krank pseudorank of a , set by the subroutine. real(kind=wp), intent(out), dimension(nb) :: rnorm on exit, rnorm(j) will contain the euclidian\nnorm of the residual vector for the problem\ndefined by the j-th column vector of the array b . real(kind=wp), intent(inout), dimension(n) :: h array of working space real(kind=wp), intent(inout), dimension(n) :: g array of working space Calls proc~~hfti~~CallsGraph proc~hfti hfti proc~h12 h12 proc~hfti->proc~h12 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hfti~~CalledByGraph proc~hfti hfti proc~lsei lsei proc~lsei->proc~hfti proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hfti ( a , mda , m , n , b , mdb , nb , tau , krank , rnorm , h , g ) implicit none integer , intent ( in ) :: mda !! the first dimensioning parameter of matrix `a` (mda >= m). integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: mdb !! first dimensioning parameter of matrix `b` (mdb>=max(m,n)) integer , intent ( in ) :: nb real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! the array `a` initially contains the  m \\times n  matrix \\mathbf{A} !! of the least squares problem  \\mathbf{A} \\mathbf{x} = \\mathbf{b} . !! either `m >= n` or `m < n` is permitted. !! there is no restriction on the rank of `a`. !! the matrix `a` will be modified by the subroutine. real ( wp ), intent ( in ) :: tau !! absolute tolerance parameter for pseudorank !! determination, provided by the user. integer , intent ( out ) :: krank !! pseudorank of `a`, set by the subroutine. real ( wp ), dimension ( nb ), intent ( out ) :: rnorm !! on exit, `rnorm(j)` will contain the euclidian !! norm of the residual vector for the problem !! defined by the `j-th` column vector of the array `b`. real ( wp ), dimension ( n ), intent ( inout ) :: h !! array of working space real ( wp ), dimension ( n ), intent ( inout ) :: g !! array of working space real ( wp ), dimension ( mdb , nb ), intent ( inout ) :: b !! if `nb = 0` the subroutine will make no reference !! to the array `b`. if `nb > 0` the array `b` must !! initially contain the `m x nb` matrix `b` of the !! the least squares problem `ax = b` and on return !! the array `b` will contain the `n x nb` solution `x`. integer :: i , ii , ip1 , j , jb , jj , k , kp1 , l , ldiag , lmax real ( wp ) :: hmax , sm , tmp logical :: need_lmax integer , dimension ( n ) :: ip !! integer array of working space !! recording permutation indices of column vectors real ( wp ), parameter :: factor = 0.001_wp k = 0 ldiag = min ( m , n ) if ( ldiag <= 0 ) then ! the solution vectors, x, are now ! in the first  n  rows of the array b(,). krank = k return else do j = 1 , ldiag need_lmax = . true . if ( j /= 1 ) then ! update squared column lengths and find lmax lmax = j do l = j , n h ( l ) = h ( l ) - a ( j - 1 , l ) ** 2 if ( h ( l ) > h ( lmax ) ) lmax = l end do if ( factor * h ( lmax ) >= hmax * eps ) need_lmax = . false . end if if ( need_lmax ) then ! compute squared column lengths and find lmax lmax = j do l = j , n h ( l ) = zero do i = j , m h ( l ) = h ( l ) + a ( i , l ) ** 2 end do if ( h ( l ) > h ( lmax ) ) lmax = l end do hmax = h ( lmax ) end if ! lmax has been determined ! do column interchanges if needed. ip ( j ) = lmax if ( ip ( j ) /= j ) then do i = 1 , m tmp = a ( i , j ) a ( i , j ) = a ( i , lmax ) a ( i , lmax ) = tmp end do h ( lmax ) = h ( j ) end if ! compute the j-th transformation and apply it to a and b. call h12 ( 1 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), a ( 1 , j + 1 ), 1 , mda , n - j ) call h12 ( 2 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), b , 1 , mdb , nb ) end do ! determine the pseudorank, k, using the tolerance, tau. do j = 1 , ldiag if ( abs ( a ( j , j )) <= tau ) exit end do k = j - 1 kp1 = j end if ! compute the norms of the residual vectors. if ( nb > 0 ) then do jb = 1 , nb tmp = zero if ( kp1 <= m ) then do i = kp1 , m tmp = tmp + b ( i , jb ) ** 2 end do end if rnorm ( jb ) = sqrt ( tmp ) end do end if ! special for pseudorank = 0 if ( k > 0 ) then ! if the pseudorank is less than n compute householder ! decomposition of first k rows. if ( k /= n ) then do ii = 1 , k i = kp1 - ii call h12 ( 1 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), a , mda , 1 , i - 1 ) end do end if if ( nb > 0 ) then do jb = 1 , nb ! solve the k by k triangular system. do l = 1 , k sm = zero i = kp1 - l if ( i /= k ) then ip1 = i + 1 do j = ip1 , k sm = sm + a ( i , j ) * b ( j , jb ) end do end if b ( i , jb ) = ( b ( i , jb ) - sm ) / a ( i , i ) end do ! complete computation of solution vector. if ( k /= n ) then do j = kp1 , n b ( j , jb ) = zero end do do i = 1 , k call h12 ( 2 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), b ( 1 , jb ), 1 , mdb , 1 ) end do end if ! re-order the solution vector to compensate for the ! column interchanges. do jj = 1 , ldiag j = ldiag + 1 - jj if ( ip ( j ) /= j ) then l = ip ( j ) tmp = b ( l , jb ) b ( l , jb ) = b ( j , jb ) b ( j , jb ) = tmp end if end do end do end if else if ( nb > 0 ) then do jb = 1 , nb do i = 1 , n b ( i , jb ) = zero end do end do end if krank = k end subroutine hfti","tags":"","url":"proc/hfti.html"},{"title":"h12 – slsqp","text":"private  subroutine h12(mode, lpivot, l1, m, u, iue, up, c, ice, icv, ncv) Construction and/or application of a single\n  householder transformation . References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode 1 or 2 -- selects algorithm h1 to construct and apply a\nhouseholder transformation, or algorithm h2 to apply a\npreviously constructed transformation. integer, intent(in) :: lpivot the index of the pivot element integer, intent(in) :: l1 if l1 <= m the transformation will be constructed to\nzero elements indexed from l1 through m .\nif l1 > m the subroutine does an identity transformation. integer, intent(in) :: m see li . real(kind=wp), intent(inout), dimension(iue,*) :: u on entry with mode = 1 , u contains the pivot\nvector. iue is the storage increment between elements.\non exit when mode = 1 , u and up contain quantities\ndefining the vector u of the householder transformation.\non entry with mode = 2 , u and up should contain\nquantities previously computed with mode = 1 .  these will\nnot be modified during the entry with mode = 2 . dimension[u(iue,m)] integer, intent(in) :: iue see u . real(kind=wp), intent(inout) :: up see u . real(kind=wp), intent(inout), dimension(*) :: c on entry with mode = 1 or 2 , c contains a matrix which\nwill be regarded as a set of vectors to which the\nhouseholder transformation is to be applied.\non exit c contains the set of transformed vectors. integer, intent(in) :: ice storage increment between elements of vectors in c . integer, intent(in) :: icv storage increment between vectors in c . integer, intent(in) :: ncv number of vectors in c to be transformed. if ncv <= 0 no operations will be done on c . Called by proc~~h12~~CalledByGraph proc~h12 h12 proc~hfti hfti proc~hfti->proc~h12 proc~lsei lsei proc~lsei->proc~h12 proc~lsei->proc~hfti proc~lsi lsi proc~lsei->proc~lsi proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~nnls nnls proc~nnls->proc~h12 proc~ldp->proc~nnls proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine h12 ( mode , lpivot , l1 , m , u , iue , up , c , ice , icv , ncv ) implicit none integer , intent ( in ) :: mode !! `1` or `2` -- selects algorithm ***h1*** to construct and apply a !! householder transformation, or algorithm ***h2*** to apply a !! previously constructed transformation. integer , intent ( in ) :: lpivot !! the index of the pivot element integer , intent ( in ) :: l1 !! if `l1 <= m` the transformation will be constructed to !! zero elements indexed from `l1` through `m`. !! if `l1 > m` the subroutine does an identity transformation. integer , intent ( in ) :: m !! see `li`. integer , intent ( in ) :: iue !! see `u`. real ( wp ), dimension ( iue , * ), intent ( inout ) :: u !! on entry with `mode = 1`, `u` contains the pivot !! vector.  `iue` is the storage increment between elements. !! on exit when `mode = 1`, `u` and `up` contain quantities !! defining the vector `u` of the householder transformation. !! on entry with `mode = 2`, `u` and `up` should contain !! quantities previously computed with `mode = 1`.  these will !! not be modified during the entry with `mode = 2`. !! `dimension[u(iue,m)]` real ( wp ), intent ( inout ) :: up !! see `u`. real ( wp ), dimension ( * ), intent ( inout ) :: c !! on entry with `mode = 1 or 2`, `c` contains a matrix which !! will be regarded as a set of vectors to which the !! householder transformation is to be applied. !! on exit `c` contains the set of transformed vectors. integer , intent ( in ) :: ice !! storage increment between elements of vectors in `c`. integer , intent ( in ) :: icv !! storage increment between vectors in `c`. integer , intent ( in ) :: ncv !! number of vectors in `c` to be transformed. if `ncv <= 0` !! no operations will be done on `c`. integer :: i , i2 , i3 , i4 , incr , j real ( wp ) :: b , cl , clinv , sm if ( 0 >= lpivot . or . lpivot >= l1 . or . l1 > m ) return cl = abs ( u ( 1 , lpivot )) if ( mode /= 2 ) then ! construct the transformation. do j = l1 , m cl = max ( abs ( u ( 1 , j )), cl ) end do if ( cl <= zero ) return clinv = one / cl sm = ( u ( 1 , lpivot ) * clinv ) ** 2 do j = l1 , m sm = sm + ( u ( 1 , j ) * clinv ) ** 2 end do cl = cl * sqrt ( sm ) if ( u ( 1 , lpivot ) > zero ) cl = - cl up = u ( 1 , lpivot ) - cl u ( 1 , lpivot ) = cl else if ( cl <= zero ) then return end if if ( ncv > 0 ) then ! apply the transformation i+u*(u**t)/b to c. b = up * u ( 1 , lpivot ) ! b must be nonpositive here. if ( b < zero ) then b = one / b i2 = 1 - icv + ice * ( lpivot - 1 ) incr = ice * ( l1 - lpivot ) do j = 1 , ncv i2 = i2 + icv i3 = i2 + incr i4 = i3 sm = c ( i2 ) * up do i = l1 , m sm = sm + c ( i3 ) * u ( 1 , i ) i3 = i3 + ice end do if ( abs ( sm ) > zero ) then sm = sm * b c ( i2 ) = c ( i2 ) + sm * up do i = l1 , m c ( i4 ) = c ( i4 ) + sm * u ( 1 , i ) i4 = i4 + ice end do end if end do end if end if end subroutine h12","tags":"","url":"proc/h12.html"},{"title":"g1 – slsqp","text":"private  subroutine g1(a, b, c, s, sig) Compute orthogonal rotation matrix. Compute matrix so that Compute is computed last to allow for the possibility that sig may be in the same location as a or b . References C.L. Lawson, R.J. Hanson, 'Solving least squares problems'\n    Prentice Hall, 1974. (revised 1995 edition) lawson-hanson from Netlib. History Jacob Williams, refactored into modern Fortran, Jan. 2016. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s real(kind=wp) :: sig Called by proc~~g1~~CalledByGraph proc~g1 g1 proc~nnls nnls proc~nnls->proc~g1 proc~ldp ldp proc~ldp->proc~nnls proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine g1 ( a , b , c , s , sig ) implicit none real ( wp ) :: a real ( wp ) :: b real ( wp ) :: sig real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s real ( wp ) :: xr , yr if ( abs ( a ) > abs ( b ) ) then xr = b / a yr = sqrt ( one + xr ** 2 ) c = sign ( one / yr , a ) s = c * xr sig = abs ( a ) * yr else if ( abs ( b ) > zero ) then xr = a / b yr = sqrt ( one + xr ** 2 ) s = sign ( one / yr , b ) c = s * xr sig = abs ( b ) * yr else sig = zero c = zero s = one end if end if end subroutine g1","tags":"","url":"proc/g1.html"},{"title":"ldl – slsqp","text":"private  subroutine ldl(n, a, z, sigma, w) - rank-one - update Purpose: Updates the factors of matrix by rank-one matrix . Reference R. Fletcher, M.J.D. Powell,\n    \" On the modification of LDL' factorization \".\n    Mathematics of Computation Vol. 28, No. 128, p. 1067-1087, October 1974. History D. Kraft, DFVLR - institut fuer dynamik der flugsysteme\n    d-8031  oberpfaffenhofen Status: 15. january 1980 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the coefficient matrix a real(kind=wp), intent(inout), dimension(*) :: a In: positive definite matrix of dimension n ;\nonly the lower triangle is used and is stored column by\ncolumn as one dimensional array of dimension n*(n+1)/2 . Out: updated factors real(kind=wp), intent(inout), dimension(*) :: z vector of dimension n of updating elements. real(kind=wp), intent(in) :: sigma scalar factor by which the modifying dyade is multiplied. real(kind=wp), intent(inout), dimension(*) :: w working array of dimension n (used only if ). Called by proc~~ldl~~CalledByGraph proc~ldl ldl proc~slsqpb slsqpb proc~slsqpb->proc~ldl proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ldl ( n , a , z , sigma , w ) implicit none integer , intent ( in ) :: n !! order of the coefficient matrix `a` real ( wp ), intent ( in ) :: sigma !! scalar factor by which the modifying dyade z z&#94;T is multiplied. real ( wp ), dimension ( * ), intent ( inout ) :: a !! ***In:*** positive definite matrix of dimension `n`; !! only the lower triangle is used and is stored column by !! column as one dimensional array of dimension `n*(n+1)/2`. !! !! ***Out:*** updated LDL&#94;T factors real ( wp ), dimension ( * ), intent ( inout ) :: w !! working array of dimension `n` (used only if  \\sigma \\lt 0  ). real ( wp ), dimension ( * ), intent ( inout ) :: z !! vector of dimension `n` of updating elements. integer :: i , ij , j real ( wp ) :: t , v , u , tp , beta , alpha , delta , gamma if ( abs ( sigma ) > zero ) then ij = 1 t = one / sigma if ( sigma <= zero ) then ! prepare negative update do i = 1 , n w ( i ) = z ( i ) end do do i = 1 , n v = w ( i ) t = t + v * v / a ( ij ) do j = i + 1 , n ij = ij + 1 w ( j ) = w ( j ) - v * a ( ij ) end do ij = ij + 1 end do if ( t >= zero ) t = epmach / sigma do i = 1 , n j = n + 1 - i ij = ij - i u = w ( j ) w ( j ) = t t = t - u * u / a ( ij ) end do end if ! here updating begins do i = 1 , n v = z ( i ) delta = v / a ( ij ) if ( sigma < zero ) tp = w ( i ) if ( sigma > zero ) tp = t + delta * v alpha = tp / t a ( ij ) = alpha * a ( ij ) if ( i == n ) return beta = delta / tp if ( alpha > four ) then gamma = t / tp do j = i + 1 , n ij = ij + 1 u = a ( ij ) a ( ij ) = gamma * u + beta * z ( j ) z ( j ) = z ( j ) - v * u end do else do j = i + 1 , n ij = ij + 1 z ( j ) = z ( j ) - v * a ( ij ) a ( ij ) = a ( ij ) + beta * z ( j ) end do end if ij = ij + 1 t = tp end do end if end subroutine ldl","tags":"","url":"proc/ldl.html"},{"title":"enforce_bounds – slsqp","text":"private  subroutine enforce_bounds(x, xl, xu, infbnd) enforce the bound constraints on x . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x optimization variable vector real(kind=wp), intent(in), dimension(:) :: xl lower bounds (must be same dimension as x ) real(kind=wp), intent(in), dimension(:) :: xu upper bounds (must be same dimension as x ) real(kind=wp), intent(in) :: infbnd \"infinity\" for the upper and lower bounds.\nNote that NaN may also be used to indicate no bound. Called by proc~~enforce_bounds~~CalledByGraph proc~enforce_bounds enforce_bounds proc~lsq lsq proc~lsq->proc~enforce_bounds proc~slsqpb slsqpb proc~slsqpb->proc~enforce_bounds proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine enforce_bounds ( x , xl , xu , infbnd ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( in ) :: xl !! lower bounds (must be same dimension as `x`) real ( wp ), dimension (:), intent ( in ) :: xu !! upper bounds (must be same dimension as `x`) real ( wp ), intent ( in ) :: infbnd !! \"infinity\" for the upper and lower bounds. !! Note that `NaN` may also be used to indicate no bound. where ( x < xl . and . xl >- infbnd . and . . not . ieee_is_nan ( xl )) x = xl elsewhere ( x > xu . and . xu < infbnd . and . . not . ieee_is_nan ( xu )) x = xu end where end subroutine enforce_bounds","tags":"","url":"proc/enforce_bounds.html"},{"title":"destroy_slsqpb_data – slsqp","text":"private  subroutine destroy_slsqpb_data(me) Destructor for slsqpb_data type. Type Bound slsqpb_data Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me Source Code subroutine destroy_slsqpb_data ( me ) implicit none class ( slsqpb_data ), intent ( out ) :: me end subroutine destroy_slsqpb_data","tags":"","url":"proc/destroy_slsqpb_data.html"},{"title":"destroy_linmin_data – slsqp","text":"private  subroutine destroy_linmin_data(me) Destructor for linmin_data type. Type Bound linmin_data Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me Called by proc~~destroy_linmin_data~~CalledByGraph proc~destroy_linmin_data linmin_data%destroy_linmin_data proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~destroy_linmin_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_linmin_data ( me ) implicit none class ( linmin_data ), intent ( out ) :: me end subroutine destroy_linmin_data","tags":"","url":"proc/destroy_linmin_data.html"},{"title":"bvls_wrapper – slsqp","text":"public  subroutine bvls_wrapper(a, mda, m, n, b, x, rnorm, w, zz, mode, max_iter) Call bvls , but matching the interface of the old nnls . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a integer, intent(in) :: mda integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(m) :: b real(kind=wp), intent(out), dimension(n) :: x real(kind=wp), intent(out) :: rnorm real(kind=wp), intent(inout), dimension(n) :: w real(kind=wp), intent(inout), dimension(m) :: zz integer, intent(out) :: mode integer, intent(in) :: max_iter maximum number of iterations\n(if <=0, then 3*n is used) Calls proc~~bvls_wrapper~~CallsGraph proc~bvls_wrapper bvls_wrapper proc~bvls bvls proc~bvls_wrapper->proc~bvls Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~bvls_wrapper~~CalledByGraph proc~bvls_wrapper bvls_wrapper proc~ldp ldp proc~ldp->proc~bvls_wrapper proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bvls_wrapper ( a , mda , m , n , b , x , rnorm , w , zz , mode , max_iter ) implicit none integer , intent ( in ) :: mda integer , intent ( in ) :: n real ( wp ), dimension ( mda , n ), intent ( inout ) :: a integer , intent ( in ) :: m real ( wp ), dimension ( m ), intent ( inout ) :: b real ( wp ), dimension ( n ), intent ( out ) :: x real ( wp ), intent ( out ) :: rnorm real ( wp ), dimension ( n ), intent ( inout ) :: w real ( wp ), dimension ( m ), intent ( inout ) :: zz integer , intent ( out ) :: mode integer , intent ( in ) :: max_iter !! maximum number of iterations !! (if <=0, then `3*n` is used) integer , dimension ( n ) :: index integer :: ierr integer :: nsetp real ( wp ), dimension ( 2 , n ) :: bnd !! BND(1,J) is the lower bound for X(J). !! BND(2,J) is the upper bound for X(J). ! set bounds for nnls: bnd ( 1 ,:) = 0.0_wp bnd ( 2 ,:) = huge ( 0.0_wp ) call bvls ( a , b , bnd , x , rnorm , nsetp , w , index , ierr , max_iter ) select case ( ierr ) case ( 0 ) mode = 1 case ( 1 : 2 ) mode = 2 case ( 3 ) ! doesn't exist in nnls... but will never happen because ! we are setting bounds above mode = - 999 case ( 4 ) mode = 3 case default mode = - 9999 !error stop 'unknown output from bvls' end select end subroutine bvls_wrapper","tags":"","url":"proc/bvls_wrapper.html"},{"title":"bvls – slsqp","text":"public  subroutine bvls(a, b, bnd, x, rnorm, nsetp, w, index, ierr, max_iter) Given an m by n matrix, , and an m-vector, ,\n  compute an n-vector, , that solves the least squares problem: subject to satisfying: This algorithm is a generalization of nnls , that solves\n  the least-squares problem, A * X = B , subject to all X(J) >= 0 . History The subroutine nnls appeared in 'Solving least squares problems,'\n    by Lawson and Hanson, Prentice-Hall, 1974.  Work on BVLS was started\n    by C. L. Lawson and R. J. Hanson at Jet Propulsion Laboratory,\n    1973 June 12.  Many modifications were subsequently made.\n    This Fortran 90 code was completed in April, 1995 by R. J. Hanson. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:,:) :: a On entry A() contains the M by N matrix, A.\nOn return A() contains the product matrix, Q*A, where\nQ is an M by M orthogonal matrix generated by this\nsubroutine.  The dimensions are M=size(A,1) and N=size(A,2). real(kind=wp), intent(inout), dimension(:) :: b On entry B() contains the M-vector, B.\nOn return, B() contains Q*B.  The same Q multiplies A. real(kind=wp), intent(in), dimension(:,:) :: bnd BND(1,J) is the lower bound for X(J).\nBND(2,J) is the upper bound for X(J). Require:  BND(1,J)  <=  BND(2,J). The values BND(1,J) = -huge(ONE) and BND(2,J) = huge(ONE) are\nsuggested choices to designate that there is no constraint in that\ndirection.  The parameter ONE is 1.0 in the working precision. real(kind=wp), intent(out), dimension(:) :: x On entry X() need not be initialized.  On return,\nX() will contain the solution N-vector. real(kind=wp), intent(out) :: rnorm Euclidean norm of the residual vector, b - A*X. integer, intent(out) :: nsetp Indicates the number of components of the solution\nvector, X(), that are not at their constraint values. real(kind=wp), intent(out), dimension(:) :: w An N-array.  On return, W() will contain the dual solution\nvector.   Using Set definitions below: W(J) = 0 for all j in Set P, W(J)  <=  0 for all j in Set Z, such that X(J) is at its\n  lower bound, and W(J)  >=  0 for all j in Set Z, such that X(J) is at its\n  upper bound. If BND(1,J) = BND(2,J), so the variable X(J) is fixed,\nthen W(J) will have an arbitrary value. integer, intent(out), dimension(:) :: index An INTEGER working array of size N.  On exit the contents\nof this array define the sets P, Z, and F as follows: INDEX(1)   through INDEX(NSETP)    =  Set P. INDEX(IZ1) through INDEX(IZ2)      = Set Z. INDEX(IZ2+1) through INDEX(N)      = Set F. IZ1 = NSETP + 1 = NPP1 Any of these sets may be empty.  Set F is those components\nthat are constrained to a unique value by the given\nconstraints.   Sets P and Z are those that are allowed a non-\nzero range of values.  Of these, set Z are those whose final\nvalue is a constraint value, while set P are those whose\nfinal value is not a constraint.  The value of IZ2 is not returned. It is computable as the number of bounds constraining a component\nof X uniquely. integer, intent(out) :: ierr Indicates status on return: 0 -- Solution completed. 1 -- M  <=  0 or N  <=  0 2 -- B(:), X(:), BND(:,:), W(:), or INDEX(:) size or shape violation. 3 -- Input bounds are inconsistent. 4 -- Exceed maximum number of iterations. integer, intent(in) :: max_iter maximum number of iterations (if <=0, then 3*n is used) Called by proc~~bvls~~CalledByGraph proc~bvls bvls proc~bvls_wrapper bvls_wrapper proc~bvls_wrapper->proc~bvls proc~ldp ldp proc~ldp->proc~bvls_wrapper proc~lsi lsi proc~lsi->proc~ldp proc~lsei lsei proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bvls ( a , b , bnd , x , rnorm , nsetp , w , index , ierr , max_iter ) implicit none real ( wp ), dimension (:,:), intent ( inout ) :: a !! On entry A() contains the M by N matrix, A. !! On return A() contains the product matrix, Q*A, where !! Q is an M by M orthogonal matrix generated by this !! subroutine.  The dimensions are M=size(A,1) and N=size(A,2). real ( wp ), dimension (:), intent ( inout ) :: b !! On entry B() contains the M-vector, B. !! On return, B() contains Q*B.  The same Q multiplies A. real ( wp ), dimension (:,:), intent ( in ) :: bnd !! BND(1,J) is the lower bound for X(J). !! BND(2,J) is the upper bound for X(J). !! !! Require:  BND(1,J)  <=  BND(2,J). !! !! The values BND(1,J) = -huge(ONE) and BND(2,J) = huge(ONE) are !! suggested choices to designate that there is no constraint in that !! direction.  The parameter ONE is 1.0 in the working precision. real ( wp ), dimension (:), intent ( out ) :: x !! On entry X() need not be initialized.  On return, !! X() will contain the solution N-vector. real ( wp ), intent ( out ) :: rnorm !! Euclidean norm of the residual vector, b - A*X. integer , intent ( out ) :: nsetp !! Indicates the number of components of the solution !! vector, X(), that are not at their constraint values. real ( wp ), dimension (:), intent ( out ) :: w !! An N-array.  On return, W() will contain the dual solution !! vector.   Using Set definitions below: !! !! * W(J) = 0 for all j in Set P, !! * W(J)  <=  0 for all j in Set Z, such that X(J) is at its !!   lower bound, and !! * W(J)  >=  0 for all j in Set Z, such that X(J) is at its !!   upper bound. !! !! If BND(1,J) = BND(2,J), so the variable X(J) is fixed, !! then W(J) will have an arbitrary value. integer , dimension (:), intent ( out ) :: index !! An INTEGER working array of size N.  On exit the contents !! of this array define the sets P, Z, and F as follows: !! !! * INDEX(1)   through INDEX(NSETP)    =  Set P. !! * INDEX(IZ1) through INDEX(IZ2)      = Set Z. !! * INDEX(IZ2+1) through INDEX(N)      = Set F. !! !! IZ1 = NSETP + 1 = NPP1 !! !! Any of these sets may be empty.  Set F is those components !! that are constrained to a unique value by the given !! constraints.   Sets P and Z are those that are allowed a non- !! zero range of values.  Of these, set Z are those whose final !! value is a constraint value, while set P are those whose !! final value is not a constraint.  The value of IZ2 is not returned. !! !! It is computable as the number of bounds constraining a component !! of X uniquely. integer , intent ( out ) :: ierr !! Indicates status on return: !! !! * 0 -- Solution completed. !! * 1 -- M  <=  0 or N  <=  0 !! * 2 -- B(:), X(:), BND(:,:), W(:), or INDEX(:) size or shape violation. !! * 3 -- Input bounds are inconsistent. !! * 4 -- Exceed maximum number of iterations. integer , intent ( in ) :: max_iter !! maximum number of iterations (if <=0, then `3*n` is used) logical :: find , hitbnd , free1 , free2 , free integer :: iter !! Iteration counter. integer :: itmax !! Maximum number of iterations permitted. !! Defaults to 3*n if `max_iter<=0`. !! This is usually larger than required. integer :: m , n , i , ibound , ii , ip , iz , iz1 , iz2 , & j , jj , jz , l , lbound , npp1 real ( wp ), dimension ( size ( a , 2 )) :: s real ( wp ), dimension ( size ( a , 1 )) :: z real ( wp ) :: alpha , asave , cc , range , & norm , sm , ss , t , unorm , up , ztest real ( wp ), parameter :: eps = epsilon ( one ) !! Determines the relative linear dependence of a column vector !! for a variable moved from its initial value.  This is used in !! one place with the default value EPS=EPSILON(ONE).  Other !! values, larger or smaller may be needed for some problems. !! Library software will likely make this an optional argument. call initialize () ! The above call will set IERR. loopa : do ! Quit on error flag, or if all coefficients are already in the ! solution, .or. if M columns of A have been triangularized. if ( ierr /= 0 . or . iz1 > iz2 . or . nsetp >= m ) exit loopa call select_another_coeff_to_solve_for () ! See if no index was found to be moved from set Z to set P. ! Then go to termination. if ( . not . find ) exit loopa call move_j_from_set_z_to_set_p () call test_set_p_against_constraints () ! The above call may set IERR. ! All coefficients in set P are strictly feasible.  Loop back. end do loopa call termination () contains ! These are internal subroutines. subroutine initialize () m = size ( a , 1 ) n = size ( a , 2 ) if ( m <= 0 . or . n <= 0 ) then ierr = 1 return end if ! Check array sizes for consistency and with M and N. if ( size ( x ) < n ) then ierr = 2 return end if if ( size ( b ) < m ) then ierr = 2 return end if if ( size ( bnd , 1 ) /= 2 ) then ierr = 2 return end if if ( size ( bnd , 2 ) < n ) then ierr = 2 return end if if ( size ( w ) < n ) then ierr = 2 return end if if ( size ( index ) < n ) then ierr = 2 return end if ierr = 0 if ( max_iter <= 0 ) then itmax = 3 * n else itmax = max_iter end if iter = 0 ! Initialize the array index(). do i = 1 , n index ( i ) = i end do iz2 = n iz1 = 1 nsetp = 0 npp1 = 1 ! Begin:  Loop on IZ to initialize  X(). iz = iz1 do if ( iz > iz2 ) exit j = index ( iz ) if ( bnd ( 1 , j ) <= - huge ( one )) then if ( bnd ( 2 , j ) >= huge ( one )) then x ( j ) = zero else x ( j ) = min ( zero , bnd ( 2 , j )) end if else  if ( bnd ( 2 , j ) >= huge ( one )) then x ( j ) = max ( zero , bnd ( 1 , j )) else range = bnd ( 2 , j ) - bnd ( 1 , j ) if ( range <= zero ) then ! Here X(J) is constrained to a single value. index ( iz ) = index ( iz2 ) index ( iz2 ) = j iz = iz - 1 iz2 = iz2 - 1 x ( j ) = bnd ( 1 , j ) w ( j ) = zero else  if ( range > zero ) then !! The following statement sets X(J) to 0 if the constraint interval !! includes 0, and otherwise sets X(J) to the endpoint of the !! constraint interval that is closest to 0. x ( j ) = max ( bnd ( 1 , j ), min ( bnd ( 2 , j ), zero )) else ierr = 3 return end if end if if ( abs ( x ( j )) > zero ) then ! Change B() to reflect a nonzero starting value for X(J). b ( 1 : m ) = b ( 1 : m ) - a ( 1 : m , j ) * x ( j ) end if iz = iz + 1 end do end subroutine initialize subroutine select_another_coeff_to_solve_for () !! 1. Search through set z for a new coefficient to solve for. !!    First select a candidate that is either an unconstrained !!    coefficient or else a constrained coefficient that has room !!    to move in the direction consistent with the sign of its dual !!    vector component.  Components of the dual (negative gradient) !!    vector will be computed as needed. !! 2. For each candidate start the transformation to bring this !!    candidate into the triangle, and then do two tests:  Test size !!    of new diagonal value to avoid extreme ill-conditioning, and !!    the value of this new coefficient to be sure it moved in the !!    expected direction. !! 3. If some coefficient passes all these conditions, set FIND = true, !!    The index of the selected coefficient is J = INDEX(IZ). !! 4. If no coefficient is selected, set FIND = false. find = . false . do iz = iz1 , iz2 j = index ( iz ) ! Set FREE1 = true if X(J) is not at the left end-point of its ! constraint region. ! Set FREE2 = true if X(J) is not at the right end-point of its ! constraint region. ! Set FREE = true if X(J) is not at either end-point of its ! constraint region. free1 = x ( j ) > bnd ( 1 , j ) free2 = x ( j ) < bnd ( 2 , j ) free = free1 . and . free2 if ( free ) then call test_coef_j_for_diag_elt_and_direction_of_change () else ! Compute dual coefficient W(J). w ( j ) = dot_product ( a ( npp1 : m , j ), b ( npp1 : m )) ! Can X(J) move in the direction indicated by the sign of W(J)? if ( w ( j ) < zero ) then if ( free1 ) call test_coef_j_for_diag_elt_and_direction_of_change () else  if ( w ( j ) > zero ) then if ( free2 ) call test_coef_j_for_diag_elt_and_direction_of_change () end if end if if ( find ) return end do end subroutine select_another_coeff_to_solve_for subroutine test_coef_j_for_diag_elt_and_direction_of_change () !! The sign of W(J) is OK for J to be moved to set P. !! Begin the transformation and check new diagonal element to avoid !! near linear dependence. asave = a ( npp1 , j ) call htc ( npp1 , a ( 1 : m , j ), up ) unorm = nrm2 ( a ( 1 : nsetp , j )) if ( abs ( a ( npp1 , j )) > eps * unorm ) then ! Column J is sufficiently independent.  Copy b into Z, update Z. z ( 1 : m ) = b ( 1 : m ) ! Compute product of transormation and updated right-hand side. norm = a ( npp1 , j ) a ( npp1 , j ) = up if ( abs ( norm ) > zero ) then sm = dot_product ( a ( npp1 : m , j ) / norm , z ( npp1 : m )) / up z ( npp1 : m ) = z ( npp1 : m ) + sm * a ( npp1 : m , j ) a ( npp1 , j ) = norm end if if ( abs ( x ( j )) > zero ) z ( 1 : npp1 ) = z ( 1 : npp1 ) + a ( 1 : npp1 , j ) * x ( j ) ! Adjust Z() as though X(J) had been reset to zero. if ( free ) then find = . true . else !! Solve for ZTEST ( proposed new value for X(J) ). !! Then set FIND to indicate if ZTEST has moved away from X(J) in !! the expected direction indicated by the sign of W(J). ztest = z ( npp1 ) / a ( npp1 , j ) find = ( w ( j ) < zero . and . ztest < x ( j ) ) . or . & ( w ( j ) > zero . and . ztest > x ( j ) ) end if end if ! If J was not accepted to be moved from set Z to set P, ! restore A(NNP1,J).  Failing these tests may mean the computed ! sign of W(J) is suspect, so here we set W(J) = 0.  This will ! not affect subsequent computation, but cleans up the W() array. if ( . not . find ) then a ( npp1 , j ) = asave w ( j ) = zero end if end subroutine test_coef_j_for_diag_elt_and_direction_of_change subroutine move_j_from_set_z_to_set_p () !! The index  J=index(IZ)  has been selected to be moved from !! set Z to set P.  Z() contains the old B() adjusted as though X(J) = 0. !! A(*,J) contains the new Householder transformation vector. b ( 1 : m ) = z ( 1 : m ) index ( iz ) = index ( iz1 ) index ( iz1 ) = j iz1 = iz1 + 1 nsetp = npp1 npp1 = npp1 + 1 ! The following loop can be null or not required. norm = a ( nsetp , j ) a ( nsetp , j ) = up if ( abs ( norm ) > zero ) then do jz = iz1 , iz2 jj = index ( jz ) sm = dot_product ( a ( nsetp : m , j ) / norm , a ( nsetp : m , jj )) / up a ( nsetp : m , jj ) = a ( nsetp : m , jj ) + sm * a ( nsetp : m , j ) end do a ( nsetp , j ) = norm end if ! The following loop can be null. do l = npp1 , m a ( l , j ) = zero end do !  L w ( j ) = zero ! Solve the triangular system.  Store this solution temporarily in Z(). do i = nsetp , 1 , - 1 if ( i /= nsetp ) z ( 1 : i ) = z ( 1 : i ) - a ( 1 : i , ii ) * z ( i + 1 ) ii = index ( i ) z ( i ) = z ( i ) / a ( i , ii ) end do end subroutine move_j_from_set_z_to_set_p subroutine test_set_p_against_constraints () loopb : do ! The solution obtained by solving the current set P is in the array Z(). iter = iter + 1 if ( iter > itmax ) then ierr = 4 exit loopb end if call see_if_all_constrained_coeffs_are_feasible () ! The above call sets HITBND.  If HITBND = true then it also sets ! ALPHA, JJ, and IBOUND. if ( . not . hitbnd ) exit loopb ! Here ALPHA will be between 0 and 1 for interpolation ! between the old X() and the new Z(). do ip = 1 , nsetp l = index ( ip ) x ( l ) = x ( l ) + alpha * ( z ( ip ) - x ( l )) end do i = index ( jj ) ! Note:  The exit test is done at the end of the loop, so the loop ! will always be executed at least once. do ! Modify A(*,*), B(*) and the index arrays to move coefficient I ! from set P to set Z. call move_coef_i_from_set_p_to_set_z if ( nsetp <= 0 ) exit loopb ! See if the remaining coefficients in set P are feasible.  They should ! be because of the way ALPHA was determined.  If any are infeasible ! it is due to round-off error.  Any that are infeasible or on a boundary ! will be set to the boundary value and moved from set P to set Z. ibound = 0 do jj = 1 , nsetp i = index ( jj ) if ( x ( i ) <= bnd ( 1 , i )) then ibound = 1 exit else if ( x ( i ) >= bnd ( 2 , i )) then ibound = 2 exit end if end do if ( ibound <= 0 ) exit end do ! Copy B( ) into Z( ).  Then solve again and loop back. z ( 1 : m ) = b ( 1 : m ) do i = nsetp , 1 , - 1 if ( i /= nsetp ) z ( 1 : i ) = z ( 1 : i ) - a ( 1 : i , ii ) * z ( i + 1 ) ii = index ( i ) z ( i ) = z ( i ) / a ( i , ii ) end do end do loopb ! The following loop can be null. do ip = 1 , nsetp i = index ( ip ) x ( i ) = z ( ip ) end do end subroutine test_set_p_against_constraints subroutine see_if_all_constrained_coeffs_are_feasible () !! See if each coefficient in set P is strictly interior to its constraint region. !! If so, set HITBND = false. !! If not, set HITBND = true, and also set ALPHA, JJ, and IBOUND. !! Then ALPHA will satisfy  0.  < ALPHA  <=  1. alpha = two do ip = 1 , nsetp l = index ( ip ) if ( z ( ip ) <= bnd ( 1 , l )) then ! Z(IP) HITS LOWER BOUND lbound = 1 else  if ( z ( ip ) >= bnd ( 2 , l )) then ! Z(IP) HITS UPPER BOUND lbound = 2 else lbound = 0 end if if ( lbound /= 0 ) then t = ( bnd ( lbound , l ) - x ( l )) / ( z ( ip ) - x ( l )) if ( alpha > t ) then alpha = t jj = ip ibound = lbound end if end if end do hitbnd = abs ( alpha - two ) > zero end subroutine see_if_all_constrained_coeffs_are_feasible subroutine move_coef_i_from_set_p_to_set_z () x ( i ) = bnd ( ibound , i ) if ( abs ( x ( i )) > zero . and . jj > 0 ) b ( 1 : jj ) = b ( 1 : jj ) - a ( 1 : jj , i ) * x ( i ) ! The following loop can be null. do j = jj + 1 , nsetp ii = index ( j ) index ( j - 1 ) = ii call rotg ( a ( j - 1 , ii ), a ( j , ii ), cc , ss ) sm = a ( j - 1 , ii ) ! The plane rotation is applied to two rows of A and the right-hand ! side.  One row is moved to the scratch array S and then the updates ! are computed.  The intent is for array operations to be performed ! and minimal extra data movement.  One extra rotation is applied ! to column II in this approach. s = a ( j - 1 , 1 : n ) a ( j - 1 , 1 : n ) = cc * s + ss * a ( j , 1 : n ) a ( j , 1 : n ) = cc * a ( j , 1 : n ) - ss * s a ( j - 1 , ii ) = sm a ( j , ii ) = zero sm = b ( j - 1 ) b ( j - 1 ) = cc * sm + ss * b ( j ) b ( j ) = cc * b ( j ) - ss * sm end do npp1 = nsetp nsetp = nsetp - 1 iz1 = iz1 - 1 index ( iz1 ) = i end subroutine move_coef_i_from_set_p_to_set_z subroutine termination () if ( ierr <= 0 ) then ! Compute the norm of the residual vector. sm = zero if ( npp1 <= m ) then sm = nrm2 ( b ( npp1 : m )) else w ( 1 : n ) = zero end if rnorm = sm end if end subroutine termination pure subroutine rotg ( sa , sb , c , s ) real ( wp ), intent ( inout ) :: sa real ( wp ), intent ( in ) :: sb real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s real ( wp ) :: roe , scale , r roe = sb if ( abs ( sa ) > abs ( sb ) ) roe = sa scale = abs ( sa ) + abs ( sb ) if ( scale <= zero ) then c = one s = zero else r = scale * sqrt (( sa / scale ) ** 2 + ( sb / scale ) ** 2 ) if ( roe < zero ) r =- r c = sa / r s = sb / r sa = r end if end subroutine rotg pure function nrm2 ( x ) result ( norm ) !!  NRM2 returns the Euclidean norm of a vector via the function !!  name, so that !! !!  `NRM2 := sqrt( x'*x )` !! !!### See also !!  * [[dnrm2]] real ( wp ), dimension (:), intent ( in ) :: x real ( wp ) :: norm real ( wp ) :: absxi , scale , ssq integer :: n , ix n = size ( x ) if ( n < 1 ) then norm = zero else if ( n == 1 ) then norm = abs ( x ( 1 ) ) else scale = zero ssq = one do ix = 1 , n absxi = abs ( x ( ix ) ) if ( absxi > zero ) then if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if end function nrm2 pure subroutine htc ( p , u , up ) !! Construct a Householder transformation. integer , intent ( in ) :: p real ( wp ), dimension (:), intent ( inout ) :: u real ( wp ), intent ( out ) :: up real ( wp ) :: vnorm vnorm = nrm2 ( u ( p : size ( u ))) if ( u ( p ) > zero ) vnorm =- vnorm up = u ( p ) - vnorm u ( p ) = vnorm end subroutine htc end subroutine bvls","tags":"","url":"proc/bvls.html"},{"title":"ddot – slsqp","text":"public pure function ddot(n, dx, incx, dy, incy) forms the dot product of two vectors.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: dx integer, intent(in) :: incx real(kind=wp), intent(in), dimension(*) :: dy integer, intent(in) :: incy Return Value real(kind=wp) Called by proc~~ddot~~CalledByGraph proc~ddot ddot proc~ldp ldp proc~ldp->proc~ddot proc~lsei lsei proc~lsei->proc~ddot proc~lsi lsi proc~lsei->proc~lsi proc~lsi->proc~ddot proc~lsi->proc~ldp proc~lsq lsq proc~lsq->proc~ddot proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~ddot proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure real ( wp ) function ddot ( n , dx , incx , dy , incy ) import :: wp implicit none integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( in ) :: dy integer , intent ( in ) :: incy end function ddot","tags":"","url":"proc/ddot.html"},{"title":"dnrm2 – slsqp","text":"public pure function dnrm2(n, x, incx) result(norm) Function that returns the Euclidean norm of a vector . Further details this version written on 25-october-1982. modified on 14-october-1993 to inline the call to dlassq.\n    sven hammarling, nag ltd. Converted to modern Fortran, Jacob Williams, Jan. 2016. Note Replaced original SLSQP routine with this one from BLAS . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: x integer, intent(in) :: incx Return Value real(kind=wp) Called by proc~~dnrm2~~CalledByGraph proc~dnrm2 dnrm2 proc~check_convergence check_convergence proc~check_convergence->proc~dnrm2 proc~ldp ldp proc~ldp->proc~dnrm2 proc~lsei lsei proc~lsei->proc~dnrm2 proc~lsi lsi proc~lsei->proc~lsi proc~lsi->proc~dnrm2 proc~lsi->proc~ldp proc~lsq lsq proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~check_convergence proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function dnrm2 ( n , x , incx ) result ( norm ) import :: wp implicit none integer , intent ( in ) :: incx integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ) :: norm end function dnrm2","tags":"","url":"proc/dnrm2.html"},{"title":"daxpy – slsqp","text":"public pure subroutine daxpy(n, da, dx, incx, dy, incy) constant times a vector plus a vector.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: da real(kind=wp), intent(in), dimension(*) :: dx integer, intent(in) :: incx real(kind=wp), intent(inout), dimension(*) :: dy integer, intent(in) :: incy Called by proc~~daxpy~~CalledByGraph proc~daxpy daxpy proc~ldp ldp proc~ldp->proc~daxpy proc~lsi lsi proc~lsi->proc~daxpy proc~lsi->proc~ldp proc~slsqpb slsqpb proc~slsqpb->proc~daxpy proc~lsq lsq proc~slsqpb->proc~lsq proc~lsei lsei proc~lsei->proc~lsi proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~lsq->proc~lsei proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine daxpy ( n , da , dx , incx , dy , incy ) import :: wp implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: da real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( inout ) :: dy integer , intent ( in ) :: incy end subroutine daxpy","tags":"","url":"proc/daxpy.html"},{"title":"dcopy – slsqp","text":"public pure subroutine dcopy(n, dx, incx, dy, incy) copies a vector, x, to a vector, y.\n  uses unrolled loops for increments equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: dx integer, intent(in) :: incx real(kind=wp), intent(out), dimension(*) :: dy integer, intent(in) :: incy Called by proc~~dcopy~~CalledByGraph proc~dcopy dcopy proc~ldp ldp proc~ldp->proc~dcopy proc~lsei lsei proc~lsei->proc~dcopy proc~lsi lsi proc~lsei->proc~lsi proc~lsq lsq proc~lsq->proc~dcopy proc~lsq->proc~lsei proc~slsqpb slsqpb proc~slsqpb->proc~dcopy proc~slsqpb->proc~lsq proc~lsi->proc~ldp proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine dcopy ( n , dx , incx , dy , incy ) import :: wp implicit none integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( out ) :: dy integer , intent ( in ) :: incy end subroutine dcopy","tags":"","url":"proc/dcopy.html"},{"title":"dscal – slsqp","text":"public pure subroutine dscal(n, da, dx, incx) scales a vector by a constant.\n  uses unrolled loops for increment equal to one. Author jack dongarra, linpack, 3/11/78. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: da real(kind=wp), intent(inout), dimension(*) :: dx integer, intent(in) :: incx Called by proc~~dscal~~CalledByGraph proc~dscal dscal proc~lsq lsq proc~lsq->proc~dscal proc~slsqpb slsqpb proc~slsqpb->proc~dscal proc~slsqpb->proc~lsq proc~slsqp slsqp proc~slsqp->proc~slsqpb proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine dscal ( n , da , dx , incx ) import :: wp implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: da real ( wp ), dimension ( * ), intent ( inout ) :: dx integer , intent ( in ) :: incx end subroutine dscal","tags":"","url":"proc/dscal.html"},{"title":"mode_to_status_message – slsqp","text":"private pure function mode_to_status_message(imode) result(message) Convert the slsqp mode flag to a message string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imode Return Value character(len=:), allocatable Called by proc~~mode_to_status_message~~CalledByGraph proc~mode_to_status_message mode_to_status_message proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~mode_to_status_message Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function mode_to_status_message ( imode ) result ( message ) implicit none integer , intent ( in ) :: imode character ( len = :), allocatable :: message select case ( imode ) case ( 0 ) !required accuracy for solution obtained message = 'Required accuracy for solution obtained' case ( - 100 ) message = 'Invalid size(x) in slsqp_wrapper' case ( - 101 ) message = 'Invalid linesearch_mode in slsqp_wrapper' case ( - 102 ) message = 'Function is not associated' case ( - 103 ) message = 'Gradient function is not associated' case ( - 104 ) message = 'Invalid gradient mode' case ( - 105 ) message = 'Invalid perturbation step size for finite difference gradients' case ( - 2 ) message = 'User-triggered stop of slsqp' case ( 1 , - 1 ) message = 'In progress' case ( 2 ) message = 'Number of equality constraints larger than n' case ( 3 ) message = 'More than 3*n iterations in lsq subproblem' case ( 4 ) message = 'Inequality constraints incompatible' case ( 5 ) message = 'Singular matrix e in lsq subproblem' case ( 6 ) message = 'Singular matrix c in lsq subproblem' case ( 7 ) message = 'Rank-deficient equality constraint subproblem hfti' case ( 8 ) message = 'Positive directional derivative for linesearch' case ( 9 ) message = 'More than max_iter iterations in slsqp' case default message = 'Unknown slsqp error' end select end function mode_to_status_message","tags":"","url":"proc/mode_to_status_message.html"},{"title":"stop_iterations – slsqp","text":"private  subroutine stop_iterations(me) A method that the user can call to stop the iterations.\n(it can be called in any of the functions).\nSLSQP will stop at the end of the next iteration. Type Bound slsqp_solver Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me Source Code subroutine stop_iterations ( me ) implicit none class ( slsqp_solver ), intent ( inout ) :: me me % user_triggered_stop = . true . end subroutine stop_iterations","tags":"","url":"proc/stop_iterations.html"},{"title":"initialize_slsqp – slsqp","text":"private  subroutine initialize_slsqp(me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax, gradient_mode, gradient_delta, tolf, toldf, toldx, max_iter_ls, nnls_mode, infinite_bound, report_msg) initialize the slsqp_solver class.  see slsqp for more details. Type Bound slsqp_solver Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of variables, integer, intent(in) :: m total number of constraints, integer, intent(in) :: meq number of equality constraints, integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients (must be\nassociated if gradient_mode=0 ) real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x . xl(i)=NaN (or xl(i)<=-infinite_bound ) indicates to ignore i th bound real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x . xu(i)=NaN (or xu(i)>=infinite_bound ) indicates to ignore i th bound logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default= output_unit ) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] integer, intent(in), optional :: gradient_mode how the gradients are to be computed: 0 - use the user-supplied g subroutine. [default] 1 - approximate by basic backward differences 2 - approximate by basic forward differences 3 - approximate by basic central differences Note that modes 1-3 do not respect the variable bounds. real(kind=wp), intent(in), optional :: gradient_delta perturbation step size (>epsilon) to compute the approximated\ngradient by finite differences ( gradient_mode 1-3).\nnote that this is an absolute step that does not respect\nthe xl or xu variable bounds. real(kind=wp), intent(in), optional :: tolf stopping criterion if then stop. real(kind=wp), intent(in), optional :: toldf stopping criterion if then stop real(kind=wp), intent(in), optional :: toldx stopping criterion if then stop integer, intent(in), optional :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in), optional :: nnls_mode Which NNLS method to use: Use the original nnls Use the newer bvls real(kind=wp), intent(in), optional :: infinite_bound \"infinity\" for the upper and lower bounds.\nif xl<=-infinite_bound or xu>=infinite_bound then these bounds are considered nonexistant.\nIf not present then huge() is used for this. procedure( msgfunc ), optional :: report_msg user-defined procedure that will be called\nwith any warning or error messages. Calls proc~~initialize_slsqp~~CallsGraph proc~initialize_slsqp slsqp_solver%initialize_slsqp proc~destroy_slsqp slsqp_solver%destroy_slsqp proc~initialize_slsqp->proc~destroy_slsqp proc~report_message slsqp_solver%report_message proc~initialize_slsqp->proc~report_message Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_slsqp ( me , n , m , meq , max_iter , acc , f , g , xl , xu , status_ok ,& linesearch_mode , iprint , report , alphamin , alphamax ,& gradient_mode , gradient_delta , tolf , toldf , toldx ,& max_iter_ls , nnls_mode , infinite_bound , report_msg ) implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: n !! the number of variables,  n \\ge 1  integer , intent ( in ) :: m !! total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: max_iter !! maximum number of iterations procedure ( func ) :: f !! problem function procedure ( grad ) :: g !! function to compute gradients (must be !! associated if `gradient_mode=0`) real ( wp ), dimension ( n ), intent ( in ) :: xl !! lower bounds on `x`. !! `xl(i)=NaN` (or `xl(i)<=-infinite_bound`) indicates to ignore `i`th bound real ( wp ), dimension ( n ), intent ( in ) :: xu !! upper bounds on `x`. !! `xu(i)=NaN` (or `xu(i)>=infinite_bound`) indicates to ignore `i`th bound real ( wp ), intent ( in ) :: acc !! accuracy logical , intent ( out ) :: status_ok !! will be false if there were errors integer , intent ( in ), optional :: linesearch_mode !! 1 = inexact (default), 2 = exact integer , intent ( in ), optional :: iprint !! unit number of status messages (default=`output_unit`) procedure ( iterfunc ), optional :: report !! user-defined procedure that will be called once per iteration real ( wp ), intent ( in ), optional :: alphamin !! minimum alpha for linesearch [default 0.1] real ( wp ), intent ( in ), optional :: alphamax !! maximum alpha for linesearch [default 1.0] integer , intent ( in ), optional :: gradient_mode !! how the gradients are to be computed: !! !! * 0 - use the user-supplied `g` subroutine. [default] !! * 1 - approximate by basic backward differences !! * 2 - approximate by basic forward differences !! * 3 - approximate by basic central differences !! !! Note that modes 1-3 do not respect the variable bounds. real ( wp ), intent ( in ), optional :: gradient_delta !! perturbation step size (>epsilon) to compute the approximated !! gradient by finite differences (`gradient_mode` 1-3). !! note that this is an absolute step that does not respect !! the `xl` or `xu` variable bounds. real ( wp ), intent ( in ), optional :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ), optional :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop real ( wp ), intent ( in ), optional :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop integer , intent ( in ), optional :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ), optional :: nnls_mode !! Which NNLS method to use: !! !! 1. Use the original [[nnls]] !! 2. Use the newer [[bvls]] real ( wp ), intent ( in ), optional :: infinite_bound !! \"infinity\" for the upper and lower bounds. !! if `xl<=-infinite_bound` or `xu>=infinite_bound` !! then these bounds are considered nonexistant. !! If not present then `huge()` is used for this. procedure ( msgfunc ), optional :: report_msg !! user-defined procedure that will be called !! with any warning or error messages. integer :: n1 , mineq , i status_ok = . false . call me % destroy () if ( present ( iprint )) me % iprint = iprint if ( present ( report_msg )) me % report_msg => report_msg if ( size ( xl ) /= size ( xu ) . or . size ( xl ) /= n ) then call me % report_message ( 'error: invalid upper or lower bound vector size' ) call me % report_message ( '  size(xl) =' , ival = size ( xl )) call me % report_message ( '  size(xu) =' , ival = size ( xu )) call me % report_message ( '  n        =' , ival = n ) else if ( meq < 0 . or . meq > m ) then call me % report_message ( 'error: invalid meq value:' , ival = meq ) else if ( m < 0 ) then call me % report_message ( 'error: invalid m value:' , ival = m ) else if ( n < 1 ) then call me % report_message ( 'error: invalid n value:' , ival = n ) else if ( any ( xl > xu . and . . not . ieee_is_nan ( xl ) . and . . not . ieee_is_nan ( xu ))) then call me % report_message ( 'error: lower bounds must be <= upper bounds.' ) do i = 1 , n if ( xl ( i ) > xu ( i ) . and . . not . ieee_is_nan ( xl ( i )) . and . . not . ieee_is_nan ( xu ( i ))) then call me % report_message ( '  xl(i)>xu(i) for variable' , ival = i ) end if end do else if ( present ( linesearch_mode )) then !two linesearch modes: select case ( linesearch_mode ) case ( 1 ) !inexact me % linesearch_mode = linesearch_mode case ( 2 ) !exact me % linesearch_mode = linesearch_mode case default call me % report_message ( 'error: invalid linesearch_mode (must be 1 or 2): ' ,& ival = linesearch_mode ) call me % destroy () return end select end if !optional linesearch bounds: if ( present ( alphamin )) me % alphamin = alphamin if ( present ( alphamax )) me % alphamax = alphamax !verify valid values for alphamin and alphamax: 0<alphamin<alphamax<=1 if ( me % alphamin <= zero . or . me % alphamax <= zero . or . & me % alphamax <= me % alphamin . or . & me % alphamin >= one . or . me % alphamax > one ) then call me % report_message ( 'error: invalid values for alphamin or alphamax.' ) call me % report_message ( '  alphamin =' , rval = me % alphamin ) call me % report_message ( '  alphamax =' , rval = me % alphamax ) call me % destroy () return end if if ( present ( tolf )) me % tolf = tolf if ( present ( toldf )) me % toldf = toldf if ( present ( toldx )) me % toldx = toldx if ( present ( max_iter_ls )) me % max_iter_ls = max_iter_ls if ( present ( nnls_mode )) then select case ( nnls_mode ) case ( 1 : 2 ) me % nnls_mode = nnls_mode case default call me % report_message ( 'error: invalid value for nnls_mode. defaulting to 1.' ) me % nnls_mode = 1 end select end if status_ok = . true . me % n = n me % m = m me % meq = meq me % max_iter = max_iter me % acc = acc me % f => f me % g => g if ( present ( report )) me % report => report allocate ( me % xl ( n )); me % xl = xl allocate ( me % xu ( n )); me % xu = xu !work arrays: n1 = n + 1 mineq = m - meq + 2 * n1 me % l_w = n1 * ( n1 + 1 ) + meq * ( n1 + 1 ) + mineq * ( n1 + 1 ) + & !for lsq ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + & !for lsi ( n1 + mineq ) * ( n1 - meq ) + 2 * meq + n1 + & !for lsei n1 * n / 2 + 2 * m + 3 * n + 3 * n1 + 1 !for slsqpb allocate ( me % w ( me % l_w )) me % w = zero if ( present ( gradient_mode )) then me % gradient_mode = gradient_mode if ( present ( gradient_delta )) then me % gradient_delta = gradient_delta end if end if if ( present ( infinite_bound )) then me % infinite_bound = abs ( infinite_bound ) else me % infinite_bound = huge ( one ) end if end if end subroutine initialize_slsqp","tags":"","url":"proc/initialize_slsqp.html"},{"title":"destroy_slsqp – slsqp","text":"private  subroutine destroy_slsqp(me) destructor for slsqp_solver . Type Bound slsqp_solver Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me Called by proc~~destroy_slsqp~~CalledByGraph proc~destroy_slsqp slsqp_solver%destroy_slsqp proc~initialize_slsqp slsqp_solver%initialize_slsqp proc~initialize_slsqp->proc~destroy_slsqp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_slsqp ( me ) implicit none class ( slsqp_solver ), intent ( out ) :: me end subroutine destroy_slsqp","tags":"","url":"proc/destroy_slsqp.html"},{"title":"slsqp_wrapper – slsqp","text":"private  subroutine slsqp_wrapper(me, x, istat, iterations, status_message) main routine for calling slsqp . Type Bound slsqp_solver Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional, allocatable :: status_message string status message\ncorresponding to istat Calls proc~~slsqp_wrapper~~CallsGraph proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~destroy_linmin_data linmin_data%destroy_linmin_data proc~slsqp_wrapper->proc~destroy_linmin_data proc~mode_to_status_message mode_to_status_message proc~slsqp_wrapper->proc~mode_to_status_message proc~report_message slsqp_solver%report_message proc~slsqp_wrapper->proc~report_message proc~slsqp slsqp proc~slsqp_wrapper->proc~slsqp proc~slsqpb slsqpb proc~slsqp->proc~slsqpb proc~check_convergence check_convergence proc~slsqpb->proc~check_convergence proc~daxpy daxpy proc~slsqpb->proc~daxpy proc~dcopy dcopy proc~slsqpb->proc~dcopy proc~ddot ddot proc~slsqpb->proc~ddot proc~dscal dscal proc~slsqpb->proc~dscal proc~enforce_bounds enforce_bounds proc~slsqpb->proc~enforce_bounds proc~ldl ldl proc~slsqpb->proc~ldl proc~linmin linmin proc~slsqpb->proc~linmin proc~lsq lsq proc~slsqpb->proc~lsq proc~dnrm2 dnrm2 proc~check_convergence->proc~dnrm2 proc~lsq->proc~dcopy proc~lsq->proc~ddot proc~lsq->proc~dscal proc~lsq->proc~enforce_bounds proc~lsei lsei proc~lsq->proc~lsei proc~lsei->proc~dcopy proc~lsei->proc~ddot proc~lsei->proc~dnrm2 proc~h12 h12 proc~lsei->proc~h12 proc~hfti hfti proc~lsei->proc~hfti proc~lsi lsi proc~lsei->proc~lsi proc~hfti->proc~h12 proc~lsi->proc~daxpy proc~lsi->proc~ddot proc~lsi->proc~dnrm2 proc~lsi->proc~h12 proc~ldp ldp proc~lsi->proc~ldp proc~ldp->proc~daxpy proc~ldp->proc~dcopy proc~ldp->proc~ddot proc~ldp->proc~dnrm2 proc~bvls_wrapper bvls_wrapper proc~ldp->proc~bvls_wrapper proc~nnls nnls proc~ldp->proc~nnls proc~bvls bvls proc~bvls_wrapper->proc~bvls proc~nnls->proc~h12 proc~g1 g1 proc~nnls->proc~g1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine slsqp_wrapper ( me , x , istat , iterations , status_message ) implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x !! **in:**  initial optimization variables, !! **out:** solution. integer , intent ( out ) :: istat !! status code (see `mode` in [[slsqp]]). integer , intent ( out ), optional :: iterations !! number of iterations character ( len = :), intent ( out ), allocatable , optional :: status_message !! string status message !! corresponding to `istat` ! local variables: real ( wp ), dimension (:), allocatable :: c !! constraint vector -- `dimension(max(1,me%m))` real ( wp ), dimension (:,:), allocatable :: a !! a matrix for [[slsqp]] -- `dimension(max(1,me%m),me%n+1)` real ( wp ), dimension (:), allocatable :: g !! g matrix for [[slsqp]] -- `dimension(me%n+1)` real ( wp ), dimension (:), allocatable :: cvec !! constraint vector -- `dimension(me%m)` real ( wp ), dimension (:), allocatable :: dfdx !! objective function partials -- `dimension(me%n)` real ( wp ), dimension (:,:), allocatable :: dcdx !! constraint partials -- `dimension(me%m,me%n)` real ( wp ), dimension (:), allocatable :: delta !! perturbation step size to approximate gradient -- `dimension(me%n)` real ( wp ), dimension (:), allocatable :: cvecr !! right function value to approximate constraints vector's gradient -- `dimension(me%m)` real ( wp ), dimension (:), allocatable :: cvecl !! left function value to approximate constraints vector's gradient -- `dimension(me%m)` real ( wp ) :: f !! objective function integer :: i !! iteration counter integer :: mode !! reverse communication flag for [[slsqp]] integer :: la !! input to [[slsqp]] integer :: iter !! in/out for [[slsqp]] real ( wp ) :: acc !! in/out for [[slsqp]] integer :: ig !! loop index to approximate gradient real ( wp ) :: fr !! right function value to approximate objective function's gradient real ( wp ) :: fl !! left function value to approximate objective function's gradient real ( wp ) :: fact !! denominator factor for finite difference approximation !initialize: allocate ( c ( max ( 1 , me % m )) ) allocate ( a ( max ( 1 , me % m ), me % n + 1 )) allocate ( g ( me % n + 1 ) ) allocate ( cvec ( me % m ) ) allocate ( dfdx ( me % n ) ) allocate ( dcdx ( me % m , me % n ) ) allocate ( delta ( me % n ) ) allocate ( cvecr ( me % m ) ) allocate ( cvecl ( me % m ) ) i = 0 iter = me % max_iter la = max ( 1 , me % m ) mode = 0 a = zero g = zero c = zero if ( present ( iterations )) iterations = 0 call me % linmin % destroy () call me % slsqpb % destroy () !check setup: if ( size ( x ) /= me % n ) then istat = - 100 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !linesearch: select case ( me % linesearch_mode ) case ( 1 ) !inexact (armijo-type linesearch) acc = abs ( me % acc ) case ( 2 ) !exact acc = - abs ( me % acc ) case default istat = - 101 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end select !make sure the functions have been associated: if (. not . associated ( me % f )) then istat = - 102 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if (( me % gradient_mode == 0 ). and .(. not . associated ( me % g ))) then istat = - 103 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if ( me % gradient_mode < 0 . or . me % gradient_mode > 3 ) then istat = - 104 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if ( me % gradient_mode /= 0 . and . me % gradient_delta <= epmach ) then istat = - 105 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !main solver loop: do if ( mode == 0 . or . mode == 1 ) then !function evaluation (f&c) call me % f ( x , f , cvec ) c ( 1 : me % m ) = cvec end if if ( mode == 0 . or . mode ==- 1 ) then !gradient evaluation (g&a) select case ( me % gradient_mode ) case ( 0 ) ! user supplied gradients call me % g ( x , dfdx , dcdx ) g ( 1 : me % n ) = dfdx a ( 1 : me % m , 1 : me % n ) = dcdx case default ! approximate using finite differences if ( me % gradient_mode == 3 ) then fact = two ! central differences else fact = one ! forward/backward differences end if do ig = 1 , me % n !initialize a delta to perturb the objective !function and the constraint vector delta = zero delta ( ig ) = me % gradient_delta !get the right and left value of the objective !function and the constraint vector select case ( me % gradient_mode ) case ( 1 ) ! backward difference call me % f ( x , fr , cvecr ) call me % f ( x - delta , fl , cvecl ) case ( 2 ) ! forward difference call me % f ( x + delta , fr , cvecr ) call me % f ( x , fl , cvecl ) case ( 3 ) ! central difference call me % f ( x + delta , fr , cvecr ) call me % f ( x - delta , fl , cvecl ) end select !compute the gradients by first-order finite differences g ( ig ) = ( fr - fl ) / ( fact * delta ( ig ) ) if ( me % m > 0 ) then a (:, ig ) = ( cvecr - cvecl ) / ( fact * delta ( ig ) ) end if end do end select !this is an iteration: !note: the initial guess is reported as iteration 0: if ( associated ( me % report )) call me % report ( i , x , f , c ) !report iteration i = i + 1 ! iteration counter end if !main routine: call slsqp ( me % m , me % meq , la , me % n , x , me % xl , me % xu ,& f , c , g , a , acc , iter , mode ,& me % w , me % l_w , & me % slsqpb , me % linmin , me % alphamin , me % alphamax ,& me % tolf , me % toldf , me % toldx ,& me % max_iter_ls , me % nnls_mode ,& me % infinite_bound ) if ( mode == 1 . or . mode ==- 1 ) then !continue to next call else if ( mode == 0 . and . associated ( me % report )) & call me % report ( i , x , f , c ) !report solution call me % report_message ( mode_to_status_message ( mode )) exit end if if ( me % user_triggered_stop ) then mode = - 2 call me % report_message ( mode_to_status_message ( mode )) me % user_triggered_stop = . false . !have to reset in case !method is called again. exit end if end do istat = mode if ( present ( iterations )) iterations = iter if ( present ( status_message )) status_message = mode_to_status_message ( istat ) end subroutine slsqp_wrapper","tags":"","url":"proc/slsqp_wrapper.html"},{"title":"report_message – slsqp","text":"private  subroutine report_message(me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\nif no unit is specified, the error_unit is used. Type Bound slsqp_solver Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False). Called by proc~~report_message~~CalledByGraph proc~report_message slsqp_solver%report_message proc~initialize_slsqp slsqp_solver%initialize_slsqp proc~initialize_slsqp->proc~report_message proc~slsqp_wrapper slsqp_solver%slsqp_wrapper proc~slsqp_wrapper->proc~report_message Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine report_message ( me , str , ival , rval , fatal ) implicit none class ( slsqp_solver ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: str !! the message to report. integer , intent ( in ), optional :: ival !! optional integer to print after the message. real ( wp ), intent ( in ), optional :: rval !! optional real to print after the message. logical , intent ( in ), optional :: fatal !! if True, then the program is stopped (default=False). logical :: stop_program !! true if the program is to be stopped logical :: write_message !! true if the message is to be printed character ( len = 10 ) :: istr !! string version of `ival` character ( len = 30 ) :: rstr !! string version of `rval` character ( len = :), allocatable :: str_to_write !! the actual message to the printed integer :: istat !! iostat for `write` statements !fatal error check: if ( present ( fatal )) then stop_program = fatal else stop_program = . false . end if !note: if stopping program, then the message is always printed: write_message = me % iprint /= 0 . or . stop_program . or . associated ( me % report_msg ) if ( write_message ) then if ( present ( ival )) then write ( istr , fmt = '(I10)' , iostat = istat ) ival if ( istat /= 0 ) istr = '*****' str_to_write = str // ' ' // trim ( adjustl ( istr )) elseif ( present ( rval )) then write ( istr , fmt = '(F30.16)' , iostat = istat ) rval if ( istat /= 0 ) rstr = '*****' str_to_write = str // ' ' // trim ( adjustl ( rstr )) else str_to_write = str end if if ( me % iprint == 0 . and . stop_program ) then write ( error_unit , '(A)' ) str_to_write !in this case, use the error unit elseif ( me % iprint /= 0 ) then write ( me % iprint , '(A)' , iostat = istat ) str_to_write !user specified unit number if ( istat /= 0 ) then ! attempt to write to error unit if above failed: write ( istr , fmt = '(I10)' , iostat = istat ) me % iprint write ( error_unit , '(A)' ) 'Error writing to unit ' // trim ( adjustl ( istr )) write ( error_unit , '(A)' ) str_to_write end if end if if ( associated ( me % report_msg )) call me % report_msg ( str_to_write ) deallocate ( str_to_write ) if ( stop_program ) error stop 'Fatal Error' end if end subroutine report_message","tags":"","url":"proc/report_message.html"},{"title":"slsqp_core – slsqp","text":"Core subroutines for the SLSQP optimization method.\nThese are refactoried versions of the original routines. Uses slsqp_support slsqp_kinds bvls_module ieee_arithmetic module~~slsqp_core~~UsesGraph module~slsqp_core slsqp_core ieee_arithmetic ieee_arithmetic module~slsqp_core->ieee_arithmetic module~bvls_module bvls_module module~slsqp_core->module~bvls_module module~slsqp_kinds slsqp_kinds module~slsqp_core->module~slsqp_kinds module~slsqp_support slsqp_support module~slsqp_core->module~slsqp_support module~bvls_module->module~slsqp_kinds module~bvls_module->module~slsqp_support iso_fortran_env iso_fortran_env module~slsqp_kinds->iso_fortran_env module~slsqp_support->module~slsqp_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~slsqp_core~~UsedByGraph module~slsqp_core slsqp_core module~slsqp_module slsqp_module module~slsqp_module->module~slsqp_core Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: eps = epsilon(1.0_wp) machine precision Derived Types type, public :: linmin_data data formerly saved in linmin routine. Components Type Visibility Attributes Name Initial real(kind=wp), public :: a = zero real(kind=wp), public :: b = zero real(kind=wp), public :: d = zero real(kind=wp), public :: e = zero real(kind=wp), public :: p = zero real(kind=wp), public :: q = zero real(kind=wp), public :: r = zero real(kind=wp), public :: u = zero real(kind=wp), public :: v = zero real(kind=wp), public :: w = zero real(kind=wp), public :: x = zero real(kind=wp), public :: m = zero real(kind=wp), public :: fu = zero real(kind=wp), public :: fv = zero real(kind=wp), public :: fw = zero real(kind=wp), public :: fx = zero real(kind=wp), public :: tol1 = zero real(kind=wp), public :: tol2 = zero Type-Bound Procedures procedure, public :: destroy => destroy_linmin_data type, public :: slsqpb_data data formerly saved in slsqpb . Components Type Visibility Attributes Name Initial real(kind=wp), public :: t = zero real(kind=wp), public :: f0 = zero real(kind=wp), public :: h1 = zero real(kind=wp), public :: h2 = zero real(kind=wp), public :: h3 = zero real(kind=wp), public :: h4 = zero real(kind=wp), public :: t0 = zero real(kind=wp), public :: gs = zero real(kind=wp), public :: tol = zero real(kind=wp), public :: alpha = zero integer, public :: line = 0 integer, public :: iexact = 0 integer, public :: incons = 0 integer, public :: ireset = 0 integer, public :: itermx = 0 integer, public :: n1 = 0 integer, public :: n2 = 0 integer, public :: n3 = 0 Type-Bound Procedures procedure, public :: destroy => destroy_slsqpb_data Functions private pure function check_convergence (n, f, f0, x, x0, s, h3, acc, tolf, toldf, toldx, converged, not_converged, inconsistent_linearization) result(mode) Check for convergence. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: f0 real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: x0 real(kind=wp), intent(in), dimension(:) :: s real(kind=wp), intent(in) :: h3 real(kind=wp), intent(in) :: acc real(kind=wp), intent(in) :: tolf real(kind=wp), intent(in) :: toldf real(kind=wp), intent(in) :: toldx integer, intent(in) :: converged mode value if converged integer, intent(in) :: not_converged mode value if not converged logical, intent(in) :: inconsistent_linearization if the SQP problem is inconsistent (will return not_converged ) Return Value integer private  function linmin (mode, ax, bx, f, tol, a, b, d, e, p, q, r, u, v, w, x, m, fu, fv, fw, fx, tol1, tol2) Linesearch without derivatives (used by slsqp if linesearch_mode=2 ).\n  Returns the abscissa approximating the point where f attains a minimum. Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout) :: mode controls reverse communication\nmust be set to 0 initially, returns with intermediate\nvalues 1 and 2 which must not be changed by the user,\nends with convergence with value 3. real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp) :: f function value at linmin which is to be brought in by\nreverse communication controlled by mode real(kind=wp), intent(in) :: tol desired length of interval of uncertainty of final result real(kind=wp), intent(inout) :: a real(kind=wp), intent(inout) :: b real(kind=wp), intent(inout) :: d real(kind=wp), intent(inout) :: e real(kind=wp), intent(inout) :: p real(kind=wp), intent(inout) :: q real(kind=wp), intent(inout) :: r real(kind=wp), intent(inout) :: u real(kind=wp), intent(inout) :: v real(kind=wp), intent(inout) :: w real(kind=wp), intent(inout) :: x real(kind=wp), intent(inout) :: m real(kind=wp), intent(inout) :: fu real(kind=wp), intent(inout) :: fv real(kind=wp), intent(inout) :: fw real(kind=wp), intent(inout) :: fx real(kind=wp), intent(inout) :: tol1 real(kind=wp), intent(inout) :: tol2 Return Value real(kind=wp) Subroutines public  subroutine slsqp (m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, w, l_w, sdat, ldat, alphamin, alphamax, tolf, toldf, toldx, max_iter_ls, nnls_mode, infinite_bound) slsqp : s equential l east sq uares p rogramming\n  to solve general nonlinear optimization problems Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m is the total number of constraints, integer, intent(in) :: meq is the number of equality constraints, integer, intent(in) :: la see a , integer, intent(in) :: n is the number of variables, real(kind=wp), intent(inout), dimension(n) :: x x() stores the current iterate of the n vector x on entry x() must be initialized. on exit x() stores the solution vector x if mode = 0 . real(kind=wp), intent(in), dimension(n) :: xl xl() stores an n vector of lower bounds xl to x . real(kind=wp), intent(in), dimension(n) :: xu xu() stores an n vector of upper bounds xu to x . real(kind=wp), intent(in) :: f is the value of the objective function. real(kind=wp), intent(in), dimension(la) :: c c() stores the m vector c of constraints,\nequality constraints (if any) first.\ndimension of c must be greater or equal la ,\nwhich must be greater or equal max(1,m) . real(kind=wp), intent(in), dimension(n+1) :: g g() stores the n vector g of partials of the\nobjective function; dimension of g must be\ngreater or equal n+1 . real(kind=wp), intent(in), dimension(la,n+1) :: a the la by n + 1 array a() stores\nthe m by n matrix a of constraint normals. a() has first dimensioning parameter la ,\nwhich must be greater or equal max(1,m) . real(kind=wp), intent(inout) :: acc abs(acc) controls the final accuracy.\nif acc < zero an exact linesearch is performed,\notherwise an armijo-type linesearch is used. integer, intent(inout) :: iter prescribes the maximum number of iterations.\non exit iter indicates the number of iterations. integer, intent(inout) :: mode mode controls calculation: Read more… real(kind=wp), intent(inout), dimension(l_w) :: w w() is a one dimensional working space.\nthe first m+n+n*n1/2 elements of w must not be\nchanged between subsequent calls of slsqp .\non return w(1) ... w(m) contain the multipliers\nassociated with the general constraints, while w(m+1) ... w(m+n(n+1)/2) store the cholesky factor l*d*l(t) of the approximate hessian of the\nlagrangian columnwise dense as lower triangular\nunit matrix l with d in its 'diagonal' and w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n) contain the multipliers associated with all\nconstraints of the quadratic program finding\nthe search direction to the solution x* integer, intent(in) :: l_w the length of w , which should be at least: Read more… type( slsqpb_data ), intent(inout) :: sdat data for slsqpb . type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min for line search real(kind=wp), intent(in) :: alphamax max for line search real(kind=wp), intent(in) :: tolf stopping criterion if then stop. real(kind=wp), intent(in) :: toldf stopping criterion if then stop. real(kind=wp), intent(in) :: toldx stopping criterion if then stop. integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use real(kind=wp), intent(in) :: infinite_bound \"infinity\" for the upper and lower bounds.\nif xl<=-infinite_bound or xu>=infinite_bound then these bounds are considered nonexistant.\nIf infinite_bound=0 then huge() is used for this. private  subroutine slsqpb (m, meq, la, n, x, xl, xu, f, c, g, a, acc, iter, mode, r, l, x0, mu, s, u, v, w, t, f0, h1, h2, h3, h4, n1, n2, n3, t0, gs, tol, line, alpha, iexact, incons, ireset, itermx, ldat, alphamin, alphamax, tolf, toldf, toldx, max_iter_ls, nnls_mode, infBnd) nonlinear programming by solving sequentially quadratic programs Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: la integer, intent(in) :: n real(kind=wp), dimension(n) :: x real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp) :: f real(kind=wp), dimension(la) :: c real(kind=wp), dimension(n+1) :: g real(kind=wp), dimension(la,n+1) :: a real(kind=wp) :: acc integer, intent(inout) :: iter in: maximum number of iterations. out: actual number of iterations. integer, intent(inout) :: mode real(kind=wp), dimension(m+n+n+2) :: r real(kind=wp), dimension((n+1)*(n+2)/2) :: l real(kind=wp), dimension(n) :: x0 real(kind=wp), dimension(la) :: mu real(kind=wp), dimension(n+1) :: s real(kind=wp), dimension(n+1) :: u real(kind=wp), dimension(n+1) :: v real(kind=wp), intent(inout), dimension(*) :: w dim(w) = Read more… real(kind=wp), intent(inout) :: t real(kind=wp), intent(inout) :: f0 real(kind=wp), intent(inout) :: h1 real(kind=wp), intent(inout) :: h2 real(kind=wp), intent(inout) :: h3 real(kind=wp), intent(inout) :: h4 integer, intent(inout) :: n1 integer, intent(inout) :: n2 integer, intent(inout) :: n3 real(kind=wp), intent(inout) :: t0 real(kind=wp), intent(inout) :: gs real(kind=wp), intent(inout) :: tol integer, intent(inout) :: line real(kind=wp), intent(inout) :: alpha integer, intent(inout) :: iexact integer, intent(inout) :: incons integer, intent(inout) :: ireset integer, intent(inout) :: itermx type( linmin_data ), intent(inout) :: ldat data for linmin . real(kind=wp), intent(in) :: alphamin min for line search real(kind=wp), intent(in) :: alphamax max for line search real(kind=wp), intent(in) :: tolf stopping criterion if then stop. real(kind=wp), intent(in) :: toldf stopping criterion if then stop real(kind=wp), intent(in) :: toldx stopping criterion if then stop integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use real(kind=wp), intent(in) :: infBnd \"infinity\" for the upper and lower bounds. private  subroutine lsq (m, meq, n, nl, la, l, g, a, b, xl, xu, x, y, w, mode, max_iter_ls, nnls_mode, infbnd) Minimize with respect to ,\n  with upper triangular matrix ,\n  and vector ,\n  where the unit lower tridiangular matrix is stored columnwise\n  dense in the array with vector stored in its\n  'diagonal' thus substituting the one-elements of Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: meq integer, intent(in) :: n integer, intent(in) :: nl integer, intent(in) :: la real(kind=wp), dimension(nl) :: l real(kind=wp), dimension(n) :: g real(kind=wp), dimension(la,n) :: a real(kind=wp), dimension(la) :: b real(kind=wp), dimension(n) :: xl real(kind=wp), dimension(n) :: xu real(kind=wp), dimension(n) :: x stores the n-dimensional solution vector real(kind=wp), dimension(m+n+n) :: y stores the vector of lagrange multipliers of dimension\nm+n+n (constraints+lower+upper bounds) real(kind=wp), dimension(*) :: w integer :: mode is a success-failure flag with the following meanings: Read more… integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use real(kind=wp), intent(in) :: infbnd \"infinity\" for the upper and lower bounds. private  subroutine lsei (c, d, e, f, g, h, lc, mc, le, me, lg, mg, n, x, xnrm, w, mode, max_iter_ls, nnls_mode) for mode=1 , the subroutine returns the solution x of\n  equality & inequality constrained least squares problem lsei : Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(lc,n) :: c real(kind=wp), intent(inout), dimension(lc) :: d real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: lc integer, intent(in) :: mc integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnrm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w on return, stores the vector of lagrange multipliers\nin its first mc+mg elements integer, intent(out) :: mode is a success-failure flag with the following meanings: Read more… integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use private  subroutine lsi (e, f, g, h, le, me, lg, mg, n, x, xnorm, w, mode, max_iter_ls, nnls_mode) for mode=1 , the subroutine returns the solution x of\n  inequality constrained linear least squares problem: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(le,n) :: e real(kind=wp), intent(inout), dimension(le) :: f real(kind=wp), intent(inout), dimension(lg,n) :: g real(kind=wp), intent(inout), dimension(lg) :: h integer, intent(in) :: le integer, intent(in) :: me integer, intent(in) :: lg integer, intent(in) :: mg integer, intent(in) :: n real(kind=wp), intent(out), dimension(n) :: x stores the solution vector real(kind=wp), intent(out) :: xnorm stores the residuum of the solution in euclidian norm real(kind=wp), intent(inout), dimension(*) :: w stores the vector of lagrange multipliers in its first mg elements integer, intent(out) :: mode is a success-failure flag with the following meanings: Read more… integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use private  subroutine ldp (g, mg, m, n, h, x, xnorm, w, mode, max_iter_ls, nnls_mode) Least distance programming routine.\n  Minimize subject to . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(mg,n) :: g on entry g stores the m by n matrix of\nlinear inequality constraints. g has first\ndimensioning parameter mg integer, intent(in) :: mg integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(in), dimension(m) :: h the right side of the inequality system. real(kind=wp), intent(out), dimension(n) :: x solution vector x if mode=1 . real(kind=wp), intent(out) :: xnorm euclidian norm of the solution vector\nif computation is successful real(kind=wp), intent(inout), dimension(*) :: w w is a one dimensional working space, the length\nof which should be at least (m+2)*(n+1) + 2*m .\non exit w stores the lagrange multipliers\nassociated with the constraints.\nat the solution of problem ldp . integer, intent(out) :: mode success-failure flag with the following meanings: Read more… integer, intent(in) :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in) :: nnls_mode which NNLS method to use private  subroutine nnls (a, mda, m, n, b, x, rnorm, w, zz, mode, max_iter) Nonnegative least squares algorithm. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a on entry, contains the m by n matrix, a . on exit, contains\nthe product matrix, q*a , where q is an m by m orthogonal matrix generated implicitly by\nthis subroutine. integer, intent(in) :: mda first dimensioning parameter for the array a . integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(m) :: b on entry, contains the m-vector b . on exit, contains q*b . real(kind=wp), intent(out), dimension(n) :: x the solution vector. real(kind=wp), intent(out) :: rnorm euclidean norm of the residual vector. real(kind=wp), intent(inout), dimension(n) :: w array of working space.  on exit w will contain\nthe dual solution vector. w will satisfy w(i) = 0 for all i in set p and w(i) <= 0 for all i in set z . real(kind=wp), intent(inout), dimension(m) :: zz an m-array of working space. integer, intent(out) :: mode this is a success-failure flag with the following meanings: Read more… integer, intent(in) :: max_iter maximum number of iterations (if <=0, then 3*n is used) private  subroutine hfti (a, mda, m, n, b, mdb, nb, tau, krank, rnorm, h, g) Rank-deficient least squares algorithm using\n  householder forward triangulation with column interchanges. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a the array a initially contains the matrix of the least squares problem .\neither m >= n or m < n is permitted.\nthere is no restriction on the rank of a .\nthe matrix a will be modified by the subroutine. integer, intent(in) :: mda the first dimensioning parameter of matrix a (mda >= m). integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(mdb,nb) :: b if nb = 0 the subroutine will make no reference\nto the array b . if nb > 0 the array b must\ninitially contain the m x nb matrix b of the\nthe least squares problem ax = b and on return\nthe array b will contain the n x nb solution x . integer, intent(in) :: mdb first dimensioning parameter of matrix b (mdb>=max(m,n)) integer, intent(in) :: nb real(kind=wp), intent(in) :: tau absolute tolerance parameter for pseudorank\ndetermination, provided by the user. integer, intent(out) :: krank pseudorank of a , set by the subroutine. real(kind=wp), intent(out), dimension(nb) :: rnorm on exit, rnorm(j) will contain the euclidian\nnorm of the residual vector for the problem\ndefined by the j-th column vector of the array b . real(kind=wp), intent(inout), dimension(n) :: h array of working space real(kind=wp), intent(inout), dimension(n) :: g array of working space private  subroutine h12 (mode, lpivot, l1, m, u, iue, up, c, ice, icv, ncv) Construction and/or application of a single\n  householder transformation . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: mode 1 or 2 -- selects algorithm h1 to construct and apply a\nhouseholder transformation, or algorithm h2 to apply a\npreviously constructed transformation. integer, intent(in) :: lpivot the index of the pivot element integer, intent(in) :: l1 if l1 <= m the transformation will be constructed to\nzero elements indexed from l1 through m .\nif l1 > m the subroutine does an identity transformation. integer, intent(in) :: m see li . real(kind=wp), intent(inout), dimension(iue,*) :: u on entry with mode = 1 , u contains the pivot\nvector. iue is the storage increment between elements.\non exit when mode = 1 , u and up contain quantities\ndefining the vector u of the householder transformation.\non entry with mode = 2 , u and up should contain\nquantities previously computed with mode = 1 .  these will\nnot be modified during the entry with mode = 2 . dimension[u(iue,m)] integer, intent(in) :: iue see u . real(kind=wp), intent(inout) :: up see u . real(kind=wp), intent(inout), dimension(*) :: c on entry with mode = 1 or 2 , c contains a matrix which\nwill be regarded as a set of vectors to which the\nhouseholder transformation is to be applied.\non exit c contains the set of transformed vectors. integer, intent(in) :: ice storage increment between elements of vectors in c . integer, intent(in) :: icv storage increment between vectors in c . integer, intent(in) :: ncv number of vectors in c to be transformed. if ncv <= 0 no operations will be done on c . private  subroutine g1 (a, b, c, s, sig) Compute orthogonal rotation matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp), intent(out) :: c real(kind=wp), intent(out) :: s real(kind=wp) :: sig private  subroutine ldl (n, a, z, sigma, w) - rank-one - update Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n order of the coefficient matrix a real(kind=wp), intent(inout), dimension(*) :: a In: positive definite matrix of dimension n ;\nonly the lower triangle is used and is stored column by\ncolumn as one dimensional array of dimension n*(n+1)/2 . Read more… real(kind=wp), intent(inout), dimension(*) :: z vector of dimension n of updating elements. real(kind=wp), intent(in) :: sigma scalar factor by which the modifying dyade is multiplied. real(kind=wp), intent(inout), dimension(*) :: w working array of dimension n (used only if ). private  subroutine enforce_bounds (x, xl, xu, infbnd) enforce the bound constraints on x . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x optimization variable vector real(kind=wp), intent(in), dimension(:) :: xl lower bounds (must be same dimension as x ) real(kind=wp), intent(in), dimension(:) :: xu upper bounds (must be same dimension as x ) real(kind=wp), intent(in) :: infbnd \"infinity\" for the upper and lower bounds.\nNote that NaN may also be used to indicate no bound. private  subroutine destroy_slsqpb_data (me) Destructor for slsqpb_data type. Arguments Type Intent Optional Attributes Name class( slsqpb_data ), intent(out) :: me private  subroutine destroy_linmin_data (me) Destructor for linmin_data type. Arguments Type Intent Optional Attributes Name class( linmin_data ), intent(out) :: me","tags":"","url":"module/slsqp_core.html"},{"title":"bvls_module – slsqp","text":"Module for bvls . History Original code from http://www.netlib.org/lawson-hanson/all Jacob Williams, Nov 2018 : refactored into a module. some code cleanup. Uses slsqp_support slsqp_kinds module~~bvls_module~~UsesGraph module~bvls_module bvls_module module~slsqp_kinds slsqp_kinds module~bvls_module->module~slsqp_kinds module~slsqp_support slsqp_support module~bvls_module->module~slsqp_support iso_fortran_env iso_fortran_env module~slsqp_kinds->iso_fortran_env module~slsqp_support->module~slsqp_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~bvls_module~~UsedByGraph module~bvls_module bvls_module module~slsqp_core slsqp_core module~slsqp_core->module~bvls_module module~slsqp_module slsqp_module module~slsqp_module->module~slsqp_core Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine bvls_wrapper (a, mda, m, n, b, x, rnorm, w, zz, mode, max_iter) Call bvls , but matching the interface of the old nnls . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(mda,n) :: a integer, intent(in) :: mda integer, intent(in) :: m integer, intent(in) :: n real(kind=wp), intent(inout), dimension(m) :: b real(kind=wp), intent(out), dimension(n) :: x real(kind=wp), intent(out) :: rnorm real(kind=wp), intent(inout), dimension(n) :: w real(kind=wp), intent(inout), dimension(m) :: zz integer, intent(out) :: mode integer, intent(in) :: max_iter maximum number of iterations\n(if <=0, then 3*n is used) public  subroutine bvls (a, b, bnd, x, rnorm, nsetp, w, index, ierr, max_iter) Given an m by n matrix, , and an m-vector, ,\n  compute an n-vector, , that solves the least squares problem: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:,:) :: a On entry A() contains the M by N matrix, A.\nOn return A() contains the product matrix, Q*A, where\nQ is an M by M orthogonal matrix generated by this\nsubroutine.  The dimensions are M=size(A,1) and N=size(A,2). real(kind=wp), intent(inout), dimension(:) :: b On entry B() contains the M-vector, B.\nOn return, B() contains Q*B.  The same Q multiplies A. real(kind=wp), intent(in), dimension(:,:) :: bnd BND(1,J) is the lower bound for X(J).\nBND(2,J) is the upper bound for X(J). Read more… real(kind=wp), intent(out), dimension(:) :: x On entry X() need not be initialized.  On return,\nX() will contain the solution N-vector. real(kind=wp), intent(out) :: rnorm Euclidean norm of the residual vector, b - A*X. integer, intent(out) :: nsetp Indicates the number of components of the solution\nvector, X(), that are not at their constraint values. real(kind=wp), intent(out), dimension(:) :: w An N-array.  On return, W() will contain the dual solution\nvector.   Using Set definitions below: Read more… integer, intent(out), dimension(:) :: index An INTEGER working array of size N.  On exit the contents\nof this array define the sets P, Z, and F as follows: Read more… integer, intent(out) :: ierr Indicates status on return: Read more… integer, intent(in) :: max_iter maximum number of iterations (if <=0, then 3*n is used)","tags":"","url":"module/bvls_module.html"},{"title":"slsqp_kinds – slsqp","text":"Numeric kind definitions. Note The default real kind ( wp ) can be\n      changed using optional preprocessor flags.\n      This library was built with real kind: real(kind=real64) [8 bytes] Uses iso_fortran_env module~~slsqp_kinds~~UsesGraph module~slsqp_kinds slsqp_kinds iso_fortran_env iso_fortran_env module~slsqp_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~slsqp_kinds~~UsedByGraph module~slsqp_kinds slsqp_kinds module~bvls_module bvls_module module~bvls_module->module~slsqp_kinds module~slsqp_support slsqp_support module~bvls_module->module~slsqp_support module~slsqp_core slsqp_core module~slsqp_core->module~slsqp_kinds module~slsqp_core->module~bvls_module module~slsqp_core->module~slsqp_support module~slsqp_module slsqp_module module~slsqp_module->module~slsqp_kinds module~slsqp_module->module~slsqp_core module~slsqp_module->module~slsqp_support module~slsqp_support->module~slsqp_kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: slsqp_rk = real64 real kind used by this module [8 bytes] integer, public, parameter :: wp = slsqp_rk copy of slsqp_rk with a shorter name","tags":"","url":"module/slsqp_kinds.html"},{"title":"slsqp_support – slsqp","text":"Support routines for SLSQP. For example, routines from BLAS and LINPACK .\nThese have also been refactored into modern Fortran. Uses slsqp_kinds module~~slsqp_support~~UsesGraph module~slsqp_support slsqp_support module~slsqp_kinds slsqp_kinds module~slsqp_support->module~slsqp_kinds iso_fortran_env iso_fortran_env module~slsqp_kinds->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~slsqp_support~~UsedByGraph module~slsqp_support slsqp_support module~bvls_module bvls_module module~bvls_module->module~slsqp_support module~slsqp_core slsqp_core module~slsqp_core->module~slsqp_support module~slsqp_core->module~bvls_module module~slsqp_module slsqp_module module~slsqp_module->module~slsqp_support module~slsqp_module->module~slsqp_core Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: epmach = epsilon(1.0_wp) real(kind=wp), public, parameter :: zero = 0.0_wp real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: two = 2.0_wp real(kind=wp), public, parameter :: four = 4.0_wp real(kind=wp), public, parameter :: ten = 10.0_wp real(kind=wp), public, parameter :: hun = 100.0_wp Functions public pure function ddot (n, dx, incx, dy, incy) forms the dot product of two vectors.\n  uses unrolled loops for increments equal to one. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: dx integer, intent(in) :: incx real(kind=wp), intent(in), dimension(*) :: dy integer, intent(in) :: incy Return Value real(kind=wp) public pure function dnrm2 (n, x, incx) result(norm) Function that returns the Euclidean norm of a vector . Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: x integer, intent(in) :: incx Return Value real(kind=wp) Subroutines public pure subroutine daxpy (n, da, dx, incx, dy, incy) constant times a vector plus a vector.\n  uses unrolled loops for increments equal to one. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: da real(kind=wp), intent(in), dimension(*) :: dx integer, intent(in) :: incx real(kind=wp), intent(inout), dimension(*) :: dy integer, intent(in) :: incy public pure subroutine dcopy (n, dx, incx, dy, incy) copies a vector, x, to a vector, y.\n  uses unrolled loops for increments equal to one. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(*) :: dx integer, intent(in) :: incx real(kind=wp), intent(out), dimension(*) :: dy integer, intent(in) :: incy public pure subroutine dscal (n, da, dx, incx) scales a vector by a constant.\n  uses unrolled loops for increment equal to one. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in) :: da real(kind=wp), intent(inout), dimension(*) :: dx integer, intent(in) :: incx","tags":"","url":"module/slsqp_support.html"},{"title":"slsqp_module – slsqp","text":"Module containing the object-oriented interface to the SLSQP method.\nIt is called using the slsqp_solver class, which\nis the only public entity in this module. Uses slsqp_support slsqp_core slsqp_kinds iso_fortran_env ieee_arithmetic module~~slsqp_module~~UsesGraph module~slsqp_module slsqp_module ieee_arithmetic ieee_arithmetic module~slsqp_module->ieee_arithmetic iso_fortran_env iso_fortran_env module~slsqp_module->iso_fortran_env module~slsqp_core slsqp_core module~slsqp_module->module~slsqp_core module~slsqp_kinds slsqp_kinds module~slsqp_module->module~slsqp_kinds module~slsqp_support slsqp_support module~slsqp_module->module~slsqp_support module~slsqp_core->ieee_arithmetic module~slsqp_core->module~slsqp_kinds module~slsqp_core->module~slsqp_support module~bvls_module bvls_module module~slsqp_core->module~bvls_module module~slsqp_kinds->iso_fortran_env module~slsqp_support->module~slsqp_kinds module~bvls_module->module~slsqp_kinds module~bvls_module->module~slsqp_support Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine func(me, x, f, c) for computing the function Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f value of the objective function real(kind=wp), intent(out), dimension(:) :: c the constraint vector dimension(m) ,\nequality constraints (if any) first. abstract interface private  subroutine grad(me, x, g, a) for computing the gradients Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out), dimension(:) :: g objective function partials w.r.t x dimension(n) real(kind=wp), intent(out), dimension(:,:) :: a gradient matrix of constraints w.r.t. x dimension(m,n) abstract interface private  subroutine iterfunc(me, iter, x, f, c) for reporting an iteration Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: iter iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(in) :: f value of the objective function real(kind=wp), intent(in), dimension(:) :: c the constraint vector dimension(m) ,\nequality constraints (if any) first. abstract interface private  subroutine msgfunc(me, str) for reporting a message to the user Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me character(len=*), intent(in) :: str the message to report. Derived Types type, public :: slsqp_solver The main class used to interface with the SLSQP solver. Components Type Visibility Attributes Name Initial integer, private :: n = 0 number of optimization variables ( ) integer, private :: m = 0 number of constraints ( ) integer, private :: meq = 0 number of equality constraints ( ) integer, private :: max_iter = 0 maximum number of iterations real(kind=wp), private :: acc = zero accuracy tolerance real(kind=wp), private :: tolf = -one accuracy tolerance over f:  if then stop real(kind=wp), private :: toldf = -one accuracy tolerance over df: if then stop.\nIt's different from acc in the case of positive derivative real(kind=wp), private :: toldx = -one accuracy tolerance over dx: if then stop integer, private :: gradient_mode = 0 how the gradients are computed: Read more… real(kind=wp), private :: gradient_delta = 1.0e8_wp perturbation step size to approximate gradients\nby finite differences ( gradient_mode 1-3). real(kind=wp), private :: alphamin = 0.1_wp min for line search real(kind=wp), private :: alphamax = 1.0_wp max for line search integer, private :: iprint = output_unit unit number of status printing (0 for no printing) real(kind=wp), private, dimension(:), allocatable :: xl lower bound on x real(kind=wp), private, dimension(:), allocatable :: xu upper bound on x integer, private :: l_w = 0 size of w real(kind=wp), private, dimension(:), allocatable :: w real work array procedure( func ), private, pointer :: f => null() problem function subroutine procedure( grad ), private, pointer :: g => null() gradient subroutine procedure( iterfunc ), private, pointer :: report => null() for reporting an iteration procedure( msgfunc ), private, pointer :: report_msg => null() for reporting a string message from slsqp to the user integer, private :: linesearch_mode = 1 linesearch mode: Read more… type( linmin_data ), private :: linmin data formerly within linmin .\nOnly used when linesearch_mode=2 type( slsqpb_data ), private :: slsqpb data formerly within slsqpb . integer, private :: nnls_mode = 1 Which NNLS method to use: Read more… integer, private :: max_iter_ls = 0 max iterations in the least squares problem.\nif <=0 , defaults to 3*n .\n(use by either nnls or bvls ) logical, private :: user_triggered_stop = .false. if the abort method has been called\nto stop the iterations real(kind=wp), private :: infinite_bound = huge(one) \"infinity\" for the upper and lower bounds.\nif xl<=-infinite_bound or xu>=infinite_bound then these bounds are considered nonexistant. Type-Bound Procedures procedure, public :: initialize => initialize_slsqp procedure, public :: destroy => destroy_slsqp procedure, public :: optimize => slsqp_wrapper procedure, public :: abort => stop_iterations procedure, private :: report_message ../../ for reporting messages to the user Functions private pure function mode_to_status_message (imode) result(message) Convert the slsqp mode flag to a message string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: imode Return Value character(len=:), allocatable Subroutines private  subroutine stop_iterations (me) A method that the user can call to stop the iterations.\n(it can be called in any of the functions).\nSLSQP will stop at the end of the next iteration. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me private  subroutine initialize_slsqp (me, n, m, meq, max_iter, acc, f, g, xl, xu, status_ok, linesearch_mode, iprint, report, alphamin, alphamax, gradient_mode, gradient_delta, tolf, toldf, toldx, max_iter_ls, nnls_mode, infinite_bound, report_msg) initialize the slsqp_solver class.  see slsqp for more details. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me integer, intent(in) :: n the number of variables, integer, intent(in) :: m total number of constraints, integer, intent(in) :: meq number of equality constraints, integer, intent(in) :: max_iter maximum number of iterations real(kind=wp), intent(in) :: acc accuracy procedure( func ) :: f problem function procedure( grad ) :: g function to compute gradients (must be\nassociated if gradient_mode=0 ) real(kind=wp), intent(in), dimension(n) :: xl lower bounds on x . xl(i)=NaN (or xl(i)<=-infinite_bound ) indicates to ignore i th bound real(kind=wp), intent(in), dimension(n) :: xu upper bounds on x . xu(i)=NaN (or xu(i)>=infinite_bound ) indicates to ignore i th bound logical, intent(out) :: status_ok will be false if there were errors integer, intent(in), optional :: linesearch_mode 1 = inexact (default), 2 = exact integer, intent(in), optional :: iprint unit number of status messages (default= output_unit ) procedure( iterfunc ), optional :: report user-defined procedure that will be called once per iteration real(kind=wp), intent(in), optional :: alphamin minimum alpha for linesearch [default 0.1] real(kind=wp), intent(in), optional :: alphamax maximum alpha for linesearch [default 1.0] integer, intent(in), optional :: gradient_mode how the gradients are to be computed: Read more… real(kind=wp), intent(in), optional :: gradient_delta perturbation step size (>epsilon) to compute the approximated\ngradient by finite differences ( gradient_mode 1-3).\nnote that this is an absolute step that does not respect\nthe xl or xu variable bounds. real(kind=wp), intent(in), optional :: tolf stopping criterion if then stop. real(kind=wp), intent(in), optional :: toldf stopping criterion if then stop real(kind=wp), intent(in), optional :: toldx stopping criterion if then stop integer, intent(in), optional :: max_iter_ls maximum number of iterations in the nnls problem integer, intent(in), optional :: nnls_mode Which NNLS method to use: Read more… real(kind=wp), intent(in), optional :: infinite_bound \"infinity\" for the upper and lower bounds.\nif xl<=-infinite_bound or xu>=infinite_bound then these bounds are considered nonexistant.\nIf not present then huge() is used for this. procedure( msgfunc ), optional :: report_msg user-defined procedure that will be called\nwith any warning or error messages. private  subroutine destroy_slsqp (me) destructor for slsqp_solver . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(out) :: me private  subroutine slsqp_wrapper (me, x, istat, iterations, status_message) main routine for calling slsqp . Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x in: initial optimization variables, out: solution. integer, intent(out) :: istat status code (see mode in slsqp ). integer, intent(out), optional :: iterations number of iterations character(len=:), intent(out), optional, allocatable :: status_message string status message\ncorresponding to istat private  subroutine report_message (me, str, ival, rval, fatal) Report a message from an slsqp_solver class. This uses the iprint variable in the class as the unit number for printing. Note: for fatal errors,\nif no unit is specified, the error_unit is used. Arguments Type Intent Optional Attributes Name class( slsqp_solver ), intent(inout) :: me character(len=*), intent(in) :: str the message to report. integer, intent(in), optional :: ival optional integer to print after the message. real(kind=wp), intent(in), optional :: rval optional real to print after the message. logical, intent(in), optional :: fatal if True, then the program is stopped (default=False).","tags":"","url":"module/slsqp_module.html"},{"title":"slsqp_core.f90 – slsqp","text":"This file depends on sourcefile~~slsqp_core.f90~~EfferentGraph sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~bvls_module.f90 bvls_module.f90 sourcefile~slsqp_core.f90->sourcefile~bvls_module.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.F90 sourcefile~slsqp_core.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_support.f90 slsqp_support.F90 sourcefile~slsqp_core.f90->sourcefile~slsqp_support.f90 sourcefile~bvls_module.f90->sourcefile~slsqp_kinds.f90 sourcefile~bvls_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~slsqp_core.f90~~AfferentGraph sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> license: BSD ! !  Core subroutines for the SLSQP optimization method. !  These are refactoried versions of the original routines. module slsqp_core use slsqp_kinds use slsqp_support use bvls_module , only : bvls_wrapper use , intrinsic :: ieee_arithmetic , only : ieee_is_nan , ieee_value , ieee_quiet_nan implicit none private real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) !! machine precision type , public :: linmin_data !! data formerly saved in [[linmin]] routine. real ( wp ) :: a = zero real ( wp ) :: b = zero real ( wp ) :: d = zero real ( wp ) :: e = zero real ( wp ) :: p = zero real ( wp ) :: q = zero real ( wp ) :: r = zero real ( wp ) :: u = zero real ( wp ) :: v = zero real ( wp ) :: w = zero real ( wp ) :: x = zero real ( wp ) :: m = zero real ( wp ) :: fu = zero real ( wp ) :: fv = zero real ( wp ) :: fw = zero real ( wp ) :: fx = zero real ( wp ) :: tol1 = zero real ( wp ) :: tol2 = zero contains procedure :: destroy => destroy_linmin_data end type linmin_data type , public :: slsqpb_data !! data formerly saved in [[slsqpb]]. real ( wp ) :: t = zero real ( wp ) :: f0 = zero real ( wp ) :: h1 = zero real ( wp ) :: h2 = zero real ( wp ) :: h3 = zero real ( wp ) :: h4 = zero real ( wp ) :: t0 = zero real ( wp ) :: gs = zero real ( wp ) :: tol = zero real ( wp ) :: alpha = zero integer :: line = 0 integer :: iexact = 0 integer :: incons = 0 integer :: ireset = 0 integer :: itermx = 0 integer :: n1 = 0 integer :: n2 = 0 integer :: n3 = 0 contains procedure :: destroy => destroy_slsqpb_data end type slsqpb_data public :: slsqp contains !******************************************************************************* !******************************************************************************* !> !  **slsqp**: **s**equential **l**east **sq**uares **p**rogramming !  to solve general nonlinear optimization problems ! !  a nonlinear programming method with quadratic programming subproblems !  this subroutine solves the general nonlinear programming problem: ! !  **minimize** ! !  *  f(x)  ! !  **subject to** ! !  *  c_j (x) = 0 ,            j = 1,...,meq    !  *  c_j (x) \\ge 0 ,          j = meq+1,...,m  !  *  xl_i \\le x_i \\le xu_i ,  i = 1,...,n      ! !  the algorithm implements the method of Han and Powell !  with BFGS-update of the b-matrix and L1-test function !  within the steplength algorithm. ! !### Reference !   * Dieter Kraft: \"A software package for sequential quadratic programming\", !     DFVLR-FB 88-28, 1988 ! !### History !   * implemented by: Dieter Kraft, DFVLR oberpfaffenhofen !   * date: april - october, 1981. !   * December, 31-st, 1984. !   * March   , 21-st, 1987, revised to fortran 77 !   * March   , 20-th, 1989, revised to ms-fortran !   * April   , 14-th, 1989, hesse   in-line coded !   * February, 28-th, 1991, fortran/2 version 1.04 accepts statement functions !   * March   ,  1-st, 1991, tested with salford ftn77/386 compiler vers 2.40 in protected mode !   * January ,        2016, Refactored into modern Fortran by Jacob Williams ! !### License !  Original version copyright 1991: Dieter Kraft, FHM. !  Released under a BSD license. ! !@note `f`, `c`, `g`, `a` must all be set by the user before each call. subroutine slsqp ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode , w , l_w , & sdat , ldat , alphamin , alphamax , tolf , toldf , toldx ,& max_iter_ls , nnls_mode , infinite_bound ) implicit none integer , intent ( in ) :: m !! is the total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! is the number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: la !! see `a`,  la \\ge \\max(m,1)  integer , intent ( in ) :: n !! is the number of variables,  n \\ge 1  real ( wp ), dimension ( n ), intent ( inout ) :: x !! `x()` stores the current iterate of the `n` vector `x` !! on entry `x()` must be initialized. on exit `x()` !! stores the solution vector `x` if `mode = 0`. real ( wp ), dimension ( n ), intent ( in ) :: xl !! `xl()` stores an n vector of lower bounds `xl` to `x`. real ( wp ), dimension ( n ), intent ( in ) :: xu !! `xu()` stores an n vector of upper bounds `xu` to `x`. real ( wp ), intent ( in ) :: f !! is the value of the objective function. real ( wp ), dimension ( la ), intent ( in ) :: c !! `c()` stores the `m` vector `c` of constraints, !! equality constraints (if any) first. !! dimension of `c` must be greater or equal `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), dimension ( n + 1 ), intent ( in ) :: g !! `g()` stores the `n` vector `g` of partials of the !! objective function; dimension of `g` must be !! greater or equal `n+1`. real ( wp ), dimension ( la , n + 1 ), intent ( in ) :: a !! the `la` by `n + 1` array `a()` stores !! the `m` by `n` matrix `a` of constraint normals. !! `a()` has first dimensioning parameter `la`, !! which must be greater or equal `max(1,m)`. real ( wp ), intent ( inout ) :: acc !! `abs(acc)` controls the final accuracy. !! if `acc` < zero an exact linesearch is performed, !! otherwise an armijo-type linesearch is used. integer , intent ( inout ) :: iter !! prescribes the maximum number of iterations. !! on exit `iter` indicates the number of iterations. integer , intent ( inout ) :: mode !! mode controls calculation: !! !! reverse communication is used in the sense that !! the program is initialized by `mode = 0`; then it is !! to be called repeatedly by the user until a return !! with `mode /= abs(1)` takes place. !! if `mode = -1` gradients have to be calculated, !! while with `mode = 1` functions have to be calculated. !! mode must not be changed between subsequent calls of [[slsqp]]. !! !! **evaluation modes**: !! !! * ** -1 **: gradient evaluation, (`g` & `a`) !! * **  0 **: *on entry*: initialization, (`f`, `g`, `c`, `a`), !!   *on exit*: required accuracy for solution obtained !! * **  1 **: function evaluation, (`f` & `c`) !! !! **failure modes**: !! !! * ** 2 **: number of equality constraints larger than `n` !! * ** 3 **: more than `3*n` iterations in [[lsq]] subproblem !! * ** 4 **: inequality constraints incompatible !! * ** 5 **: singular matrix `e` in [[lsq]] subproblem !! * ** 6 **: singular matrix `c` in [[lsq]] subproblem !! * ** 7 **: rank-deficient equality constraint subproblem [[hfti]] !! * ** 8 **: positive directional derivative for linesearch !! * ** 9 **: more than `iter` iterations in sqp !! * ** >=10 **: working space `w` too small, !!   `w` should be enlarged to `l_w=mode/1000`, integer , intent ( in ) :: l_w !! the length of `w`, which should be at least: !! !! * `(3*n1+m)*(n1+1)`                     **for lsq** !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`     **for lsi** !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`   **for lsei** !! * `+ n1*n/2 + 2*m + 3*n + 3*n1 + 1`     **for slsqpb** !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` real ( wp ), dimension ( l_w ), intent ( inout ) :: w !! `w()` is a one dimensional working space. !! the first `m+n+n*n1/2` elements of `w` must not be !! changed between subsequent calls of [[slsqp]]. !! on return `w(1) ... w(m)` contain the multipliers !! associated with the general constraints, while !! `w(m+1) ... w(m+n(n+1)/2)` store the cholesky factor !! `l*d*l(t)` of the approximate hessian of the !! lagrangian columnwise dense as lower triangular !! unit matrix `l` with `d` in its 'diagonal' and !! `w(m+n(n+1)/2+n+2 ... w(m+n(n+1)/2+n+2+m+2n)` !! contain the multipliers associated with all !! constraints of the quadratic program finding !! the search direction to the solution `x*` type ( slsqpb_data ), intent ( inout ) :: sdat !! data for [[slsqpb]]. type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ) :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop. real ( wp ), intent ( in ) :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop. integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use real ( wp ), intent ( in ) :: infinite_bound !! \"infinity\" for the upper and lower bounds. !! if `xl<=-infinite_bound` or `xu>=infinite_bound` !! then these bounds are considered nonexistant. !! If `infinite_bound=0` then `huge()` is used for this. integer :: il , im , ir , is , iu , iv , iw , ix , mineq , n1 real ( wp ) :: infBnd !! local copy of `infinite_bound` if ( infinite_bound == zero ) then infBnd = huge ( one ) else infBnd = abs ( infinite_bound ) end if ! check length of working arrays n1 = n + 1 mineq = m - meq + n1 + n1 il = ( 3 * n1 + m ) * ( n1 + 1 ) + ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + ( n1 + mineq )& * ( n1 - meq ) + 2 * meq + n1 * n / 2 + 2 * m + 3 * n + 4 * n1 + 1 im = max ( mineq , n1 - meq ) if ( l_w < il ) then mode = 1000 * max ( 10 , il ) mode = mode + max ( 10 , im ) iter = 0 return end if if ( meq > n ) then ! note: calling lsq when meq>n is corrupting the ! memory in some way, so just catch this here. mode = 2 iter = 0 return end if ! prepare data for calling sqpbdy  -  initial addresses in w im = 1 il = im + max ( 1 , m ) il = im + la ix = il + n1 * n / 2 + 1 ir = ix + n is = ir + n + n + max ( 1 , m ) is = ir + n + n + la iu = is + n1 iv = iu + n1 iw = iv + n1 sdat % n1 = n1 call slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& w ( ir ), w ( il ), w ( ix ), w ( im ), w ( is ), w ( iu ), w ( iv ), w ( iw ),& sdat % t , sdat % f0 , sdat % h1 , sdat % h2 , sdat % h3 , sdat % h4 ,& sdat % n1 , sdat % n2 , sdat % n3 , sdat % t0 , sdat % gs , sdat % tol , sdat % line ,& sdat % alpha , sdat % iexact , sdat % incons , sdat % ireset , sdat % itermx ,& ldat , alphamin , alphamax , tolf , toldf , toldx ,& max_iter_ls , nnls_mode , infBnd ) end subroutine slsqp !******************************************************************************* !******************************************************************************* !> !  nonlinear programming by solving sequentially quadratic programs ! !  l1 - line search, positive definite bfgs update subroutine slsqpb ( m , meq , la , n , x , xl , xu , f , c , g , a , acc , iter , mode ,& r , l , x0 , mu , s , u , v , w ,& t , f0 , h1 , h2 , h3 , h4 , n1 , n2 , n3 , t0 , gs , tol , line ,& alpha , iexact , incons , ireset , itermx , ldat ,& alphamin , alphamax , tolf , toldf , toldx ,& max_iter_ls , nnls_mode , infBnd ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: meq integer , intent ( in ) :: la integer , intent ( in ) :: n real ( wp ), dimension ( n ) :: x real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: f real ( wp ), dimension ( la ) :: c real ( wp ), dimension ( n + 1 ) :: g real ( wp ), dimension ( la , n + 1 ) :: a real ( wp ) :: acc integer , intent ( inout ) :: iter !! **in:**  maximum number of iterations. !! **out:** actual number of iterations. integer , intent ( inout ) :: mode real ( wp ), dimension ( m + n + n + 2 ) :: r real ( wp ), dimension (( n + 1 ) * ( n + 2 ) / 2 ) :: l real ( wp ), dimension ( n ) :: x0 real ( wp ), dimension ( la ) :: mu real ( wp ), dimension ( n + 1 ) :: s real ( wp ), dimension ( n + 1 ) :: u real ( wp ), dimension ( n + 1 ) :: v real ( wp ), dimension ( * ), intent ( inout ) :: w !! `dim(w)` = !! !! * `n1*(n1+1) + meq*(n1+1) + mineq*(n1+1)`   for [[lsq]] !! * `+(n1-meq+1)*(mineq+2) + 2*mineq`         for [[lsi]] !! * `+(n1+mineq)*(n1-meq) + 2*meq + n1`       for [[lsei]] !! !! with `mineq = m - meq + 2*n1` & `n1 = n+1` real ( wp ), intent ( inout ) :: t real ( wp ), intent ( inout ) :: f0 real ( wp ), intent ( inout ) :: h1 real ( wp ), intent ( inout ) :: h2 real ( wp ), intent ( inout ) :: h3 real ( wp ), intent ( inout ) :: h4 integer , intent ( inout ) :: n1 integer , intent ( inout ) :: n2 integer , intent ( inout ) :: n3 real ( wp ), intent ( inout ) :: t0 real ( wp ), intent ( inout ) :: gs real ( wp ), intent ( inout ) :: tol integer , intent ( inout ) :: line real ( wp ), intent ( inout ) :: alpha integer , intent ( inout ) :: iexact integer , intent ( inout ) :: incons integer , intent ( inout ) :: ireset integer , intent ( inout ) :: itermx type ( linmin_data ), intent ( inout ) :: ldat !! data for [[linmin]]. real ( wp ), intent ( in ) :: alphamin !! min  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: alphamax !! max  \\alpha  for line search !!  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ), intent ( in ) :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ) :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop real ( wp ), intent ( in ) :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use real ( wp ), intent ( in ) :: infBnd !! \"infinity\" for the upper and lower bounds. integer :: i , j , k logical :: inconsistent_linearization !! if the SQP problem is inconsistent inconsistent_linearization = . false . ! initialize if ( mode < 0 ) then ! call jacobian at current x ! update cholesky-factors of hessian matrix by modified bfgs formula do i = 1 , n u ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) - v ( i ) end do ! l'*s k = 0 do i = 1 , n h1 = zero k = k + 1 do j = i + 1 , n k = k + 1 h1 = h1 + l ( k ) * s ( j ) end do v ( i ) = s ( i ) + h1 end do ! d*l'*s k = 1 do i = 1 , n v ( i ) = l ( k ) * v ( i ) k = k + n1 - i end do ! l*d*l'*s do i = n , 1 , - 1 h1 = zero k = i do j = 1 , i - 1 h1 = h1 + l ( k ) * v ( j ) k = k + n - j end do v ( i ) = v ( i ) + h1 end do h1 = ddot ( n , s , 1 , u , 1 ) h2 = ddot ( n , s , 1 , v , 1 ) h3 = 0.2_wp * h2 if ( h1 < h3 ) then h4 = ( h2 - h3 ) / ( h2 - h1 ) h1 = h3 call dscal ( n , h4 , u , 1 ) call daxpy ( n , one - h4 , v , 1 , u , 1 ) end if if ( h1 == zero . or . h2 == zero ) then ! Singular update: reset hessian. ! [ JW : this is based on a SciPy update ] call reset_bfgs_matrix () if ( ireset > 5 ) return else call ldl ( n , l , u , + one / h1 , v ) call ldl ( n , l , v , - one / h2 , u ) end if ! end of main iteration else if ( mode == 0 ) then itermx = iter if ( acc >= zero ) then iexact = 0 else iexact = 1 end if acc = abs ( acc ) tol = ten * acc iter = 0 ireset = 0 n1 = n + 1 n2 = n1 * n / 2 n3 = n2 + 1 s ( 1 ) = zero mu ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) call dcopy ( m , mu ( 1 ), 0 , mu , 1 ) call reset_bfgs_matrix () if ( ireset > 5 ) return else ! call functions at current x t = f do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if t = t + mu ( j ) * max ( - c ( j ), h1 ) end do h1 = t - t0 select case ( iexact ) case ( 0 ) if ( h1 <= h3 / ten . or . line > 10 ) then call convergence_check ( acc , 0 , - 1 ) else alpha = min ( max ( h3 / ( two * ( h3 - h1 )), alphamin ), alphamax ) call inexact_linesearch () end if case ( 1 ) call exact_linesearch () if ( line == 3 ) call convergence_check ( acc , 0 , - 1 ) end select return end if do ! main iteration : search direction, steplength, ldl'-update iter = iter + 1 mode = 9 if ( iter > itermx ) return ! search direction as solution of qp - subproblem call dcopy ( n , xl , 1 , u , 1 ) call dcopy ( n , xu , 1 , v , 1 ) call daxpy ( n , - one , x , 1 , u , 1 ) call daxpy ( n , - one , x , 1 , v , 1 ) h4 = one call lsq ( m , meq , n , n3 , la , l , g , a , c , u , v , s , r , w , mode , max_iter_ls , nnls_mode , infBnd ) ! augmented problem for inconsistent linearization inconsistent_linearization = . false . ! initialize if ( mode == 6 ) then if ( n == meq ) mode = 4 end if if ( mode == 4 ) then ! Will reject this iteration if the SQP problem is inconsistent, inconsistent_linearization = . true . do j = 1 , m if ( j <= meq ) then a ( j , n1 ) = - c ( j ) else a ( j , n1 ) = max ( - c ( j ), zero ) end if end do s ( 1 ) = zero call dcopy ( n , s ( 1 ), 0 , s , 1 ) h3 = zero g ( n1 ) = zero l ( n3 ) = hun s ( n1 ) = one u ( n1 ) = zero v ( n1 ) = one incons = 0 do call lsq ( m , meq , n1 , n3 , la , l , g , a , c , u , v , s , r , w , mode , max_iter_ls , nnls_mode , infBnd ) h4 = one - s ( n1 ) if ( mode == 4 ) then l ( n3 ) = ten * l ( n3 ) incons = incons + 1 if ( incons <= 5 ) cycle return else if ( mode /= 1 ) then return else exit end if end do else if ( mode /= 1 ) then return end if ! update multipliers for l1-test do i = 1 , n v ( i ) = g ( i ) - ddot ( m , a ( 1 , i ), 1 , r , 1 ) end do f0 = f call dcopy ( n , x , 1 , x0 , 1 ) gs = ddot ( n , g , 1 , s , 1 ) h1 = abs ( gs ) h2 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h2 = h2 + max ( - c ( j ), h3 ) h3 = abs ( r ( j )) mu ( j ) = max ( h3 ,( mu ( j ) + h3 ) / two ) h1 = h1 + h3 * abs ( c ( j )) end do ! check convergence mode = 0 if ( h1 < acc . and . h2 < acc . and . & . not . inconsistent_linearization . and . & . not . ieee_is_nan ( f )) return h1 = zero do j = 1 , m if ( j <= meq ) then h3 = c ( j ) else h3 = zero end if h1 = h1 + mu ( j ) * max ( - c ( j ), h3 ) end do t0 = f + h1 h3 = gs - h1 * h4 mode = 8 if ( h3 >= zero ) then call reset_bfgs_matrix () if ( ireset > 5 ) return else exit end if end do ! line search with an l1-testfunction line = 0 alpha = alphamax if ( iexact == 1 ) then call exact_linesearch () if ( line == 3 ) call convergence_check ( acc , 0 , - 1 ) else call inexact_linesearch () end if contains subroutine reset_bfgs_matrix () ! 100 !! reset BFGS matrix ireset = ireset + 1 if ( ireset > 5 ) then ! check relaxed convergence in case of positive directional derivative ! [ JW: reuse this routine so that h3 is recomputed. !   this is based on a SciPy update to SLSQP ] call convergence_check ( tol , 0 , 8 ) ! the caller should return in this case else l ( 1 ) = zero call dcopy ( n2 , l ( 1 ), 0 , l , 1 ) j = 1 do i = 1 , n l ( j ) = one j = j + n1 - i end do end if end subroutine reset_bfgs_matrix subroutine inexact_linesearch () ! 300 line = line + 1 h3 = alpha * h3 call dscal ( n , alpha , s , 1 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , one , s , 1 , x , 1 ) call enforce_bounds ( x , xl , xu , infBnd ) ! ensure that x doesn't violate bounds mode = 1 end subroutine inexact_linesearch subroutine exact_linesearch () ! 400 if ( line /= 3 ) then alpha = linmin ( line , alphamin , alphamax , t , tol , & ldat % a , ldat % b , ldat % d , ldat % e , ldat % p , ldat % q , & ldat % r , ldat % u , ldat % v , ldat % w , ldat % x , ldat % m , & ldat % fu , ldat % fv , ldat % fw , ldat % fx , ldat % tol1 , ldat % tol2 ) call dcopy ( n , x0 , 1 , x , 1 ) call daxpy ( n , alpha , s , 1 , x , 1 ) mode = 1 else call dscal ( n , alpha , s , 1 ) end if end subroutine exact_linesearch subroutine convergence_check ( tolerance , converged , not_converged ) ! 500 real ( wp ), intent ( in ) :: tolerance !! tolerance integer , intent ( in ) :: converged !! mode value if converged integer , intent ( in ) :: not_converged !! mode value if not converged h3 = zero do j = 1 , m if ( j <= meq ) then h1 = c ( j ) else h1 = zero end if h3 = h3 + max ( - c ( j ), h1 ) end do mode = check_convergence ( n , f , f0 , x , x0 , s , h3 , tolerance , tolf , toldf , toldx ,& converged , not_converged , inconsistent_linearization ) end subroutine convergence_check end subroutine slsqpb !******************************************************************************* !******************************************************************************* !> !  Check for convergence. pure function check_convergence ( n , f , f0 , x , x0 , s , h3 , acc , tolf , toldf , toldx ,& converged , not_converged , inconsistent_linearization ) result ( mode ) implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: f real ( wp ), intent ( in ) :: f0 real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: x0 real ( wp ), dimension (:), intent ( in ) :: s real ( wp ), intent ( in ) :: h3 real ( wp ), intent ( in ) :: acc real ( wp ), intent ( in ) :: tolf real ( wp ), intent ( in ) :: toldf real ( wp ), intent ( in ) :: toldx integer , intent ( in ) :: converged !! mode value if converged integer , intent ( in ) :: not_converged !! mode value if not converged logical , intent ( in ) :: inconsistent_linearization !! if the SQP problem is inconsistent (will return `not_converged`) integer :: mode logical :: ok ! temp variable real ( wp ), dimension ( n ) :: xmx0 if ( h3 >= acc . or . inconsistent_linearization . or . ieee_is_nan ( f )) then mode = not_converged else ! if any are OK then it is converged ok = . false . if (. not . ok ) ok = abs ( f - f0 ) < acc if (. not . ok ) ok = dnrm2 ( n , s , 1 ) < acc ! note that these can be ignored if they are < 0: if (. not . ok . and . tolf >= zero ) ok = abs ( f ) < tolf if (. not . ok . and . toldf >= zero ) ok = abs ( f - f0 ) < toldf if (. not . ok . and . toldx >= zero ) then xmx0 = x - x0 ! to avoid array temporary warning ok = dnrm2 ( n , xmx0 , 1 ) < toldx end if if ( ok ) then mode = converged else mode = not_converged end if end if end function check_convergence !******************************************************************************* !******************************************************************************* !> !  Minimize  || e x - f ||  with respect to x, !  with upper triangular matrix  e = + d &#94;{1/2} l&#94;T , !  and vector  f = -d&#94;{-1/2} l&#94;{-1} g , !  where the unit lower tridiangular matrix l is stored columnwise !  dense in the n*(n+1)/2 array l with vector d stored in its !  'diagonal' thus substituting the one-elements of l ! !  subject to: ! !  *  a(j)*x - b(j) = 0,              j=1,...,meq  , !  *  a(j)*x - b(j) \\ge 0,            j=meq+1,...,m, !  *  x_l(i) \\le x(i) \\le x_u(i),     i=1,...,n    , ! !  On entry, the user has to provide the arrays `l`, `g`, `a`, `b`, `xl`, `xu`. !  with dimensions: `l(n*(n+1)/2)`, `g(n)`, `a(la,n)`, `b(m)`, `xl(n)`, `xu(n)`. ! !  The working array `w` must have at least the following dimension: dim(w) = ! !  * `(3*n+m)*(n+1)`                    for [[lsq]] !  * `+(n-meq+1)*(mineq+2) + 2*mineq`   for [[lsi]] !  * `+(n+mineq)*(n-meq) + 2*meq + n`   for [[lsei]] ! !  with `mineq = m - meq + 2*n` ! !  On return, no array will be changed by the subroutine. ! !### History !  * coded dieter kraft, april 1987 !  * revised march 1989 subroutine lsq ( m , meq , n , nl , la , l , g , a , b , xl , xu , x , y , w , mode , max_iter_ls , nnls_mode , infBnd ) implicit none integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: meq integer , intent ( in ) :: nl integer , intent ( in ) :: la real ( wp ), dimension ( n ) :: x !! stores the n-dimensional solution vector real ( wp ), dimension ( m + n + n ) :: y !! stores the vector of lagrange multipliers of dimension !! m+n+n (constraints+lower+upper bounds) integer :: mode !! is a success-failure flag with the following meanings: !! !! * **1:** successful computation, !! * **2:** error return because of wrong dimensions (`n<1`), !! * **3:** iteration count exceeded by [[nnls]], !! * **4:** inequality constraints incompatible, !! * **5:** matrix `e` is not of full rank, !! * **6:** matrix `c` is not of full rank, !! * **7:** rank defect in [[hfti]] integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use real ( wp ), intent ( in ) :: infbnd !! \"infinity\" for the upper and lower bounds. real ( wp ), dimension ( nl ) :: l real ( wp ), dimension ( n ) :: g real ( wp ), dimension ( la , n ) :: a real ( wp ), dimension ( la ) :: b real ( wp ), dimension ( * ) :: w real ( wp ), dimension ( n ) :: xl real ( wp ), dimension ( n ) :: xu real ( wp ) :: diag , xnorm integer :: i , ic , id , ie , iff , ig , ih , il , ip , & iw , i1 , i2 , i3 , i4 , mineq , & m1 , n1 , n2 , n3 , num_unbounded , j n1 = n + 1 mineq = m - meq m1 = mineq + n + n !  determine whether to solve problem !  with inconsistent linerarization (n2=1) !  or not (n2=0) n2 = n1 * n / 2 + 1 if ( n2 == nl ) then n2 = 0 else n2 = 1 end if n3 = n - n2 !  recover matrix e and vector f from l and g i2 = 1 i3 = 1 i4 = 1 ie = 1 iff = n * n + 1 do i = 1 , n3 i1 = n1 - i diag = sqrt ( l ( i2 )) w ( i3 ) = zero call dcopy ( i1 , w ( i3 ), 0 , w ( i3 ), 1 ) call dcopy ( i1 - n2 , l ( i2 ), 1 , w ( i3 ), n ) call dscal ( i1 - n2 , diag , w ( i3 ), n ) w ( i3 ) = diag w ( iff - 1 + i ) = ( g ( i ) - ddot ( i - 1 , w ( i4 ), 1 , w ( iff ), 1 )) / diag i2 = i2 + i1 - n2 i3 = i3 + n1 i4 = i4 + n end do if ( n2 == 1 ) then w ( i3 ) = l ( nl ) w ( i4 ) = zero call dcopy ( n3 , w ( i4 ), 0 , w ( i4 ), 1 ) w ( iff - 1 + n ) = zero end if call dscal ( n , - one , w ( iff ), 1 ) ic = iff + n id = ic + meq * n if ( meq > 0 ) then !  recover matrix c from upper part of a do i = 1 , meq call dcopy ( n , a ( i , 1 ), la , w ( ic - 1 + i ), meq ) end do !  recover vector d from upper part of b call dcopy ( meq , b ( 1 ), 1 , w ( id ), 1 ) call dscal ( meq , - one , w ( id ), 1 ) end if ig = id + meq if ( mineq > 0 ) then ! recover matrix g from lower part of a ! The matrix G(mineq+2*n,m1) is stored at w(ig) ! Not all rows will be filled if some of the upper/lower ! bounds are unbounded. do i = 1 , mineq call dcopy ( n , a ( meq + i , 1 ), la , w ( ig - 1 + i ), m1 ) end do end if ih = ig + m1 * n iw = ih + mineq + 2 * n if ( mineq > 0 ) then ! recover h from lower part of b ! The vector H(mineq+2*n) is stored at w(ih) call dcopy ( mineq , b ( meq + 1 ), 1 , w ( ih ), 1 ) call dscal ( mineq , - one , w ( ih ), 1 ) end if !  augment matrix g by +i and -i, and, !  augment vector h by xl and xu !  NaN or infBnd value indicates no bound ip = ig + mineq il = ih + mineq num_unbounded = 0 do i = 1 , n if ( ieee_is_nan ( xl ( i )) . or . xl ( i ) <=- infbnd ) then num_unbounded = num_unbounded + 1 else call update_w ( xl ( i ), one ) end if end do do i = 1 , n if ( ieee_is_nan ( xu ( i )) . or . xu ( i ) >= infbnd ) then num_unbounded = num_unbounded + 1 else call update_w ( xu ( i ), - one ) end if end do call lsei ( w ( ic ), w ( id ), w ( ie ), w ( iff ), w ( ig ), w ( ih ), max ( 1 , meq ), meq , n , n , & m1 , m1 - num_unbounded , n , x , xnorm , w ( iw ), mode , max_iter_ls , nnls_mode ) if ( mode == 1 ) then ! restore lagrange multipliers (only for user-defined variables) call dcopy ( m , w ( iw ), 1 , y ( 1 ), 1 ) if ( n3 > 0 ) then !set rest of the multipliers to nan (they are not used) y ( m + 1 ) = ieee_value ( one , ieee_quiet_nan ) do i = m + 2 , m + n3 + n3 y ( i ) = y ( m + 1 ) end do end if call enforce_bounds ( x , xl , xu , infbnd ) ! to ensure that bounds are not violated end if contains subroutine update_w ( val , fact ) real ( wp ), intent ( in ) :: val !! xu(i) or xl(i) real ( wp ), intent ( in ) :: fact !! -1 or 1 w ( il ) = fact * val do j = 1 , n w ( ip + m1 * ( j - 1 )) = zero end do w ( ip + m1 * ( i - 1 )) = fact ip = ip + 1 il = il + 1 end subroutine update_w end subroutine lsq !******************************************************************************* !******************************************************************************* !> !  for `mode=1`, the subroutine returns the solution `x` of !  equality & inequality constrained least squares problem lsei : ! !   \\underset{x}{\\min} ||E x - f||  ! !  s.t.   C x  = d   and  G x \\ge h . ! !  using QR decomposition & orthogonal basis of nullspace of  C . ! !  The following dimensions of the arrays defining the problem !  are necessary: !```` !        dim(c) :   formal (lc,n),    actual (mc,n) !        dim(d) :   formal (lc  ),    actual (mc  ) !        dim(e) :   formal (le,n),    actual (me,n) !        dim(f) :   formal (le  ),    actual (me  ) !        dim(g) :   formal (lg,n),    actual (mg,n) !        dim(h) :   formal (lg  ),    actual (mg  ) !        dim(x) :   formal (n   ),    actual (n   ) !        dim(w) :   2*mc+me+(me+mg)*(n-mc)  for lsei !                 +(n-mc+1)*(mg+2)+2*mg     for lsi !        dim(jw):   max(mg,l) !```` ! !  On entry, the user has to provide the arrays C, d, E, f, G, and h. !  On return, all arrays will be changed by the subroutine. ! !### Reference !  * Chapter 23.6 of Lawson & Hanson: Solving least squares problems. ! !### History !  * 18.5.1981, dieter kraft, dfvlr oberpfaffenhofen !  * 20.3.1987, dieter kraft, dfvlr oberpfaffenhofen subroutine lsei ( c , d , e , f , g , h , lc , mc , le , me , lg , mg , n , x , xnrm , w , mode ,& max_iter_ls , nnls_mode ) implicit none integer , intent ( in ) :: lc integer , intent ( in ) :: mc integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( lc , n ), intent ( inout ) :: c real ( wp ), dimension ( lc ) , intent ( inout ) :: d real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnrm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! on return, stores the vector of lagrange multipliers !! in its first `mc+mg` elements integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank, !! * ***6:*** matrix `c` is not of full rank, !! * ***7:*** rank defect in [[hfti]] integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use integer :: i , ie , if , ig , iw , j , k , krank , l , mc1 real ( wp ) :: t , dum ( 1 ) mode = 2 if ( mc <= n ) then l = n - mc mc1 = mc + 1 iw = ( l + 1 ) * ( mg + 2 ) + 2 * mg + mc ie = iw + mc + 1 if = ie + me * l ig = if + me !  triangularize c and apply factors to e and g do i = 1 , mc j = min ( i + 1 , lc ) call h12 ( 1 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), c ( j , 1 ), lc , 1 , mc - i ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), e , le , 1 , me ) call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), g , lg , 1 , mg ) end do !  solve c*x=d and modify f mode = 6 do i = 1 , mc if ( abs ( c ( i , i )) < epmach ) return x ( i ) = ( d ( i ) - ddot ( i - 1 , c ( i , 1 ), lc , x , 1 )) / c ( i , i ) end do mode = 1 w ( mc1 ) = zero !call dcopy(mg-mc,w(mc1),0,w(mc1),1)  ! original code call dcopy ( mg , w ( mc1 ), 0 , w ( mc1 ), 1 ) ! bug fix for when meq = n if ( mc /= n ) then do i = 1 , me w ( if - 1 + i ) = f ( i ) - ddot ( mc , e ( i , 1 ), le , x , 1 ) end do !  store transformed e & g do i = 1 , me call dcopy ( l , e ( i , mc1 ), le , w ( ie - 1 + i ), me ) end do do i = 1 , mg call dcopy ( l , g ( i , mc1 ), lg , w ( ig - 1 + i ), mg ) end do if ( mg > 0 ) then !  modify h and solve inequality constrained ls problem do i = 1 , mg h ( i ) = h ( i ) - ddot ( mc , g ( i , 1 ), lg , x , 1 ) end do call lsi ( w ( ie ), w ( if ), w ( ig ), h , me , me , mg , mg , l , x ( mc1 ), xnrm , & w ( mc1 ), mode , max_iter_ls , nnls_mode ) if ( mc == 0 ) return t = dnrm2 ( mc , x , 1 ) xnrm = sqrt ( xnrm * xnrm + t * t ) if ( mode /= 1 ) return else ! solve ls without inequality constraints mode = 7 k = max ( le , n ) t = sqrt ( epmach ) call hfti ( w ( ie ), me , me , l , w ( if ), k , 1 , t , krank , dum , w , w ( l + 1 )) xnrm = dum ( 1 ) call dcopy ( l , w ( if ), 1 , x ( mc1 ), 1 ) if ( krank /= l ) return mode = 1 end if end if !  solution of original problem and lagrange multipliers do i = 1 , me f ( i ) = ddot ( n , e ( i , 1 ), le , x , 1 ) - f ( i ) end do do i = 1 , mc d ( i ) = ddot ( me , e ( 1 , i ), 1 , f , 1 ) & - ddot ( mg , g ( 1 , i ), 1 , w ( mc1 ), 1 ) end do do i = mc , 1 , - 1 call h12 ( 2 , i , i + 1 , n , c ( i , 1 ), lc , w ( iw + i ), x , 1 , 1 , 1 ) end do do i = mc , 1 , - 1 j = min ( i + 1 , lc ) w ( i ) = ( d ( i ) - ddot ( mc - i , c ( j , i ), 1 , w ( j ), 1 )) / c ( i , i ) end do end if end subroutine lsei !******************************************************************************* !******************************************************************************* !> !  for `mode=1`, the subroutine returns the solution `x` of !  inequality constrained linear least squares problem: ! !   \\underset{x}{\\min} ||E x - f||  ! !  s.t.  G x \\ge h . ! !  the following dimensions of the arrays defining the problem !  are necessary: !```` !     dim(e) :   formal (le,n),    actual (me,n) !     dim(f) :   formal (le  ),    actual (me  ) !     dim(g) :   formal (lg,n),    actual (mg,n) !     dim(h) :   formal (lg  ),    actual (mg  ) !     dim(x) :   n !     dim(w) :   (n+1)*(mg+2) + 2*mg !     dim(jw):   lg !```` ! !  on entry, the user has to provide the arrays `e`, `f`, `g`, and `h`. !  on return, all arrays will be changed by the subroutine. ! !### Reference !  * Chapter 23.6 of Lawson & Hanson: Solving least squares problems. ! !### History !  * 03.01.1980, dieter kraft: coded !  * 20.03.1987, dieter kraft: revised to fortran 77 subroutine lsi ( e , f , g , h , le , me , lg , mg , n , x , xnorm , w , mode , max_iter_ls , nnls_mode ) implicit none integer , intent ( in ) :: le integer , intent ( in ) :: me integer , intent ( in ) :: lg integer , intent ( in ) :: mg integer , intent ( in ) :: n real ( wp ), dimension ( le , n ), intent ( inout ) :: e real ( wp ), dimension ( le ) , intent ( inout ) :: f real ( wp ), dimension ( lg , n ), intent ( inout ) :: g real ( wp ), dimension ( lg ) , intent ( inout ) :: h real ( wp ), dimension ( n ) , intent ( out ) :: x !! stores the solution vector real ( wp ), intent ( out ) :: xnorm !! stores the residuum of the solution in euclidian norm real ( wp ), dimension ( * ) , intent ( inout ) :: w !! stores the vector of lagrange multipliers in its first !! `mg` elements integer , intent ( out ) :: mode !! is a success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<1`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible, !! * ***5:*** matrix `e` is not of full rank. integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use integer :: i , j real ( wp ) :: t !  qr-factors of e and application to f do i = 1 , n j = min ( i + 1 , n ) call h12 ( 1 , i , i + 1 , me , e ( 1 , i ), 1 , t , e ( 1 , j ), 1 , le , n - i ) call h12 ( 2 , i , i + 1 , me , e ( 1 , i ), 1 , t , f , 1 , 1 , 1 ) end do !  transform g and h to get least distance problem mode = 5 do i = 1 , mg do j = 1 , n if ( abs ( e ( j , j )) < epmach . or . ieee_is_nan ( e ( j , j ))) return g ( i , j ) = ( g ( i , j ) - ddot ( j - 1 , g ( i , 1 ), lg , e ( 1 , j ), 1 )) / e ( j , j ) end do h ( i ) = h ( i ) - ddot ( n , g ( i , 1 ), lg , f , 1 ) end do !  solve least distance problem call ldp ( g , lg , mg , n , h , x , xnorm , w , mode , max_iter_ls , nnls_mode ) if ( mode == 1 ) then !  solution of original problem call daxpy ( n , one , f , 1 , x , 1 ) do i = n , 1 , - 1 j = min ( i + 1 , n ) x ( i ) = ( x ( i ) - ddot ( n - i , e ( i , j ), le , x ( j ), 1 )) / e ( i , i ) end do j = min ( n + 1 , me ) t = dnrm2 ( me - n , f ( j ), 1 ) xnorm = sqrt ( xnorm * xnorm + t * t ) end if end subroutine lsi !******************************************************************************* !******************************************************************************* !> !  Least distance programming routine. !  Minimize  \\frac{1}{2} \\mathbf{x}&#94;T \\mathbf{x}   subject to !   \\mathbf{G} \\mathbf{x} \\ge \\mathbf{h} . ! !  The declared dimension of `w` must be at least `(n+1)*(m+2)+2*m`: !```` !       first (n+1)*m locs of w = matrix e for problem nnls. !       next      n+1 locs of w = vector f for problem nnls. !       next      n+1 locs of w = vector z for problem nnls. !       next        m locs of w = vector y for problem nnls. !       next        m locs of w = vector wdual for problem nnls. !```` ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. ! !@note The 1995 version of this routine may have some sort of problem. !      Using a refactored version of the original routine. subroutine ldp ( g , mg , m , n , h , x , xnorm , w , mode , max_iter_ls , nnls_mode ) implicit none integer , intent ( in ) :: mg integer , intent ( in ) :: m integer , intent ( in ) :: n real ( wp ), dimension ( mg , n ), intent ( in ) :: g !! on entry `g` stores the `m` by `n` matrix of !! linear inequality constraints. `g` has first !! dimensioning parameter `mg` real ( wp ), dimension ( m ), intent ( in ) :: h !! the right side of the inequality system. real ( wp ), dimension ( n ), intent ( out ) :: x !! solution vector `x` if `mode=1`. real ( wp ), dimension ( * ), intent ( inout ) :: w !! `w` is a one dimensional working space, the length !! of which should be at least `(m+2)*(n+1) + 2*m`. !! on exit `w` stores the lagrange multipliers !! associated with the constraints. !! at the solution of problem `ldp`. real ( wp ), intent ( out ) :: xnorm !! euclidian norm of the solution vector !! if computation is successful integer , intent ( out ) :: mode !! success-failure flag with the following meanings: !! !! * ***1:*** successful computation, !! * ***2:*** error return because of wrong dimensions (`n<=0`), !! * ***3:*** iteration count exceeded by [[nnls]], !! * ***4:*** inequality constraints incompatible. integer , intent ( in ) :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ) :: nnls_mode !! which NNLS method to use integer :: i , iw , iwdual , iy , iz , j , jf , n1 real ( wp ) :: fac , rnorm if ( n <= 0 ) then ! error return. mode = 2 else ! state dual problem mode = 1 x = zero xnorm = zero if ( m /= 0 ) then iw = 0 do j = 1 , m do i = 1 , n iw = iw + 1 w ( iw ) = g ( j , i ) end do iw = iw + 1 w ( iw ) = h ( j ) end do jf = iw + 1 do i = 1 , n iw = iw + 1 w ( iw ) = zero end do w ( iw + 1 ) = one n1 = n + 1 iz = iw + 2 iy = iz + n1 iwdual = iy + m ! solve dual problem select case ( nnls_mode ) case ( 1 ) ! original call nnls ( w , n1 , n1 , m , w ( jf ), w ( iy ), rnorm , w ( iwdual ), w ( iz ), mode , max_iter_ls ) case ( 2 ) ! new version call bvls_wrapper ( w , n1 , n1 , m , w ( jf ), w ( iy ), rnorm , w ( iwdual ), w ( iz ), mode , max_iter_ls ) case default error stop 'invalid nnls_mode' end select if ( mode == 1 ) then mode = 4 if ( rnorm > zero ) then !  compute solution of primal problem fac = one - ddot ( m , h , 1 , w ( iy ), 1 ) if ( ieee_is_nan ( fac )) return if ( fac >= eps ) then mode = 1 fac = one / fac do j = 1 , n x ( j ) = fac * ddot ( m , g ( 1 , j ), 1 , w ( iy ), 1 ) end do xnorm = dnrm2 ( n , x , 1 ) ! compute lagrange multipliers for primal problem w ( 1 ) = zero call dcopy ( m , w ( 1 ), 0 , w , 1 ) call daxpy ( m , fac , w ( iy ), 1 , w , 1 ) end if end if end if end if end if end subroutine ldp !******************************************************************************* !******************************************************************************* !> !  Nonnegative least squares algorithm. ! !  Given an m by n matrix, \\mathbf{A}, and an m-vector, \\mathbf{b}, !  compute an n-vector, \\mathbf{x}, that solves the least squares problem: ! !   \\mathbf{A} \\mathbf{x} = \\mathbf{b} subject to  \\mathbf{x} \\ge 0  ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine nnls ( a , mda , m , n , b , x , rnorm , w , zz , mode , max_iter ) implicit none integer , intent ( in ) :: mda !! first dimensioning parameter for the array `a`. integer , intent ( in ) :: n real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! on entry, contains the `m` by `n` !! matrix, `a`. on exit, contains !! the product matrix, `q*a`, where `q` is an !! `m` by `m` orthogonal matrix generated implicitly by !! this subroutine. integer , intent ( in ) :: m real ( wp ), dimension ( m ), intent ( inout ) :: b !! on entry, contains the m-vector `b`. on exit, contains `q*b`. real ( wp ), dimension ( n ), intent ( out ) :: x !! the solution vector. real ( wp ), intent ( out ) :: rnorm !! euclidean norm of the residual vector. real ( wp ), dimension ( n ), intent ( inout ) :: w !! array of working space.  on exit `w` will contain !! the dual solution vector. `w` will satisfy `w(i) = 0` !! for all `i` in set `p` and `w(i) <= 0` for all `i` in set `z`. real ( wp ), dimension ( m ), intent ( inout ) :: zz !! an m-array of working space. integer , intent ( out ) :: mode !! this is a success-failure flag with the following meanings: !! !! * ***1*** the solution has been computed successfully. !! * ***2*** the dimensions of the problem are bad. either `m<=0` or `n<=0`. !! * ***3*** iteration count exceeded. more than `3*n` iterations. integer , intent ( in ) :: max_iter !! maximum number of iterations (if <=0, then `3*n` is used) integer :: i , ii , ip , iter , itmax , iz , iz1 , iz2 , izmax , j , jj , jz , l , npp1 , nsetp , rtnkey real ( wp ) :: alpha , asave , cc , sm , ss , t , temp , unorm , up , wmax , ztest real ( wp ), dimension ( 1 ) :: dummy integer , dimension ( n ) :: index !! an integer working array. !! the contents of this array define the sets !! `p` and `z` as follows: !! !! * `index(1:nsetp) = set p`. !! * `index(iz1:iz2) = set z`. !! !! where: `iz1 = nsetp + 1 = npp1`, `iz2 = n` real ( wp ), parameter :: factor = 0.01_wp mode = 1 if ( m <= 0 . or . n <= 0 ) then mode = 2 return end if iter = 0 if ( max_iter <= 0 ) then itmax = 3 * n else itmax = max_iter end if ! initialize the arrays index(1:n) and x(1:n). x = zero index = [( i , i = 1 , n )] iz2 = n iz1 = 1 nsetp = 0 npp1 = 1 main : do ! ******  main loop begins here  ****** ! quit if all coefficients are already in the solution. ! or if m cols of a have been triangularized. if ( iz1 <= iz2 . and . nsetp < m ) then ! compute components of the dual (negative gradient) vector w(). do iz = iz1 , iz2 j = index ( iz ) sm = zero do l = npp1 , m sm = sm + a ( l , j ) * b ( l ) end do w ( j ) = sm end do do ! find largest positive w(j). wmax = zero do iz = iz1 , iz2 j = index ( iz ) if ( w ( j ) > wmax ) then wmax = w ( j ) izmax = iz end if end do ! if wmax <= 0. go to termination. ! this indicates satisfaction of the kuhn-tucker conditions. if ( wmax <= zero ) then call termination () return end if iz = izmax j = index ( iz ) ! the sign of w(j) is ok for j to be moved to set p. ! begin the transformation and check new diagonal element to avoid ! near linear dependence. asave = a ( npp1 , j ) call h12 ( 1 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , dummy , 1 , 1 , 0 ) unorm = zero if ( nsetp /= 0 ) then do l = 1 , nsetp unorm = unorm + a ( l , j ) ** 2 end do end if unorm = sqrt ( unorm ) if ( abs ( a ( npp1 , j )) * factor >= unorm * eps ) then ! col j is sufficiently independent.  copy b into zz, update zz ! and solve for ztest ( = proposed new value for x(j) ). do l = 1 , m zz ( l ) = b ( l ) end do call h12 ( 2 , npp1 , npp1 + 1 , m , a ( 1 , j ), 1 , up , zz , 1 , 1 , 1 ) ztest = zz ( npp1 ) / a ( npp1 , j ) ! see if ztest is positive if ( ztest > zero ) then ! the index j=index(iz) has been selected to be moved from ! set z to set p. update b, update indices, apply householder ! transformations to cols in new set z, zero subdiagonal elts in ! col j, set w(j)=0. do l = 1 , m b ( l ) = zz ( l ) end do index ( iz ) = index ( iz1 ) index ( iz1 ) = j iz1 = iz1 + 1 nsetp = npp1 npp1 = npp1 + 1 if ( iz1 <= iz2 ) then do jz = iz1 , iz2 jj = index ( jz ) call h12 ( 2 , nsetp , npp1 , m , a ( 1 , j ), 1 , up , a ( 1 , jj ), 1 , mda , 1 ) end do end if if ( nsetp /= m ) then do l = npp1 , m a ( l , j ) = zero end do end if w ( j ) = zero ! solve the triangular system. ! store the solution temporarily in zz(). rtnkey = 1 exit end if end if ! reject j as a candidate to be moved from set z to set p. ! restore a(npp1,j), set w(j)=0., and loop back to test dual ! coeffs again. a ( npp1 , j ) = asave w ( j ) = zero end do else call termination () return end if ! ******  end of main loop  ****** secondary : do ! the following block of code is used as an internal subroutine ! to solve the triangular system, putting the solution in zz(). do l = 1 , nsetp ip = nsetp + 1 - l if ( l /= 1 ) then do ii = 1 , ip zz ( ii ) = zz ( ii ) - a ( ii , jj ) * zz ( ip + 1 ) end do end if jj = index ( ip ) zz ( ip ) = zz ( ip ) / a ( ip , jj ) end do if ( rtnkey /= 1 . and . rtnkey /= 2 ) return ! ******  secondary loop begins here ****** ! iteration counter. iter = iter + 1 if ( iter > itmax ) then mode = 3 !write (*,'(/a)') ' nnls quitting on iteration count.' call termination () return end if ! see if all new constrained coeffs are feasible. ! if not compute alpha. alpha = two do ip = 1 , nsetp l = index ( ip ) if ( zz ( ip ) <= zero ) then t = - x ( l ) / ( zz ( ip ) - x ( l )) if ( alpha > t ) then alpha = t jj = ip end if end if end do ! if all new constrained coeffs are feasible then alpha will ! still = 2.    if so exit from secondary loop to main loop. if ( abs ( alpha - two ) <= zero ) then ! ******  end of secondary loop  ****** do ip = 1 , nsetp i = index ( ip ) x ( i ) = zz ( ip ) end do ! all new coeffs are positive.  loop back to beginning. cycle main end if ! otherwise use alpha which will be between 0. and 1. to ! interpolate between the old x and the new zz. do ip = 1 , nsetp l = index ( ip ) x ( l ) = x ( l ) + alpha * ( zz ( ip ) - x ( l )) end do ! modify a and b and the index arrays to move coefficient i ! from set p to set z. i = index ( jj ) move_p : do x ( i ) = zero if ( jj /= nsetp ) then jj = jj + 1 do j = jj , nsetp ii = index ( j ) index ( j - 1 ) = ii call g1 ( a ( j - 1 , ii ), a ( j , ii ), cc , ss , a ( j - 1 , ii )) a ( j , ii ) = zero do l = 1 , n if ( l /= ii ) then ! apply procedure g2 (cc,ss,a(j-1,l),a(j,l)) temp = a ( j - 1 , l ) a ( j - 1 , l ) = cc * temp + ss * a ( j , l ) a ( j , l ) = - ss * temp + cc * a ( j , l ) end if end do ! apply procedure g2 (cc,ss,b(j-1),b(j)) temp = b ( j - 1 ) b ( j - 1 ) = cc * temp + ss * b ( j ) b ( j ) = - ss * temp + cc * b ( j ) end do end if npp1 = nsetp nsetp = nsetp - 1 iz1 = iz1 - 1 index ( iz1 ) = i ! see if the remaining coeffs in set p are feasible.  they should ! be because of the way alpha was determined. ! if any are infeasible it is due to round-off error.  any ! that are nonpositive will be set to zero ! and moved from set p to set z. do jj = 1 , nsetp i = index ( jj ) if ( x ( i ) <= zero ) cycle move_p end do exit move_p end do move_p ! copy b( ) into zz( ).  then solve again and loop back. do i = 1 , m zz ( i ) = b ( i ) end do rtnkey = 2 end do secondary end do main contains subroutine termination () !! come to here for termination. !! compute the norm of the final residual vector. sm = zero if ( npp1 <= m ) then do i = npp1 , m sm = sm + b ( i ) ** 2 end do else do j = 1 , n w ( j ) = zero end do end if rnorm = sqrt ( sm ) end subroutine termination end subroutine nnls !******************************************************************************* !******************************************************************************* !> !  Rank-deficient least squares algorithm using !  householder forward triangulation with column interchanges. ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine hfti ( a , mda , m , n , b , mdb , nb , tau , krank , rnorm , h , g ) implicit none integer , intent ( in ) :: mda !! the first dimensioning parameter of matrix `a` (mda >= m). integer , intent ( in ) :: m integer , intent ( in ) :: n integer , intent ( in ) :: mdb !! first dimensioning parameter of matrix `b` (mdb>=max(m,n)) integer , intent ( in ) :: nb real ( wp ), dimension ( mda , n ), intent ( inout ) :: a !! the array `a` initially contains the  m \\times n  matrix \\mathbf{A} !! of the least squares problem  \\mathbf{A} \\mathbf{x} = \\mathbf{b} . !! either `m >= n` or `m < n` is permitted. !! there is no restriction on the rank of `a`. !! the matrix `a` will be modified by the subroutine. real ( wp ), intent ( in ) :: tau !! absolute tolerance parameter for pseudorank !! determination, provided by the user. integer , intent ( out ) :: krank !! pseudorank of `a`, set by the subroutine. real ( wp ), dimension ( nb ), intent ( out ) :: rnorm !! on exit, `rnorm(j)` will contain the euclidian !! norm of the residual vector for the problem !! defined by the `j-th` column vector of the array `b`. real ( wp ), dimension ( n ), intent ( inout ) :: h !! array of working space real ( wp ), dimension ( n ), intent ( inout ) :: g !! array of working space real ( wp ), dimension ( mdb , nb ), intent ( inout ) :: b !! if `nb = 0` the subroutine will make no reference !! to the array `b`. if `nb > 0` the array `b` must !! initially contain the `m x nb` matrix `b` of the !! the least squares problem `ax = b` and on return !! the array `b` will contain the `n x nb` solution `x`. integer :: i , ii , ip1 , j , jb , jj , k , kp1 , l , ldiag , lmax real ( wp ) :: hmax , sm , tmp logical :: need_lmax integer , dimension ( n ) :: ip !! integer array of working space !! recording permutation indices of column vectors real ( wp ), parameter :: factor = 0.001_wp k = 0 ldiag = min ( m , n ) if ( ldiag <= 0 ) then ! the solution vectors, x, are now ! in the first  n  rows of the array b(,). krank = k return else do j = 1 , ldiag need_lmax = . true . if ( j /= 1 ) then ! update squared column lengths and find lmax lmax = j do l = j , n h ( l ) = h ( l ) - a ( j - 1 , l ) ** 2 if ( h ( l ) > h ( lmax ) ) lmax = l end do if ( factor * h ( lmax ) >= hmax * eps ) need_lmax = . false . end if if ( need_lmax ) then ! compute squared column lengths and find lmax lmax = j do l = j , n h ( l ) = zero do i = j , m h ( l ) = h ( l ) + a ( i , l ) ** 2 end do if ( h ( l ) > h ( lmax ) ) lmax = l end do hmax = h ( lmax ) end if ! lmax has been determined ! do column interchanges if needed. ip ( j ) = lmax if ( ip ( j ) /= j ) then do i = 1 , m tmp = a ( i , j ) a ( i , j ) = a ( i , lmax ) a ( i , lmax ) = tmp end do h ( lmax ) = h ( j ) end if ! compute the j-th transformation and apply it to a and b. call h12 ( 1 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), a ( 1 , j + 1 ), 1 , mda , n - j ) call h12 ( 2 , j , j + 1 , m , a ( 1 , j ), 1 , h ( j ), b , 1 , mdb , nb ) end do ! determine the pseudorank, k, using the tolerance, tau. do j = 1 , ldiag if ( abs ( a ( j , j )) <= tau ) exit end do k = j - 1 kp1 = j end if ! compute the norms of the residual vectors. if ( nb > 0 ) then do jb = 1 , nb tmp = zero if ( kp1 <= m ) then do i = kp1 , m tmp = tmp + b ( i , jb ) ** 2 end do end if rnorm ( jb ) = sqrt ( tmp ) end do end if ! special for pseudorank = 0 if ( k > 0 ) then ! if the pseudorank is less than n compute householder ! decomposition of first k rows. if ( k /= n ) then do ii = 1 , k i = kp1 - ii call h12 ( 1 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), a , mda , 1 , i - 1 ) end do end if if ( nb > 0 ) then do jb = 1 , nb ! solve the k by k triangular system. do l = 1 , k sm = zero i = kp1 - l if ( i /= k ) then ip1 = i + 1 do j = ip1 , k sm = sm + a ( i , j ) * b ( j , jb ) end do end if b ( i , jb ) = ( b ( i , jb ) - sm ) / a ( i , i ) end do ! complete computation of solution vector. if ( k /= n ) then do j = kp1 , n b ( j , jb ) = zero end do do i = 1 , k call h12 ( 2 , i , kp1 , n , a ( i , 1 ), mda , g ( i ), b ( 1 , jb ), 1 , mdb , 1 ) end do end if ! re-order the solution vector to compensate for the ! column interchanges. do jj = 1 , ldiag j = ldiag + 1 - jj if ( ip ( j ) /= j ) then l = ip ( j ) tmp = b ( l , jb ) b ( l , jb ) = b ( j , jb ) b ( j , jb ) = tmp end if end do end do end if else if ( nb > 0 ) then do jb = 1 , nb do i = 1 , n b ( i , jb ) = zero end do end do end if krank = k end subroutine hfti !******************************************************************************* !******************************************************************************* !> !  Construction and/or application of a single !  householder transformation  Q = I + u(u&#94;t)/b . ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine h12 ( mode , lpivot , l1 , m , u , iue , up , c , ice , icv , ncv ) implicit none integer , intent ( in ) :: mode !! `1` or `2` -- selects algorithm ***h1*** to construct and apply a !! householder transformation, or algorithm ***h2*** to apply a !! previously constructed transformation. integer , intent ( in ) :: lpivot !! the index of the pivot element integer , intent ( in ) :: l1 !! if `l1 <= m` the transformation will be constructed to !! zero elements indexed from `l1` through `m`. !! if `l1 > m` the subroutine does an identity transformation. integer , intent ( in ) :: m !! see `li`. integer , intent ( in ) :: iue !! see `u`. real ( wp ), dimension ( iue , * ), intent ( inout ) :: u !! on entry with `mode = 1`, `u` contains the pivot !! vector.  `iue` is the storage increment between elements. !! on exit when `mode = 1`, `u` and `up` contain quantities !! defining the vector `u` of the householder transformation. !! on entry with `mode = 2`, `u` and `up` should contain !! quantities previously computed with `mode = 1`.  these will !! not be modified during the entry with `mode = 2`. !! `dimension[u(iue,m)]` real ( wp ), intent ( inout ) :: up !! see `u`. real ( wp ), dimension ( * ), intent ( inout ) :: c !! on entry with `mode = 1 or 2`, `c` contains a matrix which !! will be regarded as a set of vectors to which the !! householder transformation is to be applied. !! on exit `c` contains the set of transformed vectors. integer , intent ( in ) :: ice !! storage increment between elements of vectors in `c`. integer , intent ( in ) :: icv !! storage increment between vectors in `c`. integer , intent ( in ) :: ncv !! number of vectors in `c` to be transformed. if `ncv <= 0` !! no operations will be done on `c`. integer :: i , i2 , i3 , i4 , incr , j real ( wp ) :: b , cl , clinv , sm if ( 0 >= lpivot . or . lpivot >= l1 . or . l1 > m ) return cl = abs ( u ( 1 , lpivot )) if ( mode /= 2 ) then ! construct the transformation. do j = l1 , m cl = max ( abs ( u ( 1 , j )), cl ) end do if ( cl <= zero ) return clinv = one / cl sm = ( u ( 1 , lpivot ) * clinv ) ** 2 do j = l1 , m sm = sm + ( u ( 1 , j ) * clinv ) ** 2 end do cl = cl * sqrt ( sm ) if ( u ( 1 , lpivot ) > zero ) cl = - cl up = u ( 1 , lpivot ) - cl u ( 1 , lpivot ) = cl else if ( cl <= zero ) then return end if if ( ncv > 0 ) then ! apply the transformation i+u*(u**t)/b to c. b = up * u ( 1 , lpivot ) ! b must be nonpositive here. if ( b < zero ) then b = one / b i2 = 1 - icv + ice * ( lpivot - 1 ) incr = ice * ( l1 - lpivot ) do j = 1 , ncv i2 = i2 + icv i3 = i2 + incr i4 = i3 sm = c ( i2 ) * up do i = l1 , m sm = sm + c ( i3 ) * u ( 1 , i ) i3 = i3 + ice end do if ( abs ( sm ) > zero ) then sm = sm * b c ( i2 ) = c ( i2 ) + sm * up do i = l1 , m c ( i4 ) = c ( i4 ) + sm * u ( 1 , i ) i4 = i4 + ice end do end if end do end if end if end subroutine h12 !******************************************************************************* !******************************************************************************* !> !  Compute orthogonal rotation matrix. ! !  Compute matrix  \\left[ \\begin{array}{cc} c & s \\\\ -s & c \\end{array} \\right]  !  so that ! !   !  \\left[ \\begin{array}{cc} c & s \\\\ -s & c \\end{array} \\right] !  \\left[ \\begin{array}{c} a \\\\ b \\end{array} \\right]  = !  \\left[ \\begin{array}{c} \\sqrt{a&#94;2+b&#94;2} \\\\ 0 \\end{array} \\right] !   ! !  Compute  \\sigma = \\sqrt{a&#94;2+b&#94;2}  ! !   \\sigma  is computed last to allow for the possibility that !  `sig` may be in the same location as `a` or `b`. ! !### References !  * C.L. Lawson, R.J. Hanson, 'Solving least squares problems' !    Prentice Hall, 1974. (revised 1995 edition) !  * [lawson-hanson](http://www.netlib.org/lawson-hanson/all) from Netlib. ! !### History !  * Jacob Williams, refactored into modern Fortran, Jan. 2016. subroutine g1 ( a , b , c , s , sig ) implicit none real ( wp ) :: a real ( wp ) :: b real ( wp ) :: sig real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s real ( wp ) :: xr , yr if ( abs ( a ) > abs ( b ) ) then xr = b / a yr = sqrt ( one + xr ** 2 ) c = sign ( one / yr , a ) s = c * xr sig = abs ( a ) * yr else if ( abs ( b ) > zero ) then xr = a / b yr = sqrt ( one + xr ** 2 ) s = sign ( one / yr , b ) c = s * xr sig = abs ( b ) * yr else sig = zero c = zero s = one end if end if end subroutine g1 !******************************************************************************* !******************************************************************************* !> !  LDL&#94;T - rank-one - update ! !### Purpose: ! !  Updates the LDL&#94;T factors of matrix A !  by rank-one matrix \\sigma z z&#94;T . ! !### Reference !  * R. Fletcher, M.J.D. Powell, !    \"[On the modification of LDL' factorization](http://www.ams.org/journals/mcom/1974-28-128/S0025-5718-1974-0359297-1/S0025-5718-1974-0359297-1.pdf)\". !    Mathematics of Computation Vol. 28, No. 128, p. 1067-1087, October 1974. ! !### History !  * D. Kraft, DFVLR - institut fuer dynamik der flugsysteme !    d-8031  oberpfaffenhofen !  * Status: 15. january 1980 subroutine ldl ( n , a , z , sigma , w ) implicit none integer , intent ( in ) :: n !! order of the coefficient matrix `a` real ( wp ), intent ( in ) :: sigma !! scalar factor by which the modifying dyade z z&#94;T is multiplied. real ( wp ), dimension ( * ), intent ( inout ) :: a !! ***In:*** positive definite matrix of dimension `n`; !! only the lower triangle is used and is stored column by !! column as one dimensional array of dimension `n*(n+1)/2`. !! !! ***Out:*** updated LDL&#94;T factors real ( wp ), dimension ( * ), intent ( inout ) :: w !! working array of dimension `n` (used only if  \\sigma \\lt 0  ). real ( wp ), dimension ( * ), intent ( inout ) :: z !! vector of dimension `n` of updating elements. integer :: i , ij , j real ( wp ) :: t , v , u , tp , beta , alpha , delta , gamma if ( abs ( sigma ) > zero ) then ij = 1 t = one / sigma if ( sigma <= zero ) then ! prepare negative update do i = 1 , n w ( i ) = z ( i ) end do do i = 1 , n v = w ( i ) t = t + v * v / a ( ij ) do j = i + 1 , n ij = ij + 1 w ( j ) = w ( j ) - v * a ( ij ) end do ij = ij + 1 end do if ( t >= zero ) t = epmach / sigma do i = 1 , n j = n + 1 - i ij = ij - i u = w ( j ) w ( j ) = t t = t - u * u / a ( ij ) end do end if ! here updating begins do i = 1 , n v = z ( i ) delta = v / a ( ij ) if ( sigma < zero ) tp = w ( i ) if ( sigma > zero ) tp = t + delta * v alpha = tp / t a ( ij ) = alpha * a ( ij ) if ( i == n ) return beta = delta / tp if ( alpha > four ) then gamma = t / tp do j = i + 1 , n ij = ij + 1 u = a ( ij ) a ( ij ) = gamma * u + beta * z ( j ) z ( j ) = z ( j ) - v * u end do else do j = i + 1 , n ij = ij + 1 z ( j ) = z ( j ) - v * a ( ij ) a ( ij ) = a ( ij ) + beta * z ( j ) end do end if ij = ij + 1 t = tp end do end if end subroutine ldl !******************************************************************************* !******************************************************************************* !> !  Linesearch without derivatives (used by [[slsqp]] if `linesearch_mode=2`). !  Returns the abscissa approximating the point where `f` attains a minimum. ! !### purpose: ! !  to find the argument linmin where the function `f` takes it's minimum !  on the interval `ax`, `bx`. It uses a combination of golden section !  and successive quadratic interpolation. ! !### Reference ! !  This function subprogram is a slightly modified version of the !  ALGOL 60 procedure `localmin` given in R.P. Brent: !  \"[Algorithms for minimization without derivatives](https://maths-people.anu.edu.au/~brent/pub/pub011.html)\", !  Prentice-Hall (1973). ! !### History ! !  * Kraft, D., DFVLR - institut fuer dynamik der flugsysteme !    d-8031  oberpfaffenhofen !  * status: 31. august 1984 !  * Jacob Williams, Jan 2016, Refactored into modern Fortran. !    Added saved variables as `inout`s to make the routine thread-safe. real ( wp ) function linmin ( mode , ax , bx , f , tol ,& a , b , d , e , p , q , r , u , v ,& w , x , m , fu , fv , fw , fx , tol1 , tol2 ) implicit none integer , intent ( inout ) :: mode !! controls reverse communication !! must be set to 0 initially, returns with intermediate !! values 1 and 2 which must not be changed by the user, !! ends with convergence with value 3. real ( wp ) :: f !! function value at `linmin` which is to be brought in by !! reverse communication controlled by `mode` real ( wp ), intent ( in ) :: tol !! desired length of interval of uncertainty of final result real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( inout ) :: a , b , d , e , p , q , r , u , v , w , x , m , fu , fv , fw , fx , tol1 , tol2 real ( wp ), parameter :: c = ( 3.0_wp - sqrt ( 5.0_wp )) / 2.0_wp !! golden section ratio = `0.381966011` real ( wp ), parameter :: sqrteps = sqrt ( eps ) !! square root of machine precision select case ( mode ) case ( 1 ) ! main loop starts here fx = f fv = fx fw = fv case ( 2 ) fu = f ! update a, b, v, w, and x if ( fu > fx ) then if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . abs ( w - x ) <= zero ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . abs ( v - x ) <= zero . or . abs ( v - w ) <= zero ) then v = u fv = fu end if else if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu end if case default ! initialization a = ax b = bx e = zero v = a + c * ( b - a ) w = v x = w linmin = x mode = 1 return end select m = 0.5_wp * ( a + b ) tol1 = sqrteps * abs ( x ) + tol tol2 = tol1 + tol1 ! test convergence if ( abs ( x - m ) <= tol2 - 0.5_wp * ( b - a ) ) then ! end of main loop linmin = x mode = 3 else r = zero q = r p = q if ( abs ( e ) > tol1 ) then ! fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = q - r q = q + q if ( q > zero ) p = - p if ( q < zero ) q = - q r = e e = d end if ! is parabola acceptable if ( abs ( p ) >= 0.5_wp * abs ( q * r ) . or . p <= q * ( a - x ) . or . p >= q * ( b - x ) ) then ! golden section step if ( x >= m ) e = a - x if ( x < m ) e = b - x d = c * e else ! parabolic interpolation step d = p / q ! f must not be evaluated too close to a or b if ( u - a < tol2 ) d = sign ( tol1 , m - x ) if ( b - u < tol2 ) d = sign ( tol1 , m - x ) end if ! f must not be evaluated too close to x if ( abs ( d ) < tol1 ) d = sign ( tol1 , d ) u = x + d linmin = u mode = 2 end if end function linmin !******************************************************************************* !******************************************************************************* !> !  enforce the bound constraints on `x`. subroutine enforce_bounds ( x , xl , xu , infbnd ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( in ) :: xl !! lower bounds (must be same dimension as `x`) real ( wp ), dimension (:), intent ( in ) :: xu !! upper bounds (must be same dimension as `x`) real ( wp ), intent ( in ) :: infbnd !! \"infinity\" for the upper and lower bounds. !! Note that `NaN` may also be used to indicate no bound. where ( x < xl . and . xl >- infbnd . and . . not . ieee_is_nan ( xl )) x = xl elsewhere ( x > xu . and . xu < infbnd . and . . not . ieee_is_nan ( xu )) x = xu end where end subroutine enforce_bounds !******************************************************************************* !******************************************************************************* !> !  Destructor for [[slsqpb_data]] type. subroutine destroy_slsqpb_data ( me ) implicit none class ( slsqpb_data ), intent ( out ) :: me end subroutine destroy_slsqpb_data !******************************************************************************* !******************************************************************************* !> !  Destructor for [[linmin_data]] type. subroutine destroy_linmin_data ( me ) implicit none class ( linmin_data ), intent ( out ) :: me end subroutine destroy_linmin_data !******************************************************************************* !******************************************************************************* end module slsqp_core !*******************************************************************************","tags":"","url":"sourcefile/slsqp_core.f90.html"},{"title":"bvls_module.f90 – slsqp","text":"This file depends on sourcefile~~bvls_module.f90~~EfferentGraph sourcefile~bvls_module.f90 bvls_module.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.F90 sourcefile~bvls_module.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_support.f90 slsqp_support.F90 sourcefile~bvls_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~bvls_module.f90~~AfferentGraph sourcefile~bvls_module.f90 bvls_module.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~bvls_module.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Module for [[bvls]]. ! !### History !  * Original code from http://www.netlib.org/lawson-hanson/all !  * Jacob Williams, Nov 2018 : refactored into a module. some code cleanup. module bvls_module use slsqp_kinds , only : wp use slsqp_support , only : zero , one , two implicit none private public :: bvls ! main routine public :: bvls_wrapper ! a wrapper with the same interface as nnls contains !******************************************************************************* !******************************************************************************* !> !  Call [[bvls]], but matching the interface of the old [[nnls]]. subroutine bvls_wrapper ( a , mda , m , n , b , x , rnorm , w , zz , mode , max_iter ) implicit none integer , intent ( in ) :: mda integer , intent ( in ) :: n real ( wp ), dimension ( mda , n ), intent ( inout ) :: a integer , intent ( in ) :: m real ( wp ), dimension ( m ), intent ( inout ) :: b real ( wp ), dimension ( n ), intent ( out ) :: x real ( wp ), intent ( out ) :: rnorm real ( wp ), dimension ( n ), intent ( inout ) :: w real ( wp ), dimension ( m ), intent ( inout ) :: zz integer , intent ( out ) :: mode integer , intent ( in ) :: max_iter !! maximum number of iterations !! (if <=0, then `3*n` is used) integer , dimension ( n ) :: index integer :: ierr integer :: nsetp real ( wp ), dimension ( 2 , n ) :: bnd !! BND(1,J) is the lower bound for X(J). !! BND(2,J) is the upper bound for X(J). ! set bounds for nnls: bnd ( 1 ,:) = 0.0_wp bnd ( 2 ,:) = huge ( 0.0_wp ) call bvls ( a , b , bnd , x , rnorm , nsetp , w , index , ierr , max_iter ) select case ( ierr ) case ( 0 ) mode = 1 case ( 1 : 2 ) mode = 2 case ( 3 ) ! doesn't exist in nnls... but will never happen because ! we are setting bounds above mode = - 999 case ( 4 ) mode = 3 case default mode = - 9999 !error stop 'unknown output from bvls' end select end subroutine bvls_wrapper !******************************************************************************* !******************************************************************************* !> !  Given an m by n matrix, \\mathbf{A}, and an m-vector, \\mathbf{b}, !  compute an n-vector, \\mathbf{x}, that solves the least squares problem: ! !   \\mathbf{A} \\mathbf{x} = \\mathbf{b} ! !  subject to  \\mathbf{x}  satisfying: ! !   \\mathbf{x}_l \\le \\mathbf{x} \\le \\mathbf{x}_u  ! !  This algorithm is a generalization of [[NNLS]], that solves !  the least-squares problem, `A * X = B`, subject to all `X(J) >= 0`. ! !### History !  * The subroutine [[NNLS]] appeared in 'Solving least squares problems,' !    by Lawson and Hanson, Prentice-Hall, 1974.  Work on BVLS was started !    by C. L. Lawson and R. J. Hanson at Jet Propulsion Laboratory, !    1973 June 12.  Many modifications were subsequently made. !    This Fortran 90 code was completed in April, 1995 by R. J. Hanson. subroutine bvls ( a , b , bnd , x , rnorm , nsetp , w , index , ierr , max_iter ) implicit none real ( wp ), dimension (:,:), intent ( inout ) :: a !! On entry A() contains the M by N matrix, A. !! On return A() contains the product matrix, Q*A, where !! Q is an M by M orthogonal matrix generated by this !! subroutine.  The dimensions are M=size(A,1) and N=size(A,2). real ( wp ), dimension (:), intent ( inout ) :: b !! On entry B() contains the M-vector, B. !! On return, B() contains Q*B.  The same Q multiplies A. real ( wp ), dimension (:,:), intent ( in ) :: bnd !! BND(1,J) is the lower bound for X(J). !! BND(2,J) is the upper bound for X(J). !! !! Require:  BND(1,J)  <=  BND(2,J). !! !! The values BND(1,J) = -huge(ONE) and BND(2,J) = huge(ONE) are !! suggested choices to designate that there is no constraint in that !! direction.  The parameter ONE is 1.0 in the working precision. real ( wp ), dimension (:), intent ( out ) :: x !! On entry X() need not be initialized.  On return, !! X() will contain the solution N-vector. real ( wp ), intent ( out ) :: rnorm !! Euclidean norm of the residual vector, b - A*X. integer , intent ( out ) :: nsetp !! Indicates the number of components of the solution !! vector, X(), that are not at their constraint values. real ( wp ), dimension (:), intent ( out ) :: w !! An N-array.  On return, W() will contain the dual solution !! vector.   Using Set definitions below: !! !! * W(J) = 0 for all j in Set P, !! * W(J)  <=  0 for all j in Set Z, such that X(J) is at its !!   lower bound, and !! * W(J)  >=  0 for all j in Set Z, such that X(J) is at its !!   upper bound. !! !! If BND(1,J) = BND(2,J), so the variable X(J) is fixed, !! then W(J) will have an arbitrary value. integer , dimension (:), intent ( out ) :: index !! An INTEGER working array of size N.  On exit the contents !! of this array define the sets P, Z, and F as follows: !! !! * INDEX(1)   through INDEX(NSETP)    =  Set P. !! * INDEX(IZ1) through INDEX(IZ2)      = Set Z. !! * INDEX(IZ2+1) through INDEX(N)      = Set F. !! !! IZ1 = NSETP + 1 = NPP1 !! !! Any of these sets may be empty.  Set F is those components !! that are constrained to a unique value by the given !! constraints.   Sets P and Z are those that are allowed a non- !! zero range of values.  Of these, set Z are those whose final !! value is a constraint value, while set P are those whose !! final value is not a constraint.  The value of IZ2 is not returned. !! !! It is computable as the number of bounds constraining a component !! of X uniquely. integer , intent ( out ) :: ierr !! Indicates status on return: !! !! * 0 -- Solution completed. !! * 1 -- M  <=  0 or N  <=  0 !! * 2 -- B(:), X(:), BND(:,:), W(:), or INDEX(:) size or shape violation. !! * 3 -- Input bounds are inconsistent. !! * 4 -- Exceed maximum number of iterations. integer , intent ( in ) :: max_iter !! maximum number of iterations (if <=0, then `3*n` is used) logical :: find , hitbnd , free1 , free2 , free integer :: iter !! Iteration counter. integer :: itmax !! Maximum number of iterations permitted. !! Defaults to 3*n if `max_iter<=0`. !! This is usually larger than required. integer :: m , n , i , ibound , ii , ip , iz , iz1 , iz2 , & j , jj , jz , l , lbound , npp1 real ( wp ), dimension ( size ( a , 2 )) :: s real ( wp ), dimension ( size ( a , 1 )) :: z real ( wp ) :: alpha , asave , cc , range , & norm , sm , ss , t , unorm , up , ztest real ( wp ), parameter :: eps = epsilon ( one ) !! Determines the relative linear dependence of a column vector !! for a variable moved from its initial value.  This is used in !! one place with the default value EPS=EPSILON(ONE).  Other !! values, larger or smaller may be needed for some problems. !! Library software will likely make this an optional argument. call initialize () ! The above call will set IERR. loopa : do ! Quit on error flag, or if all coefficients are already in the ! solution, .or. if M columns of A have been triangularized. if ( ierr /= 0 . or . iz1 > iz2 . or . nsetp >= m ) exit loopa call select_another_coeff_to_solve_for () ! See if no index was found to be moved from set Z to set P. ! Then go to termination. if ( . not . find ) exit loopa call move_j_from_set_z_to_set_p () call test_set_p_against_constraints () ! The above call may set IERR. ! All coefficients in set P are strictly feasible.  Loop back. end do loopa call termination () contains ! These are internal subroutines. subroutine initialize () m = size ( a , 1 ) n = size ( a , 2 ) if ( m <= 0 . or . n <= 0 ) then ierr = 1 return end if ! Check array sizes for consistency and with M and N. if ( size ( x ) < n ) then ierr = 2 return end if if ( size ( b ) < m ) then ierr = 2 return end if if ( size ( bnd , 1 ) /= 2 ) then ierr = 2 return end if if ( size ( bnd , 2 ) < n ) then ierr = 2 return end if if ( size ( w ) < n ) then ierr = 2 return end if if ( size ( index ) < n ) then ierr = 2 return end if ierr = 0 if ( max_iter <= 0 ) then itmax = 3 * n else itmax = max_iter end if iter = 0 ! Initialize the array index(). do i = 1 , n index ( i ) = i end do iz2 = n iz1 = 1 nsetp = 0 npp1 = 1 ! Begin:  Loop on IZ to initialize  X(). iz = iz1 do if ( iz > iz2 ) exit j = index ( iz ) if ( bnd ( 1 , j ) <= - huge ( one )) then if ( bnd ( 2 , j ) >= huge ( one )) then x ( j ) = zero else x ( j ) = min ( zero , bnd ( 2 , j )) end if else  if ( bnd ( 2 , j ) >= huge ( one )) then x ( j ) = max ( zero , bnd ( 1 , j )) else range = bnd ( 2 , j ) - bnd ( 1 , j ) if ( range <= zero ) then ! Here X(J) is constrained to a single value. index ( iz ) = index ( iz2 ) index ( iz2 ) = j iz = iz - 1 iz2 = iz2 - 1 x ( j ) = bnd ( 1 , j ) w ( j ) = zero else  if ( range > zero ) then !! The following statement sets X(J) to 0 if the constraint interval !! includes 0, and otherwise sets X(J) to the endpoint of the !! constraint interval that is closest to 0. x ( j ) = max ( bnd ( 1 , j ), min ( bnd ( 2 , j ), zero )) else ierr = 3 return end if end if if ( abs ( x ( j )) > zero ) then ! Change B() to reflect a nonzero starting value for X(J). b ( 1 : m ) = b ( 1 : m ) - a ( 1 : m , j ) * x ( j ) end if iz = iz + 1 end do end subroutine initialize subroutine select_another_coeff_to_solve_for () !! 1. Search through set z for a new coefficient to solve for. !!    First select a candidate that is either an unconstrained !!    coefficient or else a constrained coefficient that has room !!    to move in the direction consistent with the sign of its dual !!    vector component.  Components of the dual (negative gradient) !!    vector will be computed as needed. !! 2. For each candidate start the transformation to bring this !!    candidate into the triangle, and then do two tests:  Test size !!    of new diagonal value to avoid extreme ill-conditioning, and !!    the value of this new coefficient to be sure it moved in the !!    expected direction. !! 3. If some coefficient passes all these conditions, set FIND = true, !!    The index of the selected coefficient is J = INDEX(IZ). !! 4. If no coefficient is selected, set FIND = false. find = . false . do iz = iz1 , iz2 j = index ( iz ) ! Set FREE1 = true if X(J) is not at the left end-point of its ! constraint region. ! Set FREE2 = true if X(J) is not at the right end-point of its ! constraint region. ! Set FREE = true if X(J) is not at either end-point of its ! constraint region. free1 = x ( j ) > bnd ( 1 , j ) free2 = x ( j ) < bnd ( 2 , j ) free = free1 . and . free2 if ( free ) then call test_coef_j_for_diag_elt_and_direction_of_change () else ! Compute dual coefficient W(J). w ( j ) = dot_product ( a ( npp1 : m , j ), b ( npp1 : m )) ! Can X(J) move in the direction indicated by the sign of W(J)? if ( w ( j ) < zero ) then if ( free1 ) call test_coef_j_for_diag_elt_and_direction_of_change () else  if ( w ( j ) > zero ) then if ( free2 ) call test_coef_j_for_diag_elt_and_direction_of_change () end if end if if ( find ) return end do end subroutine select_another_coeff_to_solve_for subroutine test_coef_j_for_diag_elt_and_direction_of_change () !! The sign of W(J) is OK for J to be moved to set P. !! Begin the transformation and check new diagonal element to avoid !! near linear dependence. asave = a ( npp1 , j ) call htc ( npp1 , a ( 1 : m , j ), up ) unorm = nrm2 ( a ( 1 : nsetp , j )) if ( abs ( a ( npp1 , j )) > eps * unorm ) then ! Column J is sufficiently independent.  Copy b into Z, update Z. z ( 1 : m ) = b ( 1 : m ) ! Compute product of transormation and updated right-hand side. norm = a ( npp1 , j ) a ( npp1 , j ) = up if ( abs ( norm ) > zero ) then sm = dot_product ( a ( npp1 : m , j ) / norm , z ( npp1 : m )) / up z ( npp1 : m ) = z ( npp1 : m ) + sm * a ( npp1 : m , j ) a ( npp1 , j ) = norm end if if ( abs ( x ( j )) > zero ) z ( 1 : npp1 ) = z ( 1 : npp1 ) + a ( 1 : npp1 , j ) * x ( j ) ! Adjust Z() as though X(J) had been reset to zero. if ( free ) then find = . true . else !! Solve for ZTEST ( proposed new value for X(J) ). !! Then set FIND to indicate if ZTEST has moved away from X(J) in !! the expected direction indicated by the sign of W(J). ztest = z ( npp1 ) / a ( npp1 , j ) find = ( w ( j ) < zero . and . ztest < x ( j ) ) . or . & ( w ( j ) > zero . and . ztest > x ( j ) ) end if end if ! If J was not accepted to be moved from set Z to set P, ! restore A(NNP1,J).  Failing these tests may mean the computed ! sign of W(J) is suspect, so here we set W(J) = 0.  This will ! not affect subsequent computation, but cleans up the W() array. if ( . not . find ) then a ( npp1 , j ) = asave w ( j ) = zero end if end subroutine test_coef_j_for_diag_elt_and_direction_of_change subroutine move_j_from_set_z_to_set_p () !! The index  J=index(IZ)  has been selected to be moved from !! set Z to set P.  Z() contains the old B() adjusted as though X(J) = 0. !! A(*,J) contains the new Householder transformation vector. b ( 1 : m ) = z ( 1 : m ) index ( iz ) = index ( iz1 ) index ( iz1 ) = j iz1 = iz1 + 1 nsetp = npp1 npp1 = npp1 + 1 ! The following loop can be null or not required. norm = a ( nsetp , j ) a ( nsetp , j ) = up if ( abs ( norm ) > zero ) then do jz = iz1 , iz2 jj = index ( jz ) sm = dot_product ( a ( nsetp : m , j ) / norm , a ( nsetp : m , jj )) / up a ( nsetp : m , jj ) = a ( nsetp : m , jj ) + sm * a ( nsetp : m , j ) end do a ( nsetp , j ) = norm end if ! The following loop can be null. do l = npp1 , m a ( l , j ) = zero end do !  L w ( j ) = zero ! Solve the triangular system.  Store this solution temporarily in Z(). do i = nsetp , 1 , - 1 if ( i /= nsetp ) z ( 1 : i ) = z ( 1 : i ) - a ( 1 : i , ii ) * z ( i + 1 ) ii = index ( i ) z ( i ) = z ( i ) / a ( i , ii ) end do end subroutine move_j_from_set_z_to_set_p subroutine test_set_p_against_constraints () loopb : do ! The solution obtained by solving the current set P is in the array Z(). iter = iter + 1 if ( iter > itmax ) then ierr = 4 exit loopb end if call see_if_all_constrained_coeffs_are_feasible () ! The above call sets HITBND.  If HITBND = true then it also sets ! ALPHA, JJ, and IBOUND. if ( . not . hitbnd ) exit loopb ! Here ALPHA will be between 0 and 1 for interpolation ! between the old X() and the new Z(). do ip = 1 , nsetp l = index ( ip ) x ( l ) = x ( l ) + alpha * ( z ( ip ) - x ( l )) end do i = index ( jj ) ! Note:  The exit test is done at the end of the loop, so the loop ! will always be executed at least once. do ! Modify A(*,*), B(*) and the index arrays to move coefficient I ! from set P to set Z. call move_coef_i_from_set_p_to_set_z if ( nsetp <= 0 ) exit loopb ! See if the remaining coefficients in set P are feasible.  They should ! be because of the way ALPHA was determined.  If any are infeasible ! it is due to round-off error.  Any that are infeasible or on a boundary ! will be set to the boundary value and moved from set P to set Z. ibound = 0 do jj = 1 , nsetp i = index ( jj ) if ( x ( i ) <= bnd ( 1 , i )) then ibound = 1 exit else if ( x ( i ) >= bnd ( 2 , i )) then ibound = 2 exit end if end do if ( ibound <= 0 ) exit end do ! Copy B( ) into Z( ).  Then solve again and loop back. z ( 1 : m ) = b ( 1 : m ) do i = nsetp , 1 , - 1 if ( i /= nsetp ) z ( 1 : i ) = z ( 1 : i ) - a ( 1 : i , ii ) * z ( i + 1 ) ii = index ( i ) z ( i ) = z ( i ) / a ( i , ii ) end do end do loopb ! The following loop can be null. do ip = 1 , nsetp i = index ( ip ) x ( i ) = z ( ip ) end do end subroutine test_set_p_against_constraints subroutine see_if_all_constrained_coeffs_are_feasible () !! See if each coefficient in set P is strictly interior to its constraint region. !! If so, set HITBND = false. !! If not, set HITBND = true, and also set ALPHA, JJ, and IBOUND. !! Then ALPHA will satisfy  0.  < ALPHA  <=  1. alpha = two do ip = 1 , nsetp l = index ( ip ) if ( z ( ip ) <= bnd ( 1 , l )) then ! Z(IP) HITS LOWER BOUND lbound = 1 else  if ( z ( ip ) >= bnd ( 2 , l )) then ! Z(IP) HITS UPPER BOUND lbound = 2 else lbound = 0 end if if ( lbound /= 0 ) then t = ( bnd ( lbound , l ) - x ( l )) / ( z ( ip ) - x ( l )) if ( alpha > t ) then alpha = t jj = ip ibound = lbound end if end if end do hitbnd = abs ( alpha - two ) > zero end subroutine see_if_all_constrained_coeffs_are_feasible subroutine move_coef_i_from_set_p_to_set_z () x ( i ) = bnd ( ibound , i ) if ( abs ( x ( i )) > zero . and . jj > 0 ) b ( 1 : jj ) = b ( 1 : jj ) - a ( 1 : jj , i ) * x ( i ) ! The following loop can be null. do j = jj + 1 , nsetp ii = index ( j ) index ( j - 1 ) = ii call rotg ( a ( j - 1 , ii ), a ( j , ii ), cc , ss ) sm = a ( j - 1 , ii ) ! The plane rotation is applied to two rows of A and the right-hand ! side.  One row is moved to the scratch array S and then the updates ! are computed.  The intent is for array operations to be performed ! and minimal extra data movement.  One extra rotation is applied ! to column II in this approach. s = a ( j - 1 , 1 : n ) a ( j - 1 , 1 : n ) = cc * s + ss * a ( j , 1 : n ) a ( j , 1 : n ) = cc * a ( j , 1 : n ) - ss * s a ( j - 1 , ii ) = sm a ( j , ii ) = zero sm = b ( j - 1 ) b ( j - 1 ) = cc * sm + ss * b ( j ) b ( j ) = cc * b ( j ) - ss * sm end do npp1 = nsetp nsetp = nsetp - 1 iz1 = iz1 - 1 index ( iz1 ) = i end subroutine move_coef_i_from_set_p_to_set_z subroutine termination () if ( ierr <= 0 ) then ! Compute the norm of the residual vector. sm = zero if ( npp1 <= m ) then sm = nrm2 ( b ( npp1 : m )) else w ( 1 : n ) = zero end if rnorm = sm end if end subroutine termination pure subroutine rotg ( sa , sb , c , s ) real ( wp ), intent ( inout ) :: sa real ( wp ), intent ( in ) :: sb real ( wp ), intent ( out ) :: c real ( wp ), intent ( out ) :: s real ( wp ) :: roe , scale , r roe = sb if ( abs ( sa ) > abs ( sb ) ) roe = sa scale = abs ( sa ) + abs ( sb ) if ( scale <= zero ) then c = one s = zero else r = scale * sqrt (( sa / scale ) ** 2 + ( sb / scale ) ** 2 ) if ( roe < zero ) r =- r c = sa / r s = sb / r sa = r end if end subroutine rotg pure function nrm2 ( x ) result ( norm ) !!  NRM2 returns the Euclidean norm of a vector via the function !!  name, so that !! !!  `NRM2 := sqrt( x'*x )` !! !!### See also !!  * [[dnrm2]] real ( wp ), dimension (:), intent ( in ) :: x real ( wp ) :: norm real ( wp ) :: absxi , scale , ssq integer :: n , ix n = size ( x ) if ( n < 1 ) then norm = zero else if ( n == 1 ) then norm = abs ( x ( 1 ) ) else scale = zero ssq = one do ix = 1 , n absxi = abs ( x ( ix ) ) if ( absxi > zero ) then if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if end function nrm2 pure subroutine htc ( p , u , up ) !! Construct a Householder transformation. integer , intent ( in ) :: p real ( wp ), dimension (:), intent ( inout ) :: u real ( wp ), intent ( out ) :: up real ( wp ) :: vnorm vnorm = nrm2 ( u ( p : size ( u ))) if ( u ( p ) > zero ) vnorm =- vnorm up = u ( p ) - vnorm u ( p ) = vnorm end subroutine htc end subroutine bvls !******************************************************************************* end module bvls_module !*******************************************************************************","tags":"","url":"sourcefile/bvls_module.f90.html"},{"title":"slsqp_kinds.F90 – slsqp","text":"Files dependent on this one sourcefile~~slsqp_kinds.f90~~AfferentGraph sourcefile~slsqp_kinds.f90 slsqp_kinds.F90 sourcefile~bvls_module.f90 bvls_module.f90 sourcefile~bvls_module.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_support.f90 slsqp_support.F90 sourcefile~bvls_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_core.f90->sourcefile~bvls_module.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 12/22/2015 !  license: BSD ! !  Numeric kind definitions. ! !@note The default real kind (`wp`) can be !      changed using optional preprocessor flags. !      This library was built with real kind: #ifdef REAL32 !      `real(kind=real32)` [4 bytes] #elif REAL64 !      `real(kind=real64)` [8 bytes] #elif REAL128 !      `real(kind=real128)` [16 bytes] #else !      `real(kind=real64)` [8 bytes] #endif module slsqp_kinds use , intrinsic :: iso_fortran_env implicit none private #ifdef REAL32 integer , parameter , public :: slsqp_rk = real32 !! real kind used by this module [4 bytes] #elif REAL64 integer , parameter , public :: slsqp_rk = real64 !! real kind used by this module [8 bytes] #elif REAL128 integer , parameter , public :: slsqp_rk = real128 !! real kind used by this module [16 bytes] #else integer , parameter , public :: slsqp_rk = real64 !! real kind used by this module [8 bytes] #endif integer , parameter , public :: wp = slsqp_rk !! copy of `slsqp_rk` with a shorter name end module slsqp_kinds !*****************************************************************************************","tags":"","url":"sourcefile/slsqp_kinds.f90.html"},{"title":"slsqp_support.F90 – slsqp","text":"This file depends on sourcefile~~slsqp_support.f90~~EfferentGraph sourcefile~slsqp_support.f90 slsqp_support.F90 sourcefile~slsqp_kinds.f90 slsqp_kinds.F90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~slsqp_support.f90~~AfferentGraph sourcefile~slsqp_support.f90 slsqp_support.F90 sourcefile~bvls_module.f90 bvls_module.f90 sourcefile~bvls_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90->sourcefile~bvls_module.f90 sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> license: BSD ! !  Support routines for SLSQP. For example, routines from !  [BLAS](http://www.netlib.org/blas/) and [LINPACK](http://www.netlib.org/linpack/). !  These have also been refactored into modern Fortran. module slsqp_support use slsqp_kinds implicit none private real ( wp ), parameter , public :: epmach = epsilon ( 1.0_wp ) real ( wp ), parameter , public :: zero = 0.0_wp real ( wp ), parameter , public :: one = 1.0_wp real ( wp ), parameter , public :: two = 2.0_wp real ( wp ), parameter , public :: four = 4.0_wp real ( wp ), parameter , public :: ten = 1 0.0_wp real ( wp ), parameter , public :: hun = 10 0.0_wp public :: daxpy , dcopy , ddot , dnrm2 , dscal #ifdef HAS_BLAS ! linking with an external BLAS library. ! Define the interfaces here. Note that this ! will only work if the `wp` is the same kind ! as used in the BLAS library. interface pure subroutine daxpy ( n , da , dx , incx , dy , incy ) import :: wp implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: da real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( inout ) :: dy integer , intent ( in ) :: incy end subroutine daxpy pure subroutine dcopy ( n , dx , incx , dy , incy ) import :: wp implicit none integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( out ) :: dy integer , intent ( in ) :: incy end subroutine dcopy pure real ( wp ) function ddot ( n , dx , incx , dy , incy ) import :: wp implicit none integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( in ) :: dy integer , intent ( in ) :: incy end function ddot pure function dnrm2 ( n , x , incx ) result ( norm ) import :: wp implicit none integer , intent ( in ) :: incx integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ) :: norm end function dnrm2 pure subroutine dscal ( n , da , dx , incx ) import :: wp implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: da real ( wp ), dimension ( * ), intent ( inout ) :: dx integer , intent ( in ) :: incx end subroutine dscal end interface #else contains !******************************************************************************* !******************************************************************************* !> !  constant times a vector plus a vector. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. pure subroutine daxpy ( n , da , dx , incx , dy , incy ) implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: da real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( inout ) :: dy integer , intent ( in ) :: incy integer :: i , ix , iy , m , mp1 if ( n <= 0 ) return if ( abs ( da ) <= zero ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 4 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dy ( i ) + da * dx ( i ) end do if ( n < 4 ) return end if mp1 = m + 1 do i = mp1 , n , 4 dy ( i ) = dy ( i ) + da * dx ( i ) dy ( i + 1 ) = dy ( i + 1 ) + da * dx ( i + 1 ) dy ( i + 2 ) = dy ( i + 2 ) + da * dx ( i + 2 ) dy ( i + 3 ) = dy ( i + 3 ) + da * dx ( i + 3 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dy ( iy ) + da * dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine daxpy !******************************************************************************* !******************************************************************************* !> !  copies a vector, x, to a vector, y. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. pure subroutine dcopy ( n , dx , incx , dy , incy ) implicit none integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( out ) :: dy integer , intent ( in ) :: incy integer :: i , ix , iy , m , mp1 if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 7 ) if ( m /= 0 ) then do i = 1 , m dy ( i ) = dx ( i ) end do if ( n < 7 ) return end if mp1 = m + 1 do i = mp1 , n , 7 dy ( i ) = dx ( i ) dy ( i + 1 ) = dx ( i + 1 ) dy ( i + 2 ) = dx ( i + 2 ) dy ( i + 3 ) = dx ( i + 3 ) dy ( i + 4 ) = dx ( i + 4 ) dy ( i + 5 ) = dx ( i + 5 ) dy ( i + 6 ) = dx ( i + 6 ) end do else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dy ( iy ) = dx ( ix ) ix = ix + incx iy = iy + incy end do end if end subroutine dcopy !******************************************************************************* !******************************************************************************* !> !  forms the dot product of two vectors. !  uses unrolled loops for increments equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. pure real ( wp ) function ddot ( n , dx , incx , dy , incy ) implicit none integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: dx integer , intent ( in ) :: incx real ( wp ), dimension ( * ), intent ( in ) :: dy integer , intent ( in ) :: incy real ( wp ) :: dtemp integer :: i , ix , iy , m , mp1 ddot = zero dtemp = zero if ( n <= 0 ) return if ( incx == 1 . and . incy == 1 ) then ! code for both increments equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dtemp = dtemp + dx ( i ) * dy ( i ) end do if ( n < 5 ) then ddot = dtemp return end if end if mp1 = m + 1 do i = mp1 , n , 5 dtemp = dtemp + dx ( i ) * dy ( i ) + dx ( i + 1 ) * dy ( i + 1 ) + & dx ( i + 2 ) * dy ( i + 2 ) + dx ( i + 3 ) * dy ( i + 3 ) + dx ( i + 4 ) * dy ( i + 4 ) end do ddot = dtemp else ! code for unequal increments or equal increments ! not equal to 1 ix = 1 iy = 1 if ( incx < 0 ) ix = ( - n + 1 ) * incx + 1 if ( incy < 0 ) iy = ( - n + 1 ) * incy + 1 do i = 1 , n dtemp = dtemp + dx ( ix ) * dy ( iy ) ix = ix + incx iy = iy + incy end do ddot = dtemp end if end function ddot !******************************************************************************* !******************************************************************************* !> !  Function that returns the Euclidean norm !   \\sqrt{ \\mathbf{x}&#94;T \\mathbf{x} }  of a vector  \\mathbf{x} . ! !### Further details ! !  * this version written on 25-october-1982. !  * modified on 14-october-1993 to inline the call to dlassq. !    sven hammarling, nag ltd. !  * Converted to modern Fortran, Jacob Williams, Jan. 2016. ! !@note Replaced original SLSQP routine with this one from !      [BLAS](http://netlib.sandia.gov/blas/dnrm2.f). pure function dnrm2 ( n , x , incx ) result ( norm ) implicit none integer , intent ( in ) :: incx integer , intent ( in ) :: n real ( wp ), dimension ( * ), intent ( in ) :: x real ( wp ) :: norm real ( wp ) :: absxi , scale , ssq integer :: ix if ( n < 1 . or . incx < 1 ) then norm = zero elseif ( n == 1 ) then norm = abs ( x ( 1 )) else scale = zero ssq = one ! the following loop is equivalent to this call to the lapack ! auxiliary routine: ! call dlassq( n, x, incx, scale, ssq ) do ix = 1 , 1 + ( n - 1 ) * incx , incx if ( abs ( x ( ix )) > zero ) then absxi = abs ( x ( ix )) if ( scale < absxi ) then ssq = one + ssq * ( scale / absxi ) ** 2 scale = absxi else ssq = ssq + ( absxi / scale ) ** 2 end if end if end do norm = scale * sqrt ( ssq ) end if end function dnrm2 !******************************************************************************* !******************************************************************************* !> !  scales a vector by a constant. !  uses unrolled loops for increment equal to one. ! !### Author !  jack dongarra, linpack, 3/11/78. pure subroutine dscal ( n , da , dx , incx ) implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: da real ( wp ), dimension ( * ), intent ( inout ) :: dx integer , intent ( in ) :: incx integer :: i , m , mp1 , nincx if ( n <= 0 . or . incx <= 0 ) return if ( incx == 1 ) then ! code for increment equal to 1 ! clean-up loop m = mod ( n , 5 ) if ( m /= 0 ) then do i = 1 , m dx ( i ) = da * dx ( i ) end do if ( n < 5 ) return end if mp1 = m + 1 do i = mp1 , n , 5 dx ( i ) = da * dx ( i ) dx ( i + 1 ) = da * dx ( i + 1 ) dx ( i + 2 ) = da * dx ( i + 2 ) dx ( i + 3 ) = da * dx ( i + 3 ) dx ( i + 4 ) = da * dx ( i + 4 ) end do else ! code for increment not equal to 1 nincx = n * incx do i = 1 , nincx , incx dx ( i ) = da * dx ( i ) end do end if end subroutine dscal !******************************************************************************* #endif !******************************************************************************* end module slsqp_support !*******************************************************************************","tags":"","url":"sourcefile/slsqp_support.f90.html"},{"title":"slsqp_module.f90 – slsqp","text":"This file depends on sourcefile~~slsqp_module.f90~~EfferentGraph sourcefile~slsqp_module.f90 slsqp_module.f90 sourcefile~slsqp_core.f90 slsqp_core.f90 sourcefile~slsqp_module.f90->sourcefile~slsqp_core.f90 sourcefile~slsqp_kinds.f90 slsqp_kinds.F90 sourcefile~slsqp_module.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_support.f90 slsqp_support.F90 sourcefile~slsqp_module.f90->sourcefile~slsqp_support.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_kinds.f90 sourcefile~slsqp_core.f90->sourcefile~slsqp_support.f90 sourcefile~bvls_module.f90 bvls_module.f90 sourcefile~slsqp_core.f90->sourcefile~bvls_module.f90 sourcefile~slsqp_support.f90->sourcefile~slsqp_kinds.f90 sourcefile~bvls_module.f90->sourcefile~slsqp_kinds.f90 sourcefile~bvls_module.f90->sourcefile~slsqp_support.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> author: Jacob Williams !  license: BSD ! !  Module containing the object-oriented interface to the SLSQP method. !  It is called using the [[slsqp_solver]] class, which !  is the only public entity in this module. module slsqp_module use slsqp_kinds use slsqp_support use slsqp_core use , intrinsic :: iso_fortran_env , only : error_unit , output_unit use , intrinsic :: ieee_arithmetic , only : ieee_is_nan implicit none private type , public :: slsqp_solver !! The main class used to interface with the SLSQP solver. private integer :: n = 0 !! number of optimization variables ( n > 0 ) integer :: m = 0 !! number of constraints ( m \\ge 0 ) integer :: meq = 0 !! number of equality constraints ( m \\ge m_{eq} \\ge 0 ) integer :: max_iter = 0 !! maximum number of iterations real ( wp ) :: acc = zero !! accuracy tolerance real ( wp ) :: tolf = - one !! accuracy tolerance over f:  if  |f| < tolf  then stop real ( wp ) :: toldf = - one !! accuracy tolerance over df: if  |f_{n+1} - f_n| < toldf  then stop. !! It's different from `acc` in the case of positive derivative real ( wp ) :: toldx = - one !! accuracy tolerance over dx: if  |x_{n+1} - x_n| < toldx  then stop integer :: gradient_mode = 0 !! how the gradients are computed: !! !! * 0 - use the user-supplied `g` subroutine. [default] !! * 1 - approximate by basic backward differences !! * 2 - approximate by basic forward differences !! * 3 - approximate by basic central differences real ( wp ) :: gradient_delta = 1.0e8_wp !! perturbation step size to approximate gradients !! by finite differences (`gradient_mode` 1-3). !these two were not in the original code: real ( wp ) :: alphamin = 0.1_wp !! min  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  real ( wp ) :: alphamax = 1.0_wp !! max  \\alpha  for line search  0 < \\alpha_{min} < \\alpha_{max} \\le 1  integer :: iprint = output_unit !! unit number of status printing (0 for no printing) real ( wp ), dimension (:), allocatable :: xl !! lower bound on x real ( wp ), dimension (:), allocatable :: xu !! upper bound on x integer :: l_w = 0 !! size of `w` real ( wp ), dimension (:), allocatable :: w !! real work array procedure ( func ), pointer :: f => null () !! problem function subroutine procedure ( grad ), pointer :: g => null () !! gradient subroutine procedure ( iterfunc ), pointer :: report => null () !! for reporting an iteration procedure ( msgfunc ), pointer :: report_msg => null () !! for reporting a string message from slsqp to the user integer :: linesearch_mode = 1 !! linesearch mode: !! !! * `1` = inexact (Armijo) linesearch, !! * `2` = exact linesearch. type ( linmin_data ) :: linmin !! data formerly within [[linmin]]. !! Only used when `linesearch_mode=2` type ( slsqpb_data ) :: slsqpb !! data formerly within [[slsqpb]]. ! note: the following two maybe should be combined into a separate type ! along with the two methods... integer :: nnls_mode = 1 !! Which NNLS method to use: !! !! 1. Use the original [[nnls]] !! 2. Use the newer [[bvls]] integer :: max_iter_ls = 0 !! max iterations in the least squares problem. !! if `<=0`, defaults to `3*n`. !! (use by either [[nnls]] or [[bvls]]) logical :: user_triggered_stop = . false . !! if the `abort` method has been called !! to stop the iterations real ( wp ) :: infinite_bound = huge ( one ) !! \"infinity\" for the upper and lower bounds. !! if `xl<=-infinite_bound` or `xu>=infinite_bound` !! then these bounds are considered nonexistant. contains private procedure , public :: initialize => initialize_slsqp procedure , public :: destroy => destroy_slsqp procedure , public :: optimize => slsqp_wrapper procedure , public :: abort => stop_iterations procedure :: report_message !! for reporting messages to the user end type slsqp_solver abstract interface subroutine func ( me , x , f , c ) !! for computing the function import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( out ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. end subroutine func subroutine grad ( me , x , g , a ) !! for computing the gradients import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), dimension (:), intent ( out ) :: g !! objective function partials w.r.t x `dimension(n)` real ( wp ), dimension (:,:), intent ( out ) :: a !! gradient matrix of constraints w.r.t. x `dimension(m,n)` end subroutine grad subroutine iterfunc ( me , iter , x , f , c ) !! for reporting an iteration import :: wp , slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: iter !! iteration number real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( in ) :: f !! value of the objective function real ( wp ), dimension (:), intent ( in ) :: c !! the constraint vector `dimension(m)`, !! equality constraints (if any) first. end subroutine iterfunc subroutine msgfunc ( me , str ) !! for reporting a message to the user import :: slsqp_solver implicit none class ( slsqp_solver ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: str !! the message to report. end subroutine msgfunc end interface contains !******************************************************************************* !******************************************************************************* !> !  A method that the user can call to stop the iterations. !  (it can be called in any of the functions). !  SLSQP will stop at the end of the next iteration. subroutine stop_iterations ( me ) implicit none class ( slsqp_solver ), intent ( inout ) :: me me % user_triggered_stop = . true . end subroutine stop_iterations !******************************************************************************* !******************************************************************************* !> !  initialize the [[slsqp_solver]] class.  see [[slsqp]] for more details. subroutine initialize_slsqp ( me , n , m , meq , max_iter , acc , f , g , xl , xu , status_ok ,& linesearch_mode , iprint , report , alphamin , alphamax ,& gradient_mode , gradient_delta , tolf , toldf , toldx ,& max_iter_ls , nnls_mode , infinite_bound , report_msg ) implicit none class ( slsqp_solver ), intent ( inout ) :: me integer , intent ( in ) :: n !! the number of variables,  n \\ge 1  integer , intent ( in ) :: m !! total number of constraints,  m \\ge 0  integer , intent ( in ) :: meq !! number of equality constraints,  m_{eq} \\ge 0  integer , intent ( in ) :: max_iter !! maximum number of iterations procedure ( func ) :: f !! problem function procedure ( grad ) :: g !! function to compute gradients (must be !! associated if `gradient_mode=0`) real ( wp ), dimension ( n ), intent ( in ) :: xl !! lower bounds on `x`. !! `xl(i)=NaN` (or `xl(i)<=-infinite_bound`) indicates to ignore `i`th bound real ( wp ), dimension ( n ), intent ( in ) :: xu !! upper bounds on `x`. !! `xu(i)=NaN` (or `xu(i)>=infinite_bound`) indicates to ignore `i`th bound real ( wp ), intent ( in ) :: acc !! accuracy logical , intent ( out ) :: status_ok !! will be false if there were errors integer , intent ( in ), optional :: linesearch_mode !! 1 = inexact (default), 2 = exact integer , intent ( in ), optional :: iprint !! unit number of status messages (default=`output_unit`) procedure ( iterfunc ), optional :: report !! user-defined procedure that will be called once per iteration real ( wp ), intent ( in ), optional :: alphamin !! minimum alpha for linesearch [default 0.1] real ( wp ), intent ( in ), optional :: alphamax !! maximum alpha for linesearch [default 1.0] integer , intent ( in ), optional :: gradient_mode !! how the gradients are to be computed: !! !! * 0 - use the user-supplied `g` subroutine. [default] !! * 1 - approximate by basic backward differences !! * 2 - approximate by basic forward differences !! * 3 - approximate by basic central differences !! !! Note that modes 1-3 do not respect the variable bounds. real ( wp ), intent ( in ), optional :: gradient_delta !! perturbation step size (>epsilon) to compute the approximated !! gradient by finite differences (`gradient_mode` 1-3). !! note that this is an absolute step that does not respect !! the `xl` or `xu` variable bounds. real ( wp ), intent ( in ), optional :: tolf !! stopping criterion if  |f| < tolf  then stop. real ( wp ), intent ( in ), optional :: toldf !! stopping criterion if  |f_{n+1} - f_n| < toldf  then stop real ( wp ), intent ( in ), optional :: toldx !! stopping criterion if  ||x_{n+1} - x_n|| < toldx  then stop integer , intent ( in ), optional :: max_iter_ls !! maximum number of iterations in the [[nnls]] problem integer , intent ( in ), optional :: nnls_mode !! Which NNLS method to use: !! !! 1. Use the original [[nnls]] !! 2. Use the newer [[bvls]] real ( wp ), intent ( in ), optional :: infinite_bound !! \"infinity\" for the upper and lower bounds. !! if `xl<=-infinite_bound` or `xu>=infinite_bound` !! then these bounds are considered nonexistant. !! If not present then `huge()` is used for this. procedure ( msgfunc ), optional :: report_msg !! user-defined procedure that will be called !! with any warning or error messages. integer :: n1 , mineq , i status_ok = . false . call me % destroy () if ( present ( iprint )) me % iprint = iprint if ( present ( report_msg )) me % report_msg => report_msg if ( size ( xl ) /= size ( xu ) . or . size ( xl ) /= n ) then call me % report_message ( 'error: invalid upper or lower bound vector size' ) call me % report_message ( '  size(xl) =' , ival = size ( xl )) call me % report_message ( '  size(xu) =' , ival = size ( xu )) call me % report_message ( '  n        =' , ival = n ) else if ( meq < 0 . or . meq > m ) then call me % report_message ( 'error: invalid meq value:' , ival = meq ) else if ( m < 0 ) then call me % report_message ( 'error: invalid m value:' , ival = m ) else if ( n < 1 ) then call me % report_message ( 'error: invalid n value:' , ival = n ) else if ( any ( xl > xu . and . . not . ieee_is_nan ( xl ) . and . . not . ieee_is_nan ( xu ))) then call me % report_message ( 'error: lower bounds must be <= upper bounds.' ) do i = 1 , n if ( xl ( i ) > xu ( i ) . and . . not . ieee_is_nan ( xl ( i )) . and . . not . ieee_is_nan ( xu ( i ))) then call me % report_message ( '  xl(i)>xu(i) for variable' , ival = i ) end if end do else if ( present ( linesearch_mode )) then !two linesearch modes: select case ( linesearch_mode ) case ( 1 ) !inexact me % linesearch_mode = linesearch_mode case ( 2 ) !exact me % linesearch_mode = linesearch_mode case default call me % report_message ( 'error: invalid linesearch_mode (must be 1 or 2): ' ,& ival = linesearch_mode ) call me % destroy () return end select end if !optional linesearch bounds: if ( present ( alphamin )) me % alphamin = alphamin if ( present ( alphamax )) me % alphamax = alphamax !verify valid values for alphamin and alphamax: 0<alphamin<alphamax<=1 if ( me % alphamin <= zero . or . me % alphamax <= zero . or . & me % alphamax <= me % alphamin . or . & me % alphamin >= one . or . me % alphamax > one ) then call me % report_message ( 'error: invalid values for alphamin or alphamax.' ) call me % report_message ( '  alphamin =' , rval = me % alphamin ) call me % report_message ( '  alphamax =' , rval = me % alphamax ) call me % destroy () return end if if ( present ( tolf )) me % tolf = tolf if ( present ( toldf )) me % toldf = toldf if ( present ( toldx )) me % toldx = toldx if ( present ( max_iter_ls )) me % max_iter_ls = max_iter_ls if ( present ( nnls_mode )) then select case ( nnls_mode ) case ( 1 : 2 ) me % nnls_mode = nnls_mode case default call me % report_message ( 'error: invalid value for nnls_mode. defaulting to 1.' ) me % nnls_mode = 1 end select end if status_ok = . true . me % n = n me % m = m me % meq = meq me % max_iter = max_iter me % acc = acc me % f => f me % g => g if ( present ( report )) me % report => report allocate ( me % xl ( n )); me % xl = xl allocate ( me % xu ( n )); me % xu = xu !work arrays: n1 = n + 1 mineq = m - meq + 2 * n1 me % l_w = n1 * ( n1 + 1 ) + meq * ( n1 + 1 ) + mineq * ( n1 + 1 ) + & !for lsq ( n1 - meq + 1 ) * ( mineq + 2 ) + 2 * mineq + & !for lsi ( n1 + mineq ) * ( n1 - meq ) + 2 * meq + n1 + & !for lsei n1 * n / 2 + 2 * m + 3 * n + 3 * n1 + 1 !for slsqpb allocate ( me % w ( me % l_w )) me % w = zero if ( present ( gradient_mode )) then me % gradient_mode = gradient_mode if ( present ( gradient_delta )) then me % gradient_delta = gradient_delta end if end if if ( present ( infinite_bound )) then me % infinite_bound = abs ( infinite_bound ) else me % infinite_bound = huge ( one ) end if end if end subroutine initialize_slsqp !******************************************************************************* !******************************************************************************* !> !  destructor for [[slsqp_solver]]. subroutine destroy_slsqp ( me ) implicit none class ( slsqp_solver ), intent ( out ) :: me end subroutine destroy_slsqp !******************************************************************************* !******************************************************************************* !> !  main routine for calling [[slsqp]]. subroutine slsqp_wrapper ( me , x , istat , iterations , status_message ) implicit none class ( slsqp_solver ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x !! **in:**  initial optimization variables, !! **out:** solution. integer , intent ( out ) :: istat !! status code (see `mode` in [[slsqp]]). integer , intent ( out ), optional :: iterations !! number of iterations character ( len = :), intent ( out ), allocatable , optional :: status_message !! string status message !! corresponding to `istat` ! local variables: real ( wp ), dimension (:), allocatable :: c !! constraint vector -- `dimension(max(1,me%m))` real ( wp ), dimension (:,:), allocatable :: a !! a matrix for [[slsqp]] -- `dimension(max(1,me%m),me%n+1)` real ( wp ), dimension (:), allocatable :: g !! g matrix for [[slsqp]] -- `dimension(me%n+1)` real ( wp ), dimension (:), allocatable :: cvec !! constraint vector -- `dimension(me%m)` real ( wp ), dimension (:), allocatable :: dfdx !! objective function partials -- `dimension(me%n)` real ( wp ), dimension (:,:), allocatable :: dcdx !! constraint partials -- `dimension(me%m,me%n)` real ( wp ), dimension (:), allocatable :: delta !! perturbation step size to approximate gradient -- `dimension(me%n)` real ( wp ), dimension (:), allocatable :: cvecr !! right function value to approximate constraints vector's gradient -- `dimension(me%m)` real ( wp ), dimension (:), allocatable :: cvecl !! left function value to approximate constraints vector's gradient -- `dimension(me%m)` real ( wp ) :: f !! objective function integer :: i !! iteration counter integer :: mode !! reverse communication flag for [[slsqp]] integer :: la !! input to [[slsqp]] integer :: iter !! in/out for [[slsqp]] real ( wp ) :: acc !! in/out for [[slsqp]] integer :: ig !! loop index to approximate gradient real ( wp ) :: fr !! right function value to approximate objective function's gradient real ( wp ) :: fl !! left function value to approximate objective function's gradient real ( wp ) :: fact !! denominator factor for finite difference approximation !initialize: allocate ( c ( max ( 1 , me % m )) ) allocate ( a ( max ( 1 , me % m ), me % n + 1 )) allocate ( g ( me % n + 1 ) ) allocate ( cvec ( me % m ) ) allocate ( dfdx ( me % n ) ) allocate ( dcdx ( me % m , me % n ) ) allocate ( delta ( me % n ) ) allocate ( cvecr ( me % m ) ) allocate ( cvecl ( me % m ) ) i = 0 iter = me % max_iter la = max ( 1 , me % m ) mode = 0 a = zero g = zero c = zero if ( present ( iterations )) iterations = 0 call me % linmin % destroy () call me % slsqpb % destroy () !check setup: if ( size ( x ) /= me % n ) then istat = - 100 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !linesearch: select case ( me % linesearch_mode ) case ( 1 ) !inexact (armijo-type linesearch) acc = abs ( me % acc ) case ( 2 ) !exact acc = - abs ( me % acc ) case default istat = - 101 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end select !make sure the functions have been associated: if (. not . associated ( me % f )) then istat = - 102 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if (( me % gradient_mode == 0 ). and .(. not . associated ( me % g ))) then istat = - 103 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if ( me % gradient_mode < 0 . or . me % gradient_mode > 3 ) then istat = - 104 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if if ( me % gradient_mode /= 0 . and . me % gradient_delta <= epmach ) then istat = - 105 call me % report_message ( mode_to_status_message ( istat )) if ( present ( status_message )) status_message = mode_to_status_message ( istat ) return end if !main solver loop: do if ( mode == 0 . or . mode == 1 ) then !function evaluation (f&c) call me % f ( x , f , cvec ) c ( 1 : me % m ) = cvec end if if ( mode == 0 . or . mode ==- 1 ) then !gradient evaluation (g&a) select case ( me % gradient_mode ) case ( 0 ) ! user supplied gradients call me % g ( x , dfdx , dcdx ) g ( 1 : me % n ) = dfdx a ( 1 : me % m , 1 : me % n ) = dcdx case default ! approximate using finite differences if ( me % gradient_mode == 3 ) then fact = two ! central differences else fact = one ! forward/backward differences end if do ig = 1 , me % n !initialize a delta to perturb the objective !function and the constraint vector delta = zero delta ( ig ) = me % gradient_delta !get the right and left value of the objective !function and the constraint vector select case ( me % gradient_mode ) case ( 1 ) ! backward difference call me % f ( x , fr , cvecr ) call me % f ( x - delta , fl , cvecl ) case ( 2 ) ! forward difference call me % f ( x + delta , fr , cvecr ) call me % f ( x , fl , cvecl ) case ( 3 ) ! central difference call me % f ( x + delta , fr , cvecr ) call me % f ( x - delta , fl , cvecl ) end select !compute the gradients by first-order finite differences g ( ig ) = ( fr - fl ) / ( fact * delta ( ig ) ) if ( me % m > 0 ) then a (:, ig ) = ( cvecr - cvecl ) / ( fact * delta ( ig ) ) end if end do end select !this is an iteration: !note: the initial guess is reported as iteration 0: if ( associated ( me % report )) call me % report ( i , x , f , c ) !report iteration i = i + 1 ! iteration counter end if !main routine: call slsqp ( me % m , me % meq , la , me % n , x , me % xl , me % xu ,& f , c , g , a , acc , iter , mode ,& me % w , me % l_w , & me % slsqpb , me % linmin , me % alphamin , me % alphamax ,& me % tolf , me % toldf , me % toldx ,& me % max_iter_ls , me % nnls_mode ,& me % infinite_bound ) if ( mode == 1 . or . mode ==- 1 ) then !continue to next call else if ( mode == 0 . and . associated ( me % report )) & call me % report ( i , x , f , c ) !report solution call me % report_message ( mode_to_status_message ( mode )) exit end if if ( me % user_triggered_stop ) then mode = - 2 call me % report_message ( mode_to_status_message ( mode )) me % user_triggered_stop = . false . !have to reset in case !method is called again. exit end if end do istat = mode if ( present ( iterations )) iterations = iter if ( present ( status_message )) status_message = mode_to_status_message ( istat ) end subroutine slsqp_wrapper !******************************************************************************* !******************************************************************************* !> !  Report a message from an [[slsqp_solver]] class. This uses the `iprint` !  variable in the class as the unit number for printing. Note: for fatal errors, !  if no unit is specified, the `error_unit` is used. subroutine report_message ( me , str , ival , rval , fatal ) implicit none class ( slsqp_solver ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: str !! the message to report. integer , intent ( in ), optional :: ival !! optional integer to print after the message. real ( wp ), intent ( in ), optional :: rval !! optional real to print after the message. logical , intent ( in ), optional :: fatal !! if True, then the program is stopped (default=False). logical :: stop_program !! true if the program is to be stopped logical :: write_message !! true if the message is to be printed character ( len = 10 ) :: istr !! string version of `ival` character ( len = 30 ) :: rstr !! string version of `rval` character ( len = :), allocatable :: str_to_write !! the actual message to the printed integer :: istat !! iostat for `write` statements !fatal error check: if ( present ( fatal )) then stop_program = fatal else stop_program = . false . end if !note: if stopping program, then the message is always printed: write_message = me % iprint /= 0 . or . stop_program . or . associated ( me % report_msg ) if ( write_message ) then if ( present ( ival )) then write ( istr , fmt = '(I10)' , iostat = istat ) ival if ( istat /= 0 ) istr = '*****' str_to_write = str // ' ' // trim ( adjustl ( istr )) elseif ( present ( rval )) then write ( istr , fmt = '(F30.16)' , iostat = istat ) rval if ( istat /= 0 ) rstr = '*****' str_to_write = str // ' ' // trim ( adjustl ( rstr )) else str_to_write = str end if if ( me % iprint == 0 . and . stop_program ) then write ( error_unit , '(A)' ) str_to_write !in this case, use the error unit elseif ( me % iprint /= 0 ) then write ( me % iprint , '(A)' , iostat = istat ) str_to_write !user specified unit number if ( istat /= 0 ) then ! attempt to write to error unit if above failed: write ( istr , fmt = '(I10)' , iostat = istat ) me % iprint write ( error_unit , '(A)' ) 'Error writing to unit ' // trim ( adjustl ( istr )) write ( error_unit , '(A)' ) str_to_write end if end if if ( associated ( me % report_msg )) call me % report_msg ( str_to_write ) deallocate ( str_to_write ) if ( stop_program ) error stop 'Fatal Error' end if end subroutine report_message !******************************************************************************* !******************************************************************************* !> !  Convert the [[slsqp]] `mode` flag to a message string. pure function mode_to_status_message ( imode ) result ( message ) implicit none integer , intent ( in ) :: imode character ( len = :), allocatable :: message select case ( imode ) case ( 0 ) !required accuracy for solution obtained message = 'Required accuracy for solution obtained' case ( - 100 ) message = 'Invalid size(x) in slsqp_wrapper' case ( - 101 ) message = 'Invalid linesearch_mode in slsqp_wrapper' case ( - 102 ) message = 'Function is not associated' case ( - 103 ) message = 'Gradient function is not associated' case ( - 104 ) message = 'Invalid gradient mode' case ( - 105 ) message = 'Invalid perturbation step size for finite difference gradients' case ( - 2 ) message = 'User-triggered stop of slsqp' case ( 1 , - 1 ) message = 'In progress' case ( 2 ) message = 'Number of equality constraints larger than n' case ( 3 ) message = 'More than 3*n iterations in lsq subproblem' case ( 4 ) message = 'Inequality constraints incompatible' case ( 5 ) message = 'Singular matrix e in lsq subproblem' case ( 6 ) message = 'Singular matrix c in lsq subproblem' case ( 7 ) message = 'Rank-deficient equality constraint subproblem hfti' case ( 8 ) message = 'Positive directional derivative for linesearch' case ( 9 ) message = 'More than max_iter iterations in slsqp' case default message = 'Unknown slsqp error' end select end function mode_to_status_message !******************************************************************************* !******************************************************************************* end module slsqp_module !*******************************************************************************","tags":"","url":"sourcefile/slsqp_module.f90.html"}]}